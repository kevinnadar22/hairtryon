/**
 * This file was auto-generated by @openapi-qraft/cli.
 * Do not make direct changes to the file.
 */

import type { paths } from "../openapi";
import type { DeepReadonly, InvalidateQueryFilters, MutationFiltersByMutationKey, MutationFiltersByParameters, MutationVariables, OperationError, OperationInfiniteData, PartialParameters, QueryFiltersByParameters, QueryFiltersByQueryKey, QueryFnOptionsByParameters, QueryFnOptionsByQueryKey, RequestFnResponse, ServiceOperationEnsureInfiniteQueryDataOptions, ServiceOperationEnsureQueryDataOptions, ServiceOperationFetchInfiniteQueryOptions, ServiceOperationFetchQueryOptions, ServiceOperationInfiniteQueryKey, ServiceOperationMutationFnOptions, ServiceOperationMutationKey, ServiceOperationQueryKey, ServiceOperationUseMutationOptions, UseQueryOptionsForUseQueries, UseQueryOptionsForUseSuspenseQuery, WithOptional, QraftServiceOperationsToken } from "@openapi-qraft/tanstack-query-react-types";
import type { CancelOptions, DefinedInitialDataInfiniteOptions, DefinedInitialDataOptions, DefinedUseInfiniteQueryResult, DefinedUseQueryResult, InfiniteQueryPageParamsOptions, InvalidateOptions, Mutation, MutationCache, MutationState, NoInfer, QueryState, RefetchOptions, ResetOptions, SetDataOptions, UndefinedInitialDataInfiniteOptions, UndefinedInitialDataOptions, Updater, UseInfiniteQueryResult, UseMutationResult, UseQueryResult, UseSuspenseInfiniteQueryOptions, UseSuspenseInfiniteQueryResult, UseSuspenseQueryOptions, UseSuspenseQueryResult } from "@tanstack/react-query";
export interface ApiService {
    /**
     * @summary Signup
     * @description Register a new user account.
     *
     * Args:
     *     request (SignupRequest): User registration details including email, password, and name.
     *     db (Session): Database session.
     *
     * Returns:
     *     SignupUserResponse: Created user information.
     *
     * Raises:
     *     HTTPException: If email is already registered.
     */
    signupApiV1AuthSignupPost: {
        /**
         * @summary Signup
         * @description Register a new user account.
         *
         * Args:
         *     request (SignupRequest): User registration details including email, password, and name.
         *     db (Session): Database session.
         *
         * Returns:
         *     SignupUserResponse: Created user information.
         *
         * Raises:
         *     HTTPException: If email is already registered.
         */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: ServiceOperationMutationFnOptions<SignupApiV1AuthSignupPostBody, SignupApiV1AuthSignupPostParameters, TMeta, TSignal>, client?: (schema: SignupApiV1AuthSignupPostSchema, options: ServiceOperationMutationFnOptions<SignupApiV1AuthSignupPostBody, SignupApiV1AuthSignupPostParameters, TMeta, TSignal>) => Promise<RequestFnResponse<SignupApiV1AuthSignupPostData, SignupApiV1AuthSignupPostError>>): Promise<RequestFnResponse<SignupApiV1AuthSignupPostData, SignupApiV1AuthSignupPostError>>;
        /**
         * @summary Signup
         * @description Register a new user account.
         *
         * Args:
         *     request (SignupRequest): User registration details including email, password, and name.
         *     db (Session): Database session.
         *
         * Returns:
         *     SignupUserResponse: Created user information.
         *
         * Raises:
         *     HTTPException: If email is already registered.
         */
        getMutationKey(parameters: DeepReadonly<SignupApiV1AuthSignupPostParameters> | void): ServiceOperationMutationKey<SignupApiV1AuthSignupPostSchema, SignupApiV1AuthSignupPostParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Signup
         * @description Register a new user account.
         *
         * Args:
         *     request (SignupRequest): User registration details including email, password, and name.
         *     db (Session): Database session.
         *
         * Returns:
         *     SignupUserResponse: Created user information.
         *
         * Raises:
         *     HTTPException: If email is already registered.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.signupApiV1AuthSignupPost.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.signupApiV1AuthSignupPost.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends SignupApiV1AuthSignupPostBody, TContext = unknown>(parameters: DeepReadonly<SignupApiV1AuthSignupPostParameters>, options?: ServiceOperationUseMutationOptions<SignupApiV1AuthSignupPostSchema, SignupApiV1AuthSignupPostData, SignupApiV1AuthSignupPostParameters, TVariables, OperationError<SignupApiV1AuthSignupPostError>, TContext>): UseMutationResult<SignupApiV1AuthSignupPostData, OperationError<SignupApiV1AuthSignupPostError>, TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Signup
         * @description Register a new user account.
         *
         * Args:
         *     request (SignupRequest): User registration details including email, password, and name.
         *     db (Session): Database session.
         *
         * Returns:
         *     SignupUserResponse: Created user information.
         *
         * Raises:
         *     HTTPException: If email is already registered.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.signupApiV1AuthSignupPost.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.signupApiV1AuthSignupPost.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<SignupApiV1AuthSignupPostBody, SignupApiV1AuthSignupPostParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<SignupApiV1AuthSignupPostSchema, SignupApiV1AuthSignupPostData, SignupApiV1AuthSignupPostParameters, TVariables, OperationError<SignupApiV1AuthSignupPostError>, TContext>): UseMutationResult<SignupApiV1AuthSignupPostData, OperationError<SignupApiV1AuthSignupPostError>, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @summary Signup
         * @description Register a new user account.
         *
         * Args:
         *     request (SignupRequest): User registration details including email, password, and name.
         *     db (Session): Database session.
         *
         * Returns:
         *     SignupUserResponse: Created user information.
         *
         * Raises:
         *     HTTPException: If email is already registered.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const signupApiV1AuthSignupPostTotal = qraft.apiService.signupApiV1AuthSignupPost.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const signupApiV1AuthSignupPostTotal = qraft.apiService.signupApiV1AuthSignupPost.useIsMutating({
         *     parameters: {}
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<SignupApiV1AuthSignupPostBody, SignupApiV1AuthSignupPostData, SignupApiV1AuthSignupPostParameters, OperationError<SignupApiV1AuthSignupPostError>, TContext> | MutationFiltersByMutationKey<SignupApiV1AuthSignupPostSchema, SignupApiV1AuthSignupPostBody, SignupApiV1AuthSignupPostData, SignupApiV1AuthSignupPostParameters, OperationError<SignupApiV1AuthSignupPostError>, TContext>): number;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @summary Signup
         * @description Register a new user account.
         *
         * Args:
         *     request (SignupRequest): User registration details including email, password, and name.
         *     db (Session): Database session.
         *
         * Returns:
         *     SignupUserResponse: Created user information.
         *
         * Raises:
         *     HTTPException: If email is already registered.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const signupApiV1AuthSignupPostPendingMutationVariables = qraft.apiService.signupApiV1AuthSignupPost.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const signupApiV1AuthSignupPostMutationData = qraft.apiService.signupApiV1AuthSignupPost.useMutationState({
         *     filters: {
         *         parameters: {}
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<SignupApiV1AuthSignupPostData, OperationError<SignupApiV1AuthSignupPostError>, MutationVariables<SignupApiV1AuthSignupPostBody, SignupApiV1AuthSignupPostParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<SignupApiV1AuthSignupPostBody, SignupApiV1AuthSignupPostData, SignupApiV1AuthSignupPostParameters, OperationError<SignupApiV1AuthSignupPostError>, TContext> | MutationFiltersByMutationKey<SignupApiV1AuthSignupPostSchema, SignupApiV1AuthSignupPostBody, SignupApiV1AuthSignupPostData, SignupApiV1AuthSignupPostParameters, OperationError<SignupApiV1AuthSignupPostError>, TContext>;
            select?: (mutation: Mutation<SignupApiV1AuthSignupPostData, OperationError<SignupApiV1AuthSignupPostError>, MutationVariables<SignupApiV1AuthSignupPostBody, SignupApiV1AuthSignupPostParameters>, TContext>) => TResult;
        }): Array<TResult>;
        /**
         * @summary Signup
         * @description Register a new user account.
         *
         * Args:
         *     request (SignupRequest): User registration details including email, password, and name.
         *     db (Session): Database session.
         *
         * Returns:
         *     SignupUserResponse: Created user information.
         *
         * Raises:
         *     HTTPException: If email is already registered.
         */
        isMutating<TContext>(filters?: MutationFiltersByParameters<SignupApiV1AuthSignupPostBody, SignupApiV1AuthSignupPostData, SignupApiV1AuthSignupPostParameters, OperationError<SignupApiV1AuthSignupPostError>, TContext> | MutationFiltersByMutationKey<SignupApiV1AuthSignupPostSchema, SignupApiV1AuthSignupPostBody, SignupApiV1AuthSignupPostData, SignupApiV1AuthSignupPostParameters, OperationError<SignupApiV1AuthSignupPostError>, TContext>): number;
        /**
         * Returns a `MutationCache` object that provides access to mutation cache operations
         * for the specific endpoint.
         *
         * @summary Signup
         * @description Register a new user account.
         *
         * Args:
         *     request (SignupRequest): User registration details including email, password, and name.
         *     db (Session): Database session.
         *
         * Returns:
         *     SignupUserResponse: Created user information.
         *
         * Raises:
         *     HTTPException: If email is already registered.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/query-client/getMutationCache|`getMutationCache(...)` documentation}
         *
         * @example Find a mutation with specific parameters
         * ```ts
         * const mutationCache = qraft.apiService.signupApiV1AuthSignupPost.getMutationCache();
         * const mutation = mutationCache.find({
         *     parameters: {}
         * });
         * ```
         *
         * @example Find all mutations for the endpoint
         * ```ts
         * const mutationCache = qraft.apiService.signupApiV1AuthSignupPost.getMutationCache();
         * const mutations = mutationCache.findAll();
         * ```
         */
        getMutationCache(): Omit<MutationCache, "find" | "findAll"> & {
            find<TContext = unknown>(filters: MutationFiltersByParameters<SignupApiV1AuthSignupPostBody, SignupApiV1AuthSignupPostData, SignupApiV1AuthSignupPostParameters, OperationError<SignupApiV1AuthSignupPostError>, TContext> | MutationFiltersByMutationKey<SignupApiV1AuthSignupPostSchema, SignupApiV1AuthSignupPostBody, SignupApiV1AuthSignupPostData, SignupApiV1AuthSignupPostParameters, OperationError<SignupApiV1AuthSignupPostError>, TContext>): Mutation<SignupApiV1AuthSignupPostData, SignupApiV1AuthSignupPostError, MutationVariables<SignupApiV1AuthSignupPostBody, SignupApiV1AuthSignupPostParameters>, TContext> | undefined;
            findAll<TContext = unknown>(filters?: MutationFiltersByParameters<SignupApiV1AuthSignupPostBody, SignupApiV1AuthSignupPostData, SignupApiV1AuthSignupPostParameters, OperationError<SignupApiV1AuthSignupPostError>, TContext> | MutationFiltersByMutationKey<SignupApiV1AuthSignupPostSchema, SignupApiV1AuthSignupPostBody, SignupApiV1AuthSignupPostData, SignupApiV1AuthSignupPostParameters, OperationError<SignupApiV1AuthSignupPostError>, TContext>): Array<Mutation<SignupApiV1AuthSignupPostData, SignupApiV1AuthSignupPostError, MutationVariables<SignupApiV1AuthSignupPostBody, SignupApiV1AuthSignupPostParameters>, TContext>>;
        };
        schema: SignupApiV1AuthSignupPostSchema;
        types: {
            parameters: SignupApiV1AuthSignupPostParameters;
            data: SignupApiV1AuthSignupPostData;
            error: SignupApiV1AuthSignupPostError;
            body: SignupApiV1AuthSignupPostBody;
        };
    };
    /**
     * @summary Request Signup Token
     * @description Request a new signup verification token.
     *
     * Args:
     *     payload (RequestSignupTokenRequest): Request containing the user's email.
     *     db (Session): Database session.
     *
     * Returns:
     *     RequestSignupTokenResponse: New signup verification token.
     */
    requestSignupTokenApiV1AuthRequestSignupTokenPost: {
        /**
         * @summary Request Signup Token
         * @description Request a new signup verification token.
         *
         * Args:
         *     payload (RequestSignupTokenRequest): Request containing the user's email.
         *     db (Session): Database session.
         *
         * Returns:
         *     RequestSignupTokenResponse: New signup verification token.
         */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: ServiceOperationMutationFnOptions<RequestSignupTokenApiV1AuthRequestSignupTokenPostBody, RequestSignupTokenApiV1AuthRequestSignupTokenPostParameters, TMeta, TSignal>, client?: (schema: RequestSignupTokenApiV1AuthRequestSignupTokenPostSchema, options: ServiceOperationMutationFnOptions<RequestSignupTokenApiV1AuthRequestSignupTokenPostBody, RequestSignupTokenApiV1AuthRequestSignupTokenPostParameters, TMeta, TSignal>) => Promise<RequestFnResponse<RequestSignupTokenApiV1AuthRequestSignupTokenPostData, RequestSignupTokenApiV1AuthRequestSignupTokenPostError>>): Promise<RequestFnResponse<RequestSignupTokenApiV1AuthRequestSignupTokenPostData, RequestSignupTokenApiV1AuthRequestSignupTokenPostError>>;
        /**
         * @summary Request Signup Token
         * @description Request a new signup verification token.
         *
         * Args:
         *     payload (RequestSignupTokenRequest): Request containing the user's email.
         *     db (Session): Database session.
         *
         * Returns:
         *     RequestSignupTokenResponse: New signup verification token.
         */
        getMutationKey(parameters: DeepReadonly<RequestSignupTokenApiV1AuthRequestSignupTokenPostParameters> | void): ServiceOperationMutationKey<RequestSignupTokenApiV1AuthRequestSignupTokenPostSchema, RequestSignupTokenApiV1AuthRequestSignupTokenPostParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Request Signup Token
         * @description Request a new signup verification token.
         *
         * Args:
         *     payload (RequestSignupTokenRequest): Request containing the user's email.
         *     db (Session): Database session.
         *
         * Returns:
         *     RequestSignupTokenResponse: New signup verification token.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.requestSignupTokenApiV1AuthRequestSignupTokenPost.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.requestSignupTokenApiV1AuthRequestSignupTokenPost.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends RequestSignupTokenApiV1AuthRequestSignupTokenPostBody, TContext = unknown>(parameters: DeepReadonly<RequestSignupTokenApiV1AuthRequestSignupTokenPostParameters>, options?: ServiceOperationUseMutationOptions<RequestSignupTokenApiV1AuthRequestSignupTokenPostSchema, RequestSignupTokenApiV1AuthRequestSignupTokenPostData, RequestSignupTokenApiV1AuthRequestSignupTokenPostParameters, TVariables, OperationError<RequestSignupTokenApiV1AuthRequestSignupTokenPostError>, TContext>): UseMutationResult<RequestSignupTokenApiV1AuthRequestSignupTokenPostData, OperationError<RequestSignupTokenApiV1AuthRequestSignupTokenPostError>, TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Request Signup Token
         * @description Request a new signup verification token.
         *
         * Args:
         *     payload (RequestSignupTokenRequest): Request containing the user's email.
         *     db (Session): Database session.
         *
         * Returns:
         *     RequestSignupTokenResponse: New signup verification token.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.requestSignupTokenApiV1AuthRequestSignupTokenPost.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.requestSignupTokenApiV1AuthRequestSignupTokenPost.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<RequestSignupTokenApiV1AuthRequestSignupTokenPostBody, RequestSignupTokenApiV1AuthRequestSignupTokenPostParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<RequestSignupTokenApiV1AuthRequestSignupTokenPostSchema, RequestSignupTokenApiV1AuthRequestSignupTokenPostData, RequestSignupTokenApiV1AuthRequestSignupTokenPostParameters, TVariables, OperationError<RequestSignupTokenApiV1AuthRequestSignupTokenPostError>, TContext>): UseMutationResult<RequestSignupTokenApiV1AuthRequestSignupTokenPostData, OperationError<RequestSignupTokenApiV1AuthRequestSignupTokenPostError>, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @summary Request Signup Token
         * @description Request a new signup verification token.
         *
         * Args:
         *     payload (RequestSignupTokenRequest): Request containing the user's email.
         *     db (Session): Database session.
         *
         * Returns:
         *     RequestSignupTokenResponse: New signup verification token.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const requestSignupTokenApiV1AuthRequestSignupTokenPostTotal = qraft.apiService.requestSignupTokenApiV1AuthRequestSignupTokenPost.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const requestSignupTokenApiV1AuthRequestSignupTokenPostTotal = qraft.apiService.requestSignupTokenApiV1AuthRequestSignupTokenPost.useIsMutating({
         *     parameters: {}
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<RequestSignupTokenApiV1AuthRequestSignupTokenPostBody, RequestSignupTokenApiV1AuthRequestSignupTokenPostData, RequestSignupTokenApiV1AuthRequestSignupTokenPostParameters, OperationError<RequestSignupTokenApiV1AuthRequestSignupTokenPostError>, TContext> | MutationFiltersByMutationKey<RequestSignupTokenApiV1AuthRequestSignupTokenPostSchema, RequestSignupTokenApiV1AuthRequestSignupTokenPostBody, RequestSignupTokenApiV1AuthRequestSignupTokenPostData, RequestSignupTokenApiV1AuthRequestSignupTokenPostParameters, OperationError<RequestSignupTokenApiV1AuthRequestSignupTokenPostError>, TContext>): number;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @summary Request Signup Token
         * @description Request a new signup verification token.
         *
         * Args:
         *     payload (RequestSignupTokenRequest): Request containing the user's email.
         *     db (Session): Database session.
         *
         * Returns:
         *     RequestSignupTokenResponse: New signup verification token.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const requestSignupTokenApiV1AuthRequestSignupTokenPostPendingMutationVariables = qraft.apiService.requestSignupTokenApiV1AuthRequestSignupTokenPost.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const requestSignupTokenApiV1AuthRequestSignupTokenPostMutationData = qraft.apiService.requestSignupTokenApiV1AuthRequestSignupTokenPost.useMutationState({
         *     filters: {
         *         parameters: {}
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<RequestSignupTokenApiV1AuthRequestSignupTokenPostData, OperationError<RequestSignupTokenApiV1AuthRequestSignupTokenPostError>, MutationVariables<RequestSignupTokenApiV1AuthRequestSignupTokenPostBody, RequestSignupTokenApiV1AuthRequestSignupTokenPostParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<RequestSignupTokenApiV1AuthRequestSignupTokenPostBody, RequestSignupTokenApiV1AuthRequestSignupTokenPostData, RequestSignupTokenApiV1AuthRequestSignupTokenPostParameters, OperationError<RequestSignupTokenApiV1AuthRequestSignupTokenPostError>, TContext> | MutationFiltersByMutationKey<RequestSignupTokenApiV1AuthRequestSignupTokenPostSchema, RequestSignupTokenApiV1AuthRequestSignupTokenPostBody, RequestSignupTokenApiV1AuthRequestSignupTokenPostData, RequestSignupTokenApiV1AuthRequestSignupTokenPostParameters, OperationError<RequestSignupTokenApiV1AuthRequestSignupTokenPostError>, TContext>;
            select?: (mutation: Mutation<RequestSignupTokenApiV1AuthRequestSignupTokenPostData, OperationError<RequestSignupTokenApiV1AuthRequestSignupTokenPostError>, MutationVariables<RequestSignupTokenApiV1AuthRequestSignupTokenPostBody, RequestSignupTokenApiV1AuthRequestSignupTokenPostParameters>, TContext>) => TResult;
        }): Array<TResult>;
        /**
         * @summary Request Signup Token
         * @description Request a new signup verification token.
         *
         * Args:
         *     payload (RequestSignupTokenRequest): Request containing the user's email.
         *     db (Session): Database session.
         *
         * Returns:
         *     RequestSignupTokenResponse: New signup verification token.
         */
        isMutating<TContext>(filters?: MutationFiltersByParameters<RequestSignupTokenApiV1AuthRequestSignupTokenPostBody, RequestSignupTokenApiV1AuthRequestSignupTokenPostData, RequestSignupTokenApiV1AuthRequestSignupTokenPostParameters, OperationError<RequestSignupTokenApiV1AuthRequestSignupTokenPostError>, TContext> | MutationFiltersByMutationKey<RequestSignupTokenApiV1AuthRequestSignupTokenPostSchema, RequestSignupTokenApiV1AuthRequestSignupTokenPostBody, RequestSignupTokenApiV1AuthRequestSignupTokenPostData, RequestSignupTokenApiV1AuthRequestSignupTokenPostParameters, OperationError<RequestSignupTokenApiV1AuthRequestSignupTokenPostError>, TContext>): number;
        /**
         * Returns a `MutationCache` object that provides access to mutation cache operations
         * for the specific endpoint.
         *
         * @summary Request Signup Token
         * @description Request a new signup verification token.
         *
         * Args:
         *     payload (RequestSignupTokenRequest): Request containing the user's email.
         *     db (Session): Database session.
         *
         * Returns:
         *     RequestSignupTokenResponse: New signup verification token.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/query-client/getMutationCache|`getMutationCache(...)` documentation}
         *
         * @example Find a mutation with specific parameters
         * ```ts
         * const mutationCache = qraft.apiService.requestSignupTokenApiV1AuthRequestSignupTokenPost.getMutationCache();
         * const mutation = mutationCache.find({
         *     parameters: {}
         * });
         * ```
         *
         * @example Find all mutations for the endpoint
         * ```ts
         * const mutationCache = qraft.apiService.requestSignupTokenApiV1AuthRequestSignupTokenPost.getMutationCache();
         * const mutations = mutationCache.findAll();
         * ```
         */
        getMutationCache(): Omit<MutationCache, "find" | "findAll"> & {
            find<TContext = unknown>(filters: MutationFiltersByParameters<RequestSignupTokenApiV1AuthRequestSignupTokenPostBody, RequestSignupTokenApiV1AuthRequestSignupTokenPostData, RequestSignupTokenApiV1AuthRequestSignupTokenPostParameters, OperationError<RequestSignupTokenApiV1AuthRequestSignupTokenPostError>, TContext> | MutationFiltersByMutationKey<RequestSignupTokenApiV1AuthRequestSignupTokenPostSchema, RequestSignupTokenApiV1AuthRequestSignupTokenPostBody, RequestSignupTokenApiV1AuthRequestSignupTokenPostData, RequestSignupTokenApiV1AuthRequestSignupTokenPostParameters, OperationError<RequestSignupTokenApiV1AuthRequestSignupTokenPostError>, TContext>): Mutation<RequestSignupTokenApiV1AuthRequestSignupTokenPostData, RequestSignupTokenApiV1AuthRequestSignupTokenPostError, MutationVariables<RequestSignupTokenApiV1AuthRequestSignupTokenPostBody, RequestSignupTokenApiV1AuthRequestSignupTokenPostParameters>, TContext> | undefined;
            findAll<TContext = unknown>(filters?: MutationFiltersByParameters<RequestSignupTokenApiV1AuthRequestSignupTokenPostBody, RequestSignupTokenApiV1AuthRequestSignupTokenPostData, RequestSignupTokenApiV1AuthRequestSignupTokenPostParameters, OperationError<RequestSignupTokenApiV1AuthRequestSignupTokenPostError>, TContext> | MutationFiltersByMutationKey<RequestSignupTokenApiV1AuthRequestSignupTokenPostSchema, RequestSignupTokenApiV1AuthRequestSignupTokenPostBody, RequestSignupTokenApiV1AuthRequestSignupTokenPostData, RequestSignupTokenApiV1AuthRequestSignupTokenPostParameters, OperationError<RequestSignupTokenApiV1AuthRequestSignupTokenPostError>, TContext>): Array<Mutation<RequestSignupTokenApiV1AuthRequestSignupTokenPostData, RequestSignupTokenApiV1AuthRequestSignupTokenPostError, MutationVariables<RequestSignupTokenApiV1AuthRequestSignupTokenPostBody, RequestSignupTokenApiV1AuthRequestSignupTokenPostParameters>, TContext>>;
        };
        schema: RequestSignupTokenApiV1AuthRequestSignupTokenPostSchema;
        types: {
            parameters: RequestSignupTokenApiV1AuthRequestSignupTokenPostParameters;
            data: RequestSignupTokenApiV1AuthRequestSignupTokenPostData;
            error: RequestSignupTokenApiV1AuthRequestSignupTokenPostError;
            body: RequestSignupTokenApiV1AuthRequestSignupTokenPostBody;
        };
    };
    /**
     * @summary Verify Signup
     * @description Verify user's email using the signup verification code.
     *
     * Args:
     *     payload (VerifyEmailRequest): JWT token containing the verification code.
     *     auth_service (AuthService): Authentication service.
     *
     * Returns:
     *     CommentResponse: Confirmation message about successful verification.
     *
     * Raises:
     *     HTTPException: If verification code is invalid.
     */
    verifySignupApiV1AuthVerifySignupPost: {
        /**
         * @summary Verify Signup
         * @description Verify user's email using the signup verification code.
         *
         * Args:
         *     payload (VerifyEmailRequest): JWT token containing the verification code.
         *     auth_service (AuthService): Authentication service.
         *
         * Returns:
         *     CommentResponse: Confirmation message about successful verification.
         *
         * Raises:
         *     HTTPException: If verification code is invalid.
         */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: ServiceOperationMutationFnOptions<VerifySignupApiV1AuthVerifySignupPostBody, VerifySignupApiV1AuthVerifySignupPostParameters, TMeta, TSignal>, client?: (schema: VerifySignupApiV1AuthVerifySignupPostSchema, options: ServiceOperationMutationFnOptions<VerifySignupApiV1AuthVerifySignupPostBody, VerifySignupApiV1AuthVerifySignupPostParameters, TMeta, TSignal>) => Promise<RequestFnResponse<VerifySignupApiV1AuthVerifySignupPostData, VerifySignupApiV1AuthVerifySignupPostError>>): Promise<RequestFnResponse<VerifySignupApiV1AuthVerifySignupPostData, VerifySignupApiV1AuthVerifySignupPostError>>;
        /**
         * @summary Verify Signup
         * @description Verify user's email using the signup verification code.
         *
         * Args:
         *     payload (VerifyEmailRequest): JWT token containing the verification code.
         *     auth_service (AuthService): Authentication service.
         *
         * Returns:
         *     CommentResponse: Confirmation message about successful verification.
         *
         * Raises:
         *     HTTPException: If verification code is invalid.
         */
        getMutationKey(parameters: DeepReadonly<VerifySignupApiV1AuthVerifySignupPostParameters> | void): ServiceOperationMutationKey<VerifySignupApiV1AuthVerifySignupPostSchema, VerifySignupApiV1AuthVerifySignupPostParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Verify Signup
         * @description Verify user's email using the signup verification code.
         *
         * Args:
         *     payload (VerifyEmailRequest): JWT token containing the verification code.
         *     auth_service (AuthService): Authentication service.
         *
         * Returns:
         *     CommentResponse: Confirmation message about successful verification.
         *
         * Raises:
         *     HTTPException: If verification code is invalid.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.verifySignupApiV1AuthVerifySignupPost.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.verifySignupApiV1AuthVerifySignupPost.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends VerifySignupApiV1AuthVerifySignupPostBody, TContext = unknown>(parameters: DeepReadonly<VerifySignupApiV1AuthVerifySignupPostParameters>, options?: ServiceOperationUseMutationOptions<VerifySignupApiV1AuthVerifySignupPostSchema, VerifySignupApiV1AuthVerifySignupPostData, VerifySignupApiV1AuthVerifySignupPostParameters, TVariables, OperationError<VerifySignupApiV1AuthVerifySignupPostError>, TContext>): UseMutationResult<VerifySignupApiV1AuthVerifySignupPostData, OperationError<VerifySignupApiV1AuthVerifySignupPostError>, TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Verify Signup
         * @description Verify user's email using the signup verification code.
         *
         * Args:
         *     payload (VerifyEmailRequest): JWT token containing the verification code.
         *     auth_service (AuthService): Authentication service.
         *
         * Returns:
         *     CommentResponse: Confirmation message about successful verification.
         *
         * Raises:
         *     HTTPException: If verification code is invalid.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.verifySignupApiV1AuthVerifySignupPost.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.verifySignupApiV1AuthVerifySignupPost.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<VerifySignupApiV1AuthVerifySignupPostBody, VerifySignupApiV1AuthVerifySignupPostParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<VerifySignupApiV1AuthVerifySignupPostSchema, VerifySignupApiV1AuthVerifySignupPostData, VerifySignupApiV1AuthVerifySignupPostParameters, TVariables, OperationError<VerifySignupApiV1AuthVerifySignupPostError>, TContext>): UseMutationResult<VerifySignupApiV1AuthVerifySignupPostData, OperationError<VerifySignupApiV1AuthVerifySignupPostError>, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @summary Verify Signup
         * @description Verify user's email using the signup verification code.
         *
         * Args:
         *     payload (VerifyEmailRequest): JWT token containing the verification code.
         *     auth_service (AuthService): Authentication service.
         *
         * Returns:
         *     CommentResponse: Confirmation message about successful verification.
         *
         * Raises:
         *     HTTPException: If verification code is invalid.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const verifySignupApiV1AuthVerifySignupPostTotal = qraft.apiService.verifySignupApiV1AuthVerifySignupPost.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const verifySignupApiV1AuthVerifySignupPostTotal = qraft.apiService.verifySignupApiV1AuthVerifySignupPost.useIsMutating({
         *     parameters: {}
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<VerifySignupApiV1AuthVerifySignupPostBody, VerifySignupApiV1AuthVerifySignupPostData, VerifySignupApiV1AuthVerifySignupPostParameters, OperationError<VerifySignupApiV1AuthVerifySignupPostError>, TContext> | MutationFiltersByMutationKey<VerifySignupApiV1AuthVerifySignupPostSchema, VerifySignupApiV1AuthVerifySignupPostBody, VerifySignupApiV1AuthVerifySignupPostData, VerifySignupApiV1AuthVerifySignupPostParameters, OperationError<VerifySignupApiV1AuthVerifySignupPostError>, TContext>): number;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @summary Verify Signup
         * @description Verify user's email using the signup verification code.
         *
         * Args:
         *     payload (VerifyEmailRequest): JWT token containing the verification code.
         *     auth_service (AuthService): Authentication service.
         *
         * Returns:
         *     CommentResponse: Confirmation message about successful verification.
         *
         * Raises:
         *     HTTPException: If verification code is invalid.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const verifySignupApiV1AuthVerifySignupPostPendingMutationVariables = qraft.apiService.verifySignupApiV1AuthVerifySignupPost.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const verifySignupApiV1AuthVerifySignupPostMutationData = qraft.apiService.verifySignupApiV1AuthVerifySignupPost.useMutationState({
         *     filters: {
         *         parameters: {}
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<VerifySignupApiV1AuthVerifySignupPostData, OperationError<VerifySignupApiV1AuthVerifySignupPostError>, MutationVariables<VerifySignupApiV1AuthVerifySignupPostBody, VerifySignupApiV1AuthVerifySignupPostParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<VerifySignupApiV1AuthVerifySignupPostBody, VerifySignupApiV1AuthVerifySignupPostData, VerifySignupApiV1AuthVerifySignupPostParameters, OperationError<VerifySignupApiV1AuthVerifySignupPostError>, TContext> | MutationFiltersByMutationKey<VerifySignupApiV1AuthVerifySignupPostSchema, VerifySignupApiV1AuthVerifySignupPostBody, VerifySignupApiV1AuthVerifySignupPostData, VerifySignupApiV1AuthVerifySignupPostParameters, OperationError<VerifySignupApiV1AuthVerifySignupPostError>, TContext>;
            select?: (mutation: Mutation<VerifySignupApiV1AuthVerifySignupPostData, OperationError<VerifySignupApiV1AuthVerifySignupPostError>, MutationVariables<VerifySignupApiV1AuthVerifySignupPostBody, VerifySignupApiV1AuthVerifySignupPostParameters>, TContext>) => TResult;
        }): Array<TResult>;
        /**
         * @summary Verify Signup
         * @description Verify user's email using the signup verification code.
         *
         * Args:
         *     payload (VerifyEmailRequest): JWT token containing the verification code.
         *     auth_service (AuthService): Authentication service.
         *
         * Returns:
         *     CommentResponse: Confirmation message about successful verification.
         *
         * Raises:
         *     HTTPException: If verification code is invalid.
         */
        isMutating<TContext>(filters?: MutationFiltersByParameters<VerifySignupApiV1AuthVerifySignupPostBody, VerifySignupApiV1AuthVerifySignupPostData, VerifySignupApiV1AuthVerifySignupPostParameters, OperationError<VerifySignupApiV1AuthVerifySignupPostError>, TContext> | MutationFiltersByMutationKey<VerifySignupApiV1AuthVerifySignupPostSchema, VerifySignupApiV1AuthVerifySignupPostBody, VerifySignupApiV1AuthVerifySignupPostData, VerifySignupApiV1AuthVerifySignupPostParameters, OperationError<VerifySignupApiV1AuthVerifySignupPostError>, TContext>): number;
        /**
         * Returns a `MutationCache` object that provides access to mutation cache operations
         * for the specific endpoint.
         *
         * @summary Verify Signup
         * @description Verify user's email using the signup verification code.
         *
         * Args:
         *     payload (VerifyEmailRequest): JWT token containing the verification code.
         *     auth_service (AuthService): Authentication service.
         *
         * Returns:
         *     CommentResponse: Confirmation message about successful verification.
         *
         * Raises:
         *     HTTPException: If verification code is invalid.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/query-client/getMutationCache|`getMutationCache(...)` documentation}
         *
         * @example Find a mutation with specific parameters
         * ```ts
         * const mutationCache = qraft.apiService.verifySignupApiV1AuthVerifySignupPost.getMutationCache();
         * const mutation = mutationCache.find({
         *     parameters: {}
         * });
         * ```
         *
         * @example Find all mutations for the endpoint
         * ```ts
         * const mutationCache = qraft.apiService.verifySignupApiV1AuthVerifySignupPost.getMutationCache();
         * const mutations = mutationCache.findAll();
         * ```
         */
        getMutationCache(): Omit<MutationCache, "find" | "findAll"> & {
            find<TContext = unknown>(filters: MutationFiltersByParameters<VerifySignupApiV1AuthVerifySignupPostBody, VerifySignupApiV1AuthVerifySignupPostData, VerifySignupApiV1AuthVerifySignupPostParameters, OperationError<VerifySignupApiV1AuthVerifySignupPostError>, TContext> | MutationFiltersByMutationKey<VerifySignupApiV1AuthVerifySignupPostSchema, VerifySignupApiV1AuthVerifySignupPostBody, VerifySignupApiV1AuthVerifySignupPostData, VerifySignupApiV1AuthVerifySignupPostParameters, OperationError<VerifySignupApiV1AuthVerifySignupPostError>, TContext>): Mutation<VerifySignupApiV1AuthVerifySignupPostData, VerifySignupApiV1AuthVerifySignupPostError, MutationVariables<VerifySignupApiV1AuthVerifySignupPostBody, VerifySignupApiV1AuthVerifySignupPostParameters>, TContext> | undefined;
            findAll<TContext = unknown>(filters?: MutationFiltersByParameters<VerifySignupApiV1AuthVerifySignupPostBody, VerifySignupApiV1AuthVerifySignupPostData, VerifySignupApiV1AuthVerifySignupPostParameters, OperationError<VerifySignupApiV1AuthVerifySignupPostError>, TContext> | MutationFiltersByMutationKey<VerifySignupApiV1AuthVerifySignupPostSchema, VerifySignupApiV1AuthVerifySignupPostBody, VerifySignupApiV1AuthVerifySignupPostData, VerifySignupApiV1AuthVerifySignupPostParameters, OperationError<VerifySignupApiV1AuthVerifySignupPostError>, TContext>): Array<Mutation<VerifySignupApiV1AuthVerifySignupPostData, VerifySignupApiV1AuthVerifySignupPostError, MutationVariables<VerifySignupApiV1AuthVerifySignupPostBody, VerifySignupApiV1AuthVerifySignupPostParameters>, TContext>>;
        };
        schema: VerifySignupApiV1AuthVerifySignupPostSchema;
        types: {
            parameters: VerifySignupApiV1AuthVerifySignupPostParameters;
            data: VerifySignupApiV1AuthVerifySignupPostData;
            error: VerifySignupApiV1AuthVerifySignupPostError;
            body: VerifySignupApiV1AuthVerifySignupPostBody;
        };
    };
    /**
     * @summary Request Login Token
     * @description Request a new login verification token.
     *
     * Args:
     *     payload (RequestLoginTokenRequest): Request containing the user's email and password.
     *     db (Session): Database session.
     *
     * Returns:
     *     RequestLoginTokenResponse: New login verification token.
     */
    requestLoginTokenApiV1AuthRequestLoginTokenPost: {
        /**
         * @summary Request Login Token
         * @description Request a new login verification token.
         *
         * Args:
         *     payload (RequestLoginTokenRequest): Request containing the user's email and password.
         *     db (Session): Database session.
         *
         * Returns:
         *     RequestLoginTokenResponse: New login verification token.
         */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: ServiceOperationMutationFnOptions<RequestLoginTokenApiV1AuthRequestLoginTokenPostBody, RequestLoginTokenApiV1AuthRequestLoginTokenPostParameters, TMeta, TSignal>, client?: (schema: RequestLoginTokenApiV1AuthRequestLoginTokenPostSchema, options: ServiceOperationMutationFnOptions<RequestLoginTokenApiV1AuthRequestLoginTokenPostBody, RequestLoginTokenApiV1AuthRequestLoginTokenPostParameters, TMeta, TSignal>) => Promise<RequestFnResponse<RequestLoginTokenApiV1AuthRequestLoginTokenPostData, RequestLoginTokenApiV1AuthRequestLoginTokenPostError>>): Promise<RequestFnResponse<RequestLoginTokenApiV1AuthRequestLoginTokenPostData, RequestLoginTokenApiV1AuthRequestLoginTokenPostError>>;
        /**
         * @summary Request Login Token
         * @description Request a new login verification token.
         *
         * Args:
         *     payload (RequestLoginTokenRequest): Request containing the user's email and password.
         *     db (Session): Database session.
         *
         * Returns:
         *     RequestLoginTokenResponse: New login verification token.
         */
        getMutationKey(parameters: DeepReadonly<RequestLoginTokenApiV1AuthRequestLoginTokenPostParameters> | void): ServiceOperationMutationKey<RequestLoginTokenApiV1AuthRequestLoginTokenPostSchema, RequestLoginTokenApiV1AuthRequestLoginTokenPostParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Request Login Token
         * @description Request a new login verification token.
         *
         * Args:
         *     payload (RequestLoginTokenRequest): Request containing the user's email and password.
         *     db (Session): Database session.
         *
         * Returns:
         *     RequestLoginTokenResponse: New login verification token.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.requestLoginTokenApiV1AuthRequestLoginTokenPost.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.requestLoginTokenApiV1AuthRequestLoginTokenPost.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends RequestLoginTokenApiV1AuthRequestLoginTokenPostBody, TContext = unknown>(parameters: DeepReadonly<RequestLoginTokenApiV1AuthRequestLoginTokenPostParameters>, options?: ServiceOperationUseMutationOptions<RequestLoginTokenApiV1AuthRequestLoginTokenPostSchema, RequestLoginTokenApiV1AuthRequestLoginTokenPostData, RequestLoginTokenApiV1AuthRequestLoginTokenPostParameters, TVariables, OperationError<RequestLoginTokenApiV1AuthRequestLoginTokenPostError>, TContext>): UseMutationResult<RequestLoginTokenApiV1AuthRequestLoginTokenPostData, OperationError<RequestLoginTokenApiV1AuthRequestLoginTokenPostError>, TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Request Login Token
         * @description Request a new login verification token.
         *
         * Args:
         *     payload (RequestLoginTokenRequest): Request containing the user's email and password.
         *     db (Session): Database session.
         *
         * Returns:
         *     RequestLoginTokenResponse: New login verification token.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.requestLoginTokenApiV1AuthRequestLoginTokenPost.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.requestLoginTokenApiV1AuthRequestLoginTokenPost.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<RequestLoginTokenApiV1AuthRequestLoginTokenPostBody, RequestLoginTokenApiV1AuthRequestLoginTokenPostParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<RequestLoginTokenApiV1AuthRequestLoginTokenPostSchema, RequestLoginTokenApiV1AuthRequestLoginTokenPostData, RequestLoginTokenApiV1AuthRequestLoginTokenPostParameters, TVariables, OperationError<RequestLoginTokenApiV1AuthRequestLoginTokenPostError>, TContext>): UseMutationResult<RequestLoginTokenApiV1AuthRequestLoginTokenPostData, OperationError<RequestLoginTokenApiV1AuthRequestLoginTokenPostError>, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @summary Request Login Token
         * @description Request a new login verification token.
         *
         * Args:
         *     payload (RequestLoginTokenRequest): Request containing the user's email and password.
         *     db (Session): Database session.
         *
         * Returns:
         *     RequestLoginTokenResponse: New login verification token.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const requestLoginTokenApiV1AuthRequestLoginTokenPostTotal = qraft.apiService.requestLoginTokenApiV1AuthRequestLoginTokenPost.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const requestLoginTokenApiV1AuthRequestLoginTokenPostTotal = qraft.apiService.requestLoginTokenApiV1AuthRequestLoginTokenPost.useIsMutating({
         *     parameters: {}
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<RequestLoginTokenApiV1AuthRequestLoginTokenPostBody, RequestLoginTokenApiV1AuthRequestLoginTokenPostData, RequestLoginTokenApiV1AuthRequestLoginTokenPostParameters, OperationError<RequestLoginTokenApiV1AuthRequestLoginTokenPostError>, TContext> | MutationFiltersByMutationKey<RequestLoginTokenApiV1AuthRequestLoginTokenPostSchema, RequestLoginTokenApiV1AuthRequestLoginTokenPostBody, RequestLoginTokenApiV1AuthRequestLoginTokenPostData, RequestLoginTokenApiV1AuthRequestLoginTokenPostParameters, OperationError<RequestLoginTokenApiV1AuthRequestLoginTokenPostError>, TContext>): number;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @summary Request Login Token
         * @description Request a new login verification token.
         *
         * Args:
         *     payload (RequestLoginTokenRequest): Request containing the user's email and password.
         *     db (Session): Database session.
         *
         * Returns:
         *     RequestLoginTokenResponse: New login verification token.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const requestLoginTokenApiV1AuthRequestLoginTokenPostPendingMutationVariables = qraft.apiService.requestLoginTokenApiV1AuthRequestLoginTokenPost.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const requestLoginTokenApiV1AuthRequestLoginTokenPostMutationData = qraft.apiService.requestLoginTokenApiV1AuthRequestLoginTokenPost.useMutationState({
         *     filters: {
         *         parameters: {}
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<RequestLoginTokenApiV1AuthRequestLoginTokenPostData, OperationError<RequestLoginTokenApiV1AuthRequestLoginTokenPostError>, MutationVariables<RequestLoginTokenApiV1AuthRequestLoginTokenPostBody, RequestLoginTokenApiV1AuthRequestLoginTokenPostParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<RequestLoginTokenApiV1AuthRequestLoginTokenPostBody, RequestLoginTokenApiV1AuthRequestLoginTokenPostData, RequestLoginTokenApiV1AuthRequestLoginTokenPostParameters, OperationError<RequestLoginTokenApiV1AuthRequestLoginTokenPostError>, TContext> | MutationFiltersByMutationKey<RequestLoginTokenApiV1AuthRequestLoginTokenPostSchema, RequestLoginTokenApiV1AuthRequestLoginTokenPostBody, RequestLoginTokenApiV1AuthRequestLoginTokenPostData, RequestLoginTokenApiV1AuthRequestLoginTokenPostParameters, OperationError<RequestLoginTokenApiV1AuthRequestLoginTokenPostError>, TContext>;
            select?: (mutation: Mutation<RequestLoginTokenApiV1AuthRequestLoginTokenPostData, OperationError<RequestLoginTokenApiV1AuthRequestLoginTokenPostError>, MutationVariables<RequestLoginTokenApiV1AuthRequestLoginTokenPostBody, RequestLoginTokenApiV1AuthRequestLoginTokenPostParameters>, TContext>) => TResult;
        }): Array<TResult>;
        /**
         * @summary Request Login Token
         * @description Request a new login verification token.
         *
         * Args:
         *     payload (RequestLoginTokenRequest): Request containing the user's email and password.
         *     db (Session): Database session.
         *
         * Returns:
         *     RequestLoginTokenResponse: New login verification token.
         */
        isMutating<TContext>(filters?: MutationFiltersByParameters<RequestLoginTokenApiV1AuthRequestLoginTokenPostBody, RequestLoginTokenApiV1AuthRequestLoginTokenPostData, RequestLoginTokenApiV1AuthRequestLoginTokenPostParameters, OperationError<RequestLoginTokenApiV1AuthRequestLoginTokenPostError>, TContext> | MutationFiltersByMutationKey<RequestLoginTokenApiV1AuthRequestLoginTokenPostSchema, RequestLoginTokenApiV1AuthRequestLoginTokenPostBody, RequestLoginTokenApiV1AuthRequestLoginTokenPostData, RequestLoginTokenApiV1AuthRequestLoginTokenPostParameters, OperationError<RequestLoginTokenApiV1AuthRequestLoginTokenPostError>, TContext>): number;
        /**
         * Returns a `MutationCache` object that provides access to mutation cache operations
         * for the specific endpoint.
         *
         * @summary Request Login Token
         * @description Request a new login verification token.
         *
         * Args:
         *     payload (RequestLoginTokenRequest): Request containing the user's email and password.
         *     db (Session): Database session.
         *
         * Returns:
         *     RequestLoginTokenResponse: New login verification token.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/query-client/getMutationCache|`getMutationCache(...)` documentation}
         *
         * @example Find a mutation with specific parameters
         * ```ts
         * const mutationCache = qraft.apiService.requestLoginTokenApiV1AuthRequestLoginTokenPost.getMutationCache();
         * const mutation = mutationCache.find({
         *     parameters: {}
         * });
         * ```
         *
         * @example Find all mutations for the endpoint
         * ```ts
         * const mutationCache = qraft.apiService.requestLoginTokenApiV1AuthRequestLoginTokenPost.getMutationCache();
         * const mutations = mutationCache.findAll();
         * ```
         */
        getMutationCache(): Omit<MutationCache, "find" | "findAll"> & {
            find<TContext = unknown>(filters: MutationFiltersByParameters<RequestLoginTokenApiV1AuthRequestLoginTokenPostBody, RequestLoginTokenApiV1AuthRequestLoginTokenPostData, RequestLoginTokenApiV1AuthRequestLoginTokenPostParameters, OperationError<RequestLoginTokenApiV1AuthRequestLoginTokenPostError>, TContext> | MutationFiltersByMutationKey<RequestLoginTokenApiV1AuthRequestLoginTokenPostSchema, RequestLoginTokenApiV1AuthRequestLoginTokenPostBody, RequestLoginTokenApiV1AuthRequestLoginTokenPostData, RequestLoginTokenApiV1AuthRequestLoginTokenPostParameters, OperationError<RequestLoginTokenApiV1AuthRequestLoginTokenPostError>, TContext>): Mutation<RequestLoginTokenApiV1AuthRequestLoginTokenPostData, RequestLoginTokenApiV1AuthRequestLoginTokenPostError, MutationVariables<RequestLoginTokenApiV1AuthRequestLoginTokenPostBody, RequestLoginTokenApiV1AuthRequestLoginTokenPostParameters>, TContext> | undefined;
            findAll<TContext = unknown>(filters?: MutationFiltersByParameters<RequestLoginTokenApiV1AuthRequestLoginTokenPostBody, RequestLoginTokenApiV1AuthRequestLoginTokenPostData, RequestLoginTokenApiV1AuthRequestLoginTokenPostParameters, OperationError<RequestLoginTokenApiV1AuthRequestLoginTokenPostError>, TContext> | MutationFiltersByMutationKey<RequestLoginTokenApiV1AuthRequestLoginTokenPostSchema, RequestLoginTokenApiV1AuthRequestLoginTokenPostBody, RequestLoginTokenApiV1AuthRequestLoginTokenPostData, RequestLoginTokenApiV1AuthRequestLoginTokenPostParameters, OperationError<RequestLoginTokenApiV1AuthRequestLoginTokenPostError>, TContext>): Array<Mutation<RequestLoginTokenApiV1AuthRequestLoginTokenPostData, RequestLoginTokenApiV1AuthRequestLoginTokenPostError, MutationVariables<RequestLoginTokenApiV1AuthRequestLoginTokenPostBody, RequestLoginTokenApiV1AuthRequestLoginTokenPostParameters>, TContext>>;
        };
        schema: RequestLoginTokenApiV1AuthRequestLoginTokenPostSchema;
        types: {
            parameters: RequestLoginTokenApiV1AuthRequestLoginTokenPostParameters;
            data: RequestLoginTokenApiV1AuthRequestLoginTokenPostData;
            error: RequestLoginTokenApiV1AuthRequestLoginTokenPostError;
            body: RequestLoginTokenApiV1AuthRequestLoginTokenPostBody;
        };
    };
    /**
     * @summary Verify Login
     * @description Verify user's email using the login verification code.
     *
     * Args:
     *     payload (VerifyLoginRequest): JWT token containing the verification code.
     *     auth_service (AuthService): Authentication service.
     *
     * Returns:
     *     VerifyLoginResponse: Response containing access token and verification status.
     *
     * Raises:
     *     HTTPException: If verification code is invalid.
     */
    verifyLoginApiV1AuthVerifyLoginPost: {
        /**
         * @summary Verify Login
         * @description Verify user's email using the login verification code.
         *
         * Args:
         *     payload (VerifyLoginRequest): JWT token containing the verification code.
         *     auth_service (AuthService): Authentication service.
         *
         * Returns:
         *     VerifyLoginResponse: Response containing access token and verification status.
         *
         * Raises:
         *     HTTPException: If verification code is invalid.
         */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: ServiceOperationMutationFnOptions<VerifyLoginApiV1AuthVerifyLoginPostBody, VerifyLoginApiV1AuthVerifyLoginPostParameters, TMeta, TSignal>, client?: (schema: VerifyLoginApiV1AuthVerifyLoginPostSchema, options: ServiceOperationMutationFnOptions<VerifyLoginApiV1AuthVerifyLoginPostBody, VerifyLoginApiV1AuthVerifyLoginPostParameters, TMeta, TSignal>) => Promise<RequestFnResponse<VerifyLoginApiV1AuthVerifyLoginPostData, VerifyLoginApiV1AuthVerifyLoginPostError>>): Promise<RequestFnResponse<VerifyLoginApiV1AuthVerifyLoginPostData, VerifyLoginApiV1AuthVerifyLoginPostError>>;
        /**
         * @summary Verify Login
         * @description Verify user's email using the login verification code.
         *
         * Args:
         *     payload (VerifyLoginRequest): JWT token containing the verification code.
         *     auth_service (AuthService): Authentication service.
         *
         * Returns:
         *     VerifyLoginResponse: Response containing access token and verification status.
         *
         * Raises:
         *     HTTPException: If verification code is invalid.
         */
        getMutationKey(parameters: DeepReadonly<VerifyLoginApiV1AuthVerifyLoginPostParameters> | void): ServiceOperationMutationKey<VerifyLoginApiV1AuthVerifyLoginPostSchema, VerifyLoginApiV1AuthVerifyLoginPostParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Verify Login
         * @description Verify user's email using the login verification code.
         *
         * Args:
         *     payload (VerifyLoginRequest): JWT token containing the verification code.
         *     auth_service (AuthService): Authentication service.
         *
         * Returns:
         *     VerifyLoginResponse: Response containing access token and verification status.
         *
         * Raises:
         *     HTTPException: If verification code is invalid.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.verifyLoginApiV1AuthVerifyLoginPost.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.verifyLoginApiV1AuthVerifyLoginPost.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends VerifyLoginApiV1AuthVerifyLoginPostBody, TContext = unknown>(parameters: DeepReadonly<VerifyLoginApiV1AuthVerifyLoginPostParameters>, options?: ServiceOperationUseMutationOptions<VerifyLoginApiV1AuthVerifyLoginPostSchema, VerifyLoginApiV1AuthVerifyLoginPostData, VerifyLoginApiV1AuthVerifyLoginPostParameters, TVariables, OperationError<VerifyLoginApiV1AuthVerifyLoginPostError>, TContext>): UseMutationResult<VerifyLoginApiV1AuthVerifyLoginPostData, OperationError<VerifyLoginApiV1AuthVerifyLoginPostError>, TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Verify Login
         * @description Verify user's email using the login verification code.
         *
         * Args:
         *     payload (VerifyLoginRequest): JWT token containing the verification code.
         *     auth_service (AuthService): Authentication service.
         *
         * Returns:
         *     VerifyLoginResponse: Response containing access token and verification status.
         *
         * Raises:
         *     HTTPException: If verification code is invalid.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.verifyLoginApiV1AuthVerifyLoginPost.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.verifyLoginApiV1AuthVerifyLoginPost.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<VerifyLoginApiV1AuthVerifyLoginPostBody, VerifyLoginApiV1AuthVerifyLoginPostParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<VerifyLoginApiV1AuthVerifyLoginPostSchema, VerifyLoginApiV1AuthVerifyLoginPostData, VerifyLoginApiV1AuthVerifyLoginPostParameters, TVariables, OperationError<VerifyLoginApiV1AuthVerifyLoginPostError>, TContext>): UseMutationResult<VerifyLoginApiV1AuthVerifyLoginPostData, OperationError<VerifyLoginApiV1AuthVerifyLoginPostError>, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @summary Verify Login
         * @description Verify user's email using the login verification code.
         *
         * Args:
         *     payload (VerifyLoginRequest): JWT token containing the verification code.
         *     auth_service (AuthService): Authentication service.
         *
         * Returns:
         *     VerifyLoginResponse: Response containing access token and verification status.
         *
         * Raises:
         *     HTTPException: If verification code is invalid.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const verifyLoginApiV1AuthVerifyLoginPostTotal = qraft.apiService.verifyLoginApiV1AuthVerifyLoginPost.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const verifyLoginApiV1AuthVerifyLoginPostTotal = qraft.apiService.verifyLoginApiV1AuthVerifyLoginPost.useIsMutating({
         *     parameters: {}
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<VerifyLoginApiV1AuthVerifyLoginPostBody, VerifyLoginApiV1AuthVerifyLoginPostData, VerifyLoginApiV1AuthVerifyLoginPostParameters, OperationError<VerifyLoginApiV1AuthVerifyLoginPostError>, TContext> | MutationFiltersByMutationKey<VerifyLoginApiV1AuthVerifyLoginPostSchema, VerifyLoginApiV1AuthVerifyLoginPostBody, VerifyLoginApiV1AuthVerifyLoginPostData, VerifyLoginApiV1AuthVerifyLoginPostParameters, OperationError<VerifyLoginApiV1AuthVerifyLoginPostError>, TContext>): number;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @summary Verify Login
         * @description Verify user's email using the login verification code.
         *
         * Args:
         *     payload (VerifyLoginRequest): JWT token containing the verification code.
         *     auth_service (AuthService): Authentication service.
         *
         * Returns:
         *     VerifyLoginResponse: Response containing access token and verification status.
         *
         * Raises:
         *     HTTPException: If verification code is invalid.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const verifyLoginApiV1AuthVerifyLoginPostPendingMutationVariables = qraft.apiService.verifyLoginApiV1AuthVerifyLoginPost.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const verifyLoginApiV1AuthVerifyLoginPostMutationData = qraft.apiService.verifyLoginApiV1AuthVerifyLoginPost.useMutationState({
         *     filters: {
         *         parameters: {}
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<VerifyLoginApiV1AuthVerifyLoginPostData, OperationError<VerifyLoginApiV1AuthVerifyLoginPostError>, MutationVariables<VerifyLoginApiV1AuthVerifyLoginPostBody, VerifyLoginApiV1AuthVerifyLoginPostParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<VerifyLoginApiV1AuthVerifyLoginPostBody, VerifyLoginApiV1AuthVerifyLoginPostData, VerifyLoginApiV1AuthVerifyLoginPostParameters, OperationError<VerifyLoginApiV1AuthVerifyLoginPostError>, TContext> | MutationFiltersByMutationKey<VerifyLoginApiV1AuthVerifyLoginPostSchema, VerifyLoginApiV1AuthVerifyLoginPostBody, VerifyLoginApiV1AuthVerifyLoginPostData, VerifyLoginApiV1AuthVerifyLoginPostParameters, OperationError<VerifyLoginApiV1AuthVerifyLoginPostError>, TContext>;
            select?: (mutation: Mutation<VerifyLoginApiV1AuthVerifyLoginPostData, OperationError<VerifyLoginApiV1AuthVerifyLoginPostError>, MutationVariables<VerifyLoginApiV1AuthVerifyLoginPostBody, VerifyLoginApiV1AuthVerifyLoginPostParameters>, TContext>) => TResult;
        }): Array<TResult>;
        /**
         * @summary Verify Login
         * @description Verify user's email using the login verification code.
         *
         * Args:
         *     payload (VerifyLoginRequest): JWT token containing the verification code.
         *     auth_service (AuthService): Authentication service.
         *
         * Returns:
         *     VerifyLoginResponse: Response containing access token and verification status.
         *
         * Raises:
         *     HTTPException: If verification code is invalid.
         */
        isMutating<TContext>(filters?: MutationFiltersByParameters<VerifyLoginApiV1AuthVerifyLoginPostBody, VerifyLoginApiV1AuthVerifyLoginPostData, VerifyLoginApiV1AuthVerifyLoginPostParameters, OperationError<VerifyLoginApiV1AuthVerifyLoginPostError>, TContext> | MutationFiltersByMutationKey<VerifyLoginApiV1AuthVerifyLoginPostSchema, VerifyLoginApiV1AuthVerifyLoginPostBody, VerifyLoginApiV1AuthVerifyLoginPostData, VerifyLoginApiV1AuthVerifyLoginPostParameters, OperationError<VerifyLoginApiV1AuthVerifyLoginPostError>, TContext>): number;
        /**
         * Returns a `MutationCache` object that provides access to mutation cache operations
         * for the specific endpoint.
         *
         * @summary Verify Login
         * @description Verify user's email using the login verification code.
         *
         * Args:
         *     payload (VerifyLoginRequest): JWT token containing the verification code.
         *     auth_service (AuthService): Authentication service.
         *
         * Returns:
         *     VerifyLoginResponse: Response containing access token and verification status.
         *
         * Raises:
         *     HTTPException: If verification code is invalid.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/query-client/getMutationCache|`getMutationCache(...)` documentation}
         *
         * @example Find a mutation with specific parameters
         * ```ts
         * const mutationCache = qraft.apiService.verifyLoginApiV1AuthVerifyLoginPost.getMutationCache();
         * const mutation = mutationCache.find({
         *     parameters: {}
         * });
         * ```
         *
         * @example Find all mutations for the endpoint
         * ```ts
         * const mutationCache = qraft.apiService.verifyLoginApiV1AuthVerifyLoginPost.getMutationCache();
         * const mutations = mutationCache.findAll();
         * ```
         */
        getMutationCache(): Omit<MutationCache, "find" | "findAll"> & {
            find<TContext = unknown>(filters: MutationFiltersByParameters<VerifyLoginApiV1AuthVerifyLoginPostBody, VerifyLoginApiV1AuthVerifyLoginPostData, VerifyLoginApiV1AuthVerifyLoginPostParameters, OperationError<VerifyLoginApiV1AuthVerifyLoginPostError>, TContext> | MutationFiltersByMutationKey<VerifyLoginApiV1AuthVerifyLoginPostSchema, VerifyLoginApiV1AuthVerifyLoginPostBody, VerifyLoginApiV1AuthVerifyLoginPostData, VerifyLoginApiV1AuthVerifyLoginPostParameters, OperationError<VerifyLoginApiV1AuthVerifyLoginPostError>, TContext>): Mutation<VerifyLoginApiV1AuthVerifyLoginPostData, VerifyLoginApiV1AuthVerifyLoginPostError, MutationVariables<VerifyLoginApiV1AuthVerifyLoginPostBody, VerifyLoginApiV1AuthVerifyLoginPostParameters>, TContext> | undefined;
            findAll<TContext = unknown>(filters?: MutationFiltersByParameters<VerifyLoginApiV1AuthVerifyLoginPostBody, VerifyLoginApiV1AuthVerifyLoginPostData, VerifyLoginApiV1AuthVerifyLoginPostParameters, OperationError<VerifyLoginApiV1AuthVerifyLoginPostError>, TContext> | MutationFiltersByMutationKey<VerifyLoginApiV1AuthVerifyLoginPostSchema, VerifyLoginApiV1AuthVerifyLoginPostBody, VerifyLoginApiV1AuthVerifyLoginPostData, VerifyLoginApiV1AuthVerifyLoginPostParameters, OperationError<VerifyLoginApiV1AuthVerifyLoginPostError>, TContext>): Array<Mutation<VerifyLoginApiV1AuthVerifyLoginPostData, VerifyLoginApiV1AuthVerifyLoginPostError, MutationVariables<VerifyLoginApiV1AuthVerifyLoginPostBody, VerifyLoginApiV1AuthVerifyLoginPostParameters>, TContext>>;
        };
        schema: VerifyLoginApiV1AuthVerifyLoginPostSchema;
        types: {
            parameters: VerifyLoginApiV1AuthVerifyLoginPostParameters;
            data: VerifyLoginApiV1AuthVerifyLoginPostData;
            error: VerifyLoginApiV1AuthVerifyLoginPostError;
            body: VerifyLoginApiV1AuthVerifyLoginPostBody;
        };
    };
    /**
     * @summary Logout
     * @description Logout user and clear cookies.
     *
     * Args:
     *     auth_service (AuthServiceDep): Authentication service.
     *
     * Returns:
     *     JSONResponse: JSON response with cookies cleared.
     */
    logoutApiV1AuthLogoutPost: {
        /**
         * @summary Logout
         * @description Logout user and clear cookies.
         *
         * Args:
         *     auth_service (AuthServiceDep): Authentication service.
         *
         * Returns:
         *     JSONResponse: JSON response with cookies cleared.
         */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: ServiceOperationMutationFnOptions<LogoutApiV1AuthLogoutPostBody, LogoutApiV1AuthLogoutPostParameters, TMeta, TSignal>, client?: (schema: LogoutApiV1AuthLogoutPostSchema, options: ServiceOperationMutationFnOptions<LogoutApiV1AuthLogoutPostBody, LogoutApiV1AuthLogoutPostParameters, TMeta, TSignal>) => Promise<RequestFnResponse<LogoutApiV1AuthLogoutPostData, LogoutApiV1AuthLogoutPostError>>): Promise<RequestFnResponse<LogoutApiV1AuthLogoutPostData, LogoutApiV1AuthLogoutPostError>>;
        /**
         * @summary Logout
         * @description Logout user and clear cookies.
         *
         * Args:
         *     auth_service (AuthServiceDep): Authentication service.
         *
         * Returns:
         *     JSONResponse: JSON response with cookies cleared.
         */
        getMutationKey(parameters: DeepReadonly<LogoutApiV1AuthLogoutPostParameters> | void): ServiceOperationMutationKey<LogoutApiV1AuthLogoutPostSchema, LogoutApiV1AuthLogoutPostParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Logout
         * @description Logout user and clear cookies.
         *
         * Args:
         *     auth_service (AuthServiceDep): Authentication service.
         *
         * Returns:
         *     JSONResponse: JSON response with cookies cleared.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.logoutApiV1AuthLogoutPost.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.logoutApiV1AuthLogoutPost.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends LogoutApiV1AuthLogoutPostBody, TContext = unknown>(parameters: DeepReadonly<LogoutApiV1AuthLogoutPostParameters>, options?: ServiceOperationUseMutationOptions<LogoutApiV1AuthLogoutPostSchema, LogoutApiV1AuthLogoutPostData, LogoutApiV1AuthLogoutPostParameters, TVariables, OperationError<LogoutApiV1AuthLogoutPostError>, TContext>): UseMutationResult<LogoutApiV1AuthLogoutPostData, OperationError<LogoutApiV1AuthLogoutPostError>, TVariables | void, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Logout
         * @description Logout user and clear cookies.
         *
         * Args:
         *     auth_service (AuthServiceDep): Authentication service.
         *
         * Returns:
         *     JSONResponse: JSON response with cookies cleared.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.logoutApiV1AuthLogoutPost.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.logoutApiV1AuthLogoutPost.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<LogoutApiV1AuthLogoutPostBody, LogoutApiV1AuthLogoutPostParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<LogoutApiV1AuthLogoutPostSchema, LogoutApiV1AuthLogoutPostData, LogoutApiV1AuthLogoutPostParameters, TVariables, OperationError<LogoutApiV1AuthLogoutPostError>, TContext>): UseMutationResult<LogoutApiV1AuthLogoutPostData, OperationError<LogoutApiV1AuthLogoutPostError>, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @summary Logout
         * @description Logout user and clear cookies.
         *
         * Args:
         *     auth_service (AuthServiceDep): Authentication service.
         *
         * Returns:
         *     JSONResponse: JSON response with cookies cleared.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const logoutApiV1AuthLogoutPostTotal = qraft.apiService.logoutApiV1AuthLogoutPost.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const logoutApiV1AuthLogoutPostTotal = qraft.apiService.logoutApiV1AuthLogoutPost.useIsMutating({
         *     parameters: {}
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<LogoutApiV1AuthLogoutPostBody, LogoutApiV1AuthLogoutPostData, LogoutApiV1AuthLogoutPostParameters, OperationError<LogoutApiV1AuthLogoutPostError>, TContext> | MutationFiltersByMutationKey<LogoutApiV1AuthLogoutPostSchema, LogoutApiV1AuthLogoutPostBody, LogoutApiV1AuthLogoutPostData, LogoutApiV1AuthLogoutPostParameters, OperationError<LogoutApiV1AuthLogoutPostError>, TContext>): number;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @summary Logout
         * @description Logout user and clear cookies.
         *
         * Args:
         *     auth_service (AuthServiceDep): Authentication service.
         *
         * Returns:
         *     JSONResponse: JSON response with cookies cleared.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const logoutApiV1AuthLogoutPostPendingMutationVariables = qraft.apiService.logoutApiV1AuthLogoutPost.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const logoutApiV1AuthLogoutPostMutationData = qraft.apiService.logoutApiV1AuthLogoutPost.useMutationState({
         *     filters: {
         *         parameters: {}
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<LogoutApiV1AuthLogoutPostData, OperationError<LogoutApiV1AuthLogoutPostError>, MutationVariables<LogoutApiV1AuthLogoutPostBody, LogoutApiV1AuthLogoutPostParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<LogoutApiV1AuthLogoutPostBody, LogoutApiV1AuthLogoutPostData, LogoutApiV1AuthLogoutPostParameters, OperationError<LogoutApiV1AuthLogoutPostError>, TContext> | MutationFiltersByMutationKey<LogoutApiV1AuthLogoutPostSchema, LogoutApiV1AuthLogoutPostBody, LogoutApiV1AuthLogoutPostData, LogoutApiV1AuthLogoutPostParameters, OperationError<LogoutApiV1AuthLogoutPostError>, TContext>;
            select?: (mutation: Mutation<LogoutApiV1AuthLogoutPostData, OperationError<LogoutApiV1AuthLogoutPostError>, MutationVariables<LogoutApiV1AuthLogoutPostBody, LogoutApiV1AuthLogoutPostParameters>, TContext>) => TResult;
        }): Array<TResult>;
        /**
         * @summary Logout
         * @description Logout user and clear cookies.
         *
         * Args:
         *     auth_service (AuthServiceDep): Authentication service.
         *
         * Returns:
         *     JSONResponse: JSON response with cookies cleared.
         */
        isMutating<TContext>(filters?: MutationFiltersByParameters<LogoutApiV1AuthLogoutPostBody, LogoutApiV1AuthLogoutPostData, LogoutApiV1AuthLogoutPostParameters, OperationError<LogoutApiV1AuthLogoutPostError>, TContext> | MutationFiltersByMutationKey<LogoutApiV1AuthLogoutPostSchema, LogoutApiV1AuthLogoutPostBody, LogoutApiV1AuthLogoutPostData, LogoutApiV1AuthLogoutPostParameters, OperationError<LogoutApiV1AuthLogoutPostError>, TContext>): number;
        /**
         * Returns a `MutationCache` object that provides access to mutation cache operations
         * for the specific endpoint.
         *
         * @summary Logout
         * @description Logout user and clear cookies.
         *
         * Args:
         *     auth_service (AuthServiceDep): Authentication service.
         *
         * Returns:
         *     JSONResponse: JSON response with cookies cleared.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/query-client/getMutationCache|`getMutationCache(...)` documentation}
         *
         * @example Find a mutation with specific parameters
         * ```ts
         * const mutationCache = qraft.apiService.logoutApiV1AuthLogoutPost.getMutationCache();
         * const mutation = mutationCache.find({
         *     parameters: {}
         * });
         * ```
         *
         * @example Find all mutations for the endpoint
         * ```ts
         * const mutationCache = qraft.apiService.logoutApiV1AuthLogoutPost.getMutationCache();
         * const mutations = mutationCache.findAll();
         * ```
         */
        getMutationCache(): Omit<MutationCache, "find" | "findAll"> & {
            find<TContext = unknown>(filters: MutationFiltersByParameters<LogoutApiV1AuthLogoutPostBody, LogoutApiV1AuthLogoutPostData, LogoutApiV1AuthLogoutPostParameters, OperationError<LogoutApiV1AuthLogoutPostError>, TContext> | MutationFiltersByMutationKey<LogoutApiV1AuthLogoutPostSchema, LogoutApiV1AuthLogoutPostBody, LogoutApiV1AuthLogoutPostData, LogoutApiV1AuthLogoutPostParameters, OperationError<LogoutApiV1AuthLogoutPostError>, TContext>): Mutation<LogoutApiV1AuthLogoutPostData, LogoutApiV1AuthLogoutPostError, MutationVariables<LogoutApiV1AuthLogoutPostBody, LogoutApiV1AuthLogoutPostParameters>, TContext> | undefined;
            findAll<TContext = unknown>(filters?: MutationFiltersByParameters<LogoutApiV1AuthLogoutPostBody, LogoutApiV1AuthLogoutPostData, LogoutApiV1AuthLogoutPostParameters, OperationError<LogoutApiV1AuthLogoutPostError>, TContext> | MutationFiltersByMutationKey<LogoutApiV1AuthLogoutPostSchema, LogoutApiV1AuthLogoutPostBody, LogoutApiV1AuthLogoutPostData, LogoutApiV1AuthLogoutPostParameters, OperationError<LogoutApiV1AuthLogoutPostError>, TContext>): Array<Mutation<LogoutApiV1AuthLogoutPostData, LogoutApiV1AuthLogoutPostError, MutationVariables<LogoutApiV1AuthLogoutPostBody, LogoutApiV1AuthLogoutPostParameters>, TContext>>;
        };
        schema: LogoutApiV1AuthLogoutPostSchema;
        types: {
            parameters: LogoutApiV1AuthLogoutPostParameters;
            data: LogoutApiV1AuthLogoutPostData;
            error: LogoutApiV1AuthLogoutPostError;
            body: LogoutApiV1AuthLogoutPostBody;
        };
    };
    /**
     * @summary Google Login
     * @description Initiate Google OAuth authentication flow.
     *
     * Args:
     *     request (Request): FastAPI request object.
     *
     * Returns:
     *     RedirectResponse: Redirect to Google OAuth consent screen.
     */
    googleLoginApiV1AuthGoogleGet: {
        /**
         * @summary Google Login
         * @description Initiate Google OAuth authentication flow.
         *
         * Args:
         *     request (Request): FastAPI request object.
         *
         * Returns:
         *     RedirectResponse: Redirect to Google OAuth consent screen.
         */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GoogleLoginApiV1AuthGoogleGetParameters, TMeta, TSignal> | void), client?: (schema: GoogleLoginApiV1AuthGoogleGetSchema, options: {
            parameters: GoogleLoginApiV1AuthGoogleGetParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GoogleLoginApiV1AuthGoogleGetData, GoogleLoginApiV1AuthGoogleGetError>>): Promise<RequestFnResponse<GoogleLoginApiV1AuthGoogleGetData, GoogleLoginApiV1AuthGoogleGetError>>;
        /**
         * @summary Google Login
         * @description Initiate Google OAuth authentication flow.
         *
         * Args:
         *     request (Request): FastAPI request object.
         *
         * Returns:
         *     RedirectResponse: Redirect to Google OAuth consent screen.
         */
        getQueryKey(parameters: DeepReadonly<GoogleLoginApiV1AuthGoogleGetParameters> | void): ServiceOperationQueryKey<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Google Login
         * @description Initiate Google OAuth authentication flow.
         *
         * Args:
         *     request (Request): FastAPI request object.
         *
         * Returns:
         *     RedirectResponse: Redirect to Google OAuth consent screen.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.apiService.googleLoginApiV1AuthGoogleGet.useQuery()
         * ```
         */
        useQuery<TData = GoogleLoginApiV1AuthGoogleGetData>(parameters: ServiceOperationQueryKey<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetParameters> | (DeepReadonly<GoogleLoginApiV1AuthGoogleGetParameters> | void), options?: Omit<UndefinedInitialDataOptions<GoogleLoginApiV1AuthGoogleGetData, GoogleLoginApiV1AuthGoogleGetError, TData, ServiceOperationQueryKey<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetParameters>>, "queryKey">): UseQueryResult<TData, OperationError<GoogleLoginApiV1AuthGoogleGetError>>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Google Login
         * @description Initiate Google OAuth authentication flow.
         *
         * Args:
         *     request (Request): FastAPI request object.
         *
         * Returns:
         *     RedirectResponse: Redirect to Google OAuth consent screen.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.apiService.googleLoginApiV1AuthGoogleGet.useQuery()
         * ```
         */
        useQuery<TData = GoogleLoginApiV1AuthGoogleGetData>(parameters: ServiceOperationQueryKey<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetParameters> | (DeepReadonly<GoogleLoginApiV1AuthGoogleGetParameters> | void), options: Omit<DefinedInitialDataOptions<GoogleLoginApiV1AuthGoogleGetData, GoogleLoginApiV1AuthGoogleGetError, TData, ServiceOperationQueryKey<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetParameters>>, "queryKey">): DefinedUseQueryResult<TData, OperationError<GoogleLoginApiV1AuthGoogleGetError>>;
        /**
         * @summary Google Login
         * @description Initiate Google OAuth authentication flow.
         *
         * Args:
         *     request (Request): FastAPI request object.
         *
         * Returns:
         *     RedirectResponse: Redirect to Google OAuth consent screen.
         */
        getInfiniteQueryKey(parameters: DeepReadonly<GoogleLoginApiV1AuthGoogleGetParameters> | void): ServiceOperationInfiniteQueryKey<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @summary Google Login
         * @description Initiate Google OAuth authentication flow.
         *
         * Args:
         *     request (Request): FastAPI request object.
         *
         * Returns:
         *     RedirectResponse: Redirect to Google OAuth consent screen.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.googleLoginApiV1AuthGoogleGet.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GoogleLoginApiV1AuthGoogleGetParameters, TQueryFnData = GoogleLoginApiV1AuthGoogleGetData, TData = OperationInfiniteData<TQueryFnData, GoogleLoginApiV1AuthGoogleGetParameters>>(parameters: ServiceOperationInfiniteQueryKey<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetParameters> | (DeepReadonly<GoogleLoginApiV1AuthGoogleGetParameters> | void), options: Omit<UndefinedInitialDataInfiniteOptions<TQueryFnData, GoogleLoginApiV1AuthGoogleGetError, TData, ServiceOperationInfiniteQueryKey<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>): UseInfiniteQueryResult<TData, OperationError<GoogleLoginApiV1AuthGoogleGetError>>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @summary Google Login
         * @description Initiate Google OAuth authentication flow.
         *
         * Args:
         *     request (Request): FastAPI request object.
         *
         * Returns:
         *     RedirectResponse: Redirect to Google OAuth consent screen.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.googleLoginApiV1AuthGoogleGet.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GoogleLoginApiV1AuthGoogleGetParameters, TQueryFnData = GoogleLoginApiV1AuthGoogleGetData, TData = OperationInfiniteData<TQueryFnData, GoogleLoginApiV1AuthGoogleGetParameters>>(parameters: ServiceOperationInfiniteQueryKey<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetParameters> | (DeepReadonly<GoogleLoginApiV1AuthGoogleGetParameters> | void), options: Omit<DefinedInitialDataInfiniteOptions<TQueryFnData, GoogleLoginApiV1AuthGoogleGetError, TData, ServiceOperationInfiniteQueryKey<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GoogleLoginApiV1AuthGoogleGetData, PartialParameters<DeepReadonly<TPageParam>>>): DefinedUseInfiniteQueryResult<TData, OperationError<GoogleLoginApiV1AuthGoogleGetError>>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @summary Google Login
         * @description Initiate Google OAuth authentication flow.
         *
         * Args:
         *     request (Request): FastAPI request object.
         *
         * Returns:
         *     RedirectResponse: Redirect to Google OAuth consent screen.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const googleLoginApiV1AuthGoogleGetTotal = qraft.apiService.googleLoginApiV1AuthGoogleGet.useIsFetching()
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetData, TInfinite, GoogleLoginApiV1AuthGoogleGetParameters, GoogleLoginApiV1AuthGoogleGetError> | QueryFiltersByQueryKey<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetData, TInfinite, GoogleLoginApiV1AuthGoogleGetParameters, GoogleLoginApiV1AuthGoogleGetError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @summary Google Login
         * @description Initiate Google OAuth authentication flow.
         *
         * Args:
         *     request (Request): FastAPI request object.
         *
         * Returns:
         *     RedirectResponse: Redirect to Google OAuth consent screen.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const googleLoginApiV1AuthGoogleGetResults = qraft.apiService.googleLoginApiV1AuthGoogleGet.useQueries({
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * googleLoginApiV1AuthGoogleGetResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const googleLoginApiV1AuthGoogleGetCombinedResults = qraft.apiService.googleLoginApiV1AuthGoogleGet.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * googleLoginApiV1AuthGoogleGetCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetParameters, GoogleLoginApiV1AuthGoogleGetData, GoogleLoginApiV1AuthGoogleGetError>>, TCombinedResult = Array<UseQueryResult<GoogleLoginApiV1AuthGoogleGetData, GoogleLoginApiV1AuthGoogleGetError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GoogleLoginApiV1AuthGoogleGetData, GoogleLoginApiV1AuthGoogleGetError>>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * Performs asynchronous data fetching with Suspense support.
         * Similar to useQuery but integrates with React Suspense for loading states.
         *
         * @summary Google Login
         * @description Initiate Google OAuth authentication flow.
         *
         * Args:
         *     request (Request): FastAPI request object.
         *
         * Returns:
         *     RedirectResponse: Redirect to Google OAuth consent screen.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
         * @example Suspense Query without parameters
         * ```ts
         * const data = qraft.apiService.googleLoginApiV1AuthGoogleGet.useSuspenseQuery()
         * ```
         */
        useSuspenseQuery<TData = GoogleLoginApiV1AuthGoogleGetData>(parameters: ServiceOperationQueryKey<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetParameters> | (DeepReadonly<GoogleLoginApiV1AuthGoogleGetParameters> | void), options?: Omit<UseSuspenseQueryOptions<GoogleLoginApiV1AuthGoogleGetData, GoogleLoginApiV1AuthGoogleGetError, TData, ServiceOperationQueryKey<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetParameters>>, "queryKey">): UseSuspenseQueryResult<TData, OperationError<GoogleLoginApiV1AuthGoogleGetError>>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @summary Google Login
         * @description Initiate Google OAuth authentication flow.
         *
         * Args:
         *     request (Request): FastAPI request object.
         *
         * Returns:
         *     RedirectResponse: Redirect to Google OAuth consent screen.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.googleLoginApiV1AuthGoogleGet.useSuspenseInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GoogleLoginApiV1AuthGoogleGetParameters, TData = GoogleLoginApiV1AuthGoogleGetData>(parameters: ServiceOperationInfiniteQueryKey<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetParameters> | (DeepReadonly<GoogleLoginApiV1AuthGoogleGetParameters> | void), options: Omit<UseSuspenseInfiniteQueryOptions<GoogleLoginApiV1AuthGoogleGetData, GoogleLoginApiV1AuthGoogleGetError, OperationInfiniteData<TData, GoogleLoginApiV1AuthGoogleGetParameters>, ServiceOperationInfiniteQueryKey<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GoogleLoginApiV1AuthGoogleGetData, PartialParameters<DeepReadonly<TPageParam>>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GoogleLoginApiV1AuthGoogleGetParameters>, OperationError<GoogleLoginApiV1AuthGoogleGetError>>;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
         * Similar to useQueries but integrates with React Suspense for loading states.
         *
         * @summary Google Login
         * @description Initiate Google OAuth authentication flow.
         *
         * Args:
         *     request (Request): FastAPI request object.
         *
         * Returns:
         *     RedirectResponse: Redirect to Google OAuth consent screen.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
         * @example Basic usage with Suspense
         * ```ts
         * const googleLoginApiV1AuthGoogleGetData = qraft.apiService.googleLoginApiV1AuthGoogleGet.useSuspenseQueries({
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * googleLoginApiV1AuthGoogleGetResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example With data transformation using combine
         * ```ts
         * const googleLoginApiV1AuthGoogleGetCombinedData = qraft.apiService.googleLoginApiV1AuthGoogleGet.useSuspenseQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * googleLoginApiV1AuthGoogleGetCombinedData.forEach(data => console.log({ data }));
         * ```
         */
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetParameters, GoogleLoginApiV1AuthGoogleGetData, GoogleLoginApiV1AuthGoogleGetError>>, TCombinedResult = Array<UseSuspenseQueryResult<GoogleLoginApiV1AuthGoogleGetData, GoogleLoginApiV1AuthGoogleGetError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GoogleLoginApiV1AuthGoogleGetData, GoogleLoginApiV1AuthGoogleGetError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * @summary Google Login
         * @description Initiate Google OAuth authentication flow.
         *
         * Args:
         *     request (Request): FastAPI request object.
         *
         * Returns:
         *     RedirectResponse: Redirect to Google OAuth consent screen.
         */
        fetchQuery(options: ServiceOperationFetchQueryOptions<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetData, GoogleLoginApiV1AuthGoogleGetParameters, GoogleLoginApiV1AuthGoogleGetError> | void): Promise<GoogleLoginApiV1AuthGoogleGetData>;
        /**
         * @summary Google Login
         * @description Initiate Google OAuth authentication flow.
         *
         * Args:
         *     request (Request): FastAPI request object.
         *
         * Returns:
         *     RedirectResponse: Redirect to Google OAuth consent screen.
         */
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetData, GoogleLoginApiV1AuthGoogleGetParameters, GoogleLoginApiV1AuthGoogleGetError> | void): Promise<void>;
        /**
         * @summary Google Login
         * @description Initiate Google OAuth authentication flow.
         *
         * Args:
         *     request (Request): FastAPI request object.
         *
         * Returns:
         *     RedirectResponse: Redirect to Google OAuth consent screen.
         */
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetData, GoogleLoginApiV1AuthGoogleGetParameters, GoogleLoginApiV1AuthGoogleGetError> | void): Promise<GoogleLoginApiV1AuthGoogleGetData>;
        /**
         * @summary Google Login
         * @description Initiate Google OAuth authentication flow.
         *
         * Args:
         *     request (Request): FastAPI request object.
         *
         * Returns:
         *     RedirectResponse: Redirect to Google OAuth consent screen.
         */
        fetchInfiniteQuery<TPageParam extends GoogleLoginApiV1AuthGoogleGetParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetData, GoogleLoginApiV1AuthGoogleGetParameters, DeepReadonly<TPageParam>, GoogleLoginApiV1AuthGoogleGetError> | void): Promise<OperationInfiniteData<GoogleLoginApiV1AuthGoogleGetData, GoogleLoginApiV1AuthGoogleGetParameters>>;
        /**
         * @summary Google Login
         * @description Initiate Google OAuth authentication flow.
         *
         * Args:
         *     request (Request): FastAPI request object.
         *
         * Returns:
         *     RedirectResponse: Redirect to Google OAuth consent screen.
         */
        prefetchInfiniteQuery<TPageParam extends GoogleLoginApiV1AuthGoogleGetParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetData, GoogleLoginApiV1AuthGoogleGetParameters, DeepReadonly<TPageParam>, GoogleLoginApiV1AuthGoogleGetError> | void): Promise<void>;
        /**
         * @summary Google Login
         * @description Initiate Google OAuth authentication flow.
         *
         * Args:
         *     request (Request): FastAPI request object.
         *
         * Returns:
         *     RedirectResponse: Redirect to Google OAuth consent screen.
         */
        ensureInfiniteQueryData<TPageParam extends GoogleLoginApiV1AuthGoogleGetParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetData, GoogleLoginApiV1AuthGoogleGetParameters, DeepReadonly<TPageParam>, GoogleLoginApiV1AuthGoogleGetError> | void): Promise<OperationInfiniteData<GoogleLoginApiV1AuthGoogleGetData, GoogleLoginApiV1AuthGoogleGetParameters>>;
        /**
         * @summary Google Login
         * @description Initiate Google OAuth authentication flow.
         *
         * Args:
         *     request (Request): FastAPI request object.
         *
         * Returns:
         *     RedirectResponse: Redirect to Google OAuth consent screen.
         */
        getQueryData(parameters: ServiceOperationQueryKey<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetParameters> | (DeepReadonly<GoogleLoginApiV1AuthGoogleGetParameters> | void)): GoogleLoginApiV1AuthGoogleGetData | undefined;
        /**
         * @summary Google Login
         * @description Initiate Google OAuth authentication flow.
         *
         * Args:
         *     request (Request): FastAPI request object.
         *
         * Returns:
         *     RedirectResponse: Redirect to Google OAuth consent screen.
         */
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetParameters> | (DeepReadonly<GoogleLoginApiV1AuthGoogleGetParameters> | void)): OperationInfiniteData<GoogleLoginApiV1AuthGoogleGetData, GoogleLoginApiV1AuthGoogleGetParameters> | undefined;
        /**
         * @summary Google Login
         * @description Initiate Google OAuth authentication flow.
         *
         * Args:
         *     request (Request): FastAPI request object.
         *
         * Returns:
         *     RedirectResponse: Redirect to Google OAuth consent screen.
         */
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetData, TInfinite, GoogleLoginApiV1AuthGoogleGetParameters, GoogleLoginApiV1AuthGoogleGetError> | QueryFiltersByQueryKey<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetData, TInfinite, GoogleLoginApiV1AuthGoogleGetParameters, GoogleLoginApiV1AuthGoogleGetError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetParameters>,
            data: NoInfer<OperationInfiniteData<GoogleLoginApiV1AuthGoogleGetData, GoogleLoginApiV1AuthGoogleGetParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetParameters>,
            data: GoogleLoginApiV1AuthGoogleGetData | undefined
        ]>;
        /**
         * @summary Google Login
         * @description Initiate Google OAuth authentication flow.
         *
         * Args:
         *     request (Request): FastAPI request object.
         *
         * Returns:
         *     RedirectResponse: Redirect to Google OAuth consent screen.
         */
        getQueryState(parameters: ServiceOperationQueryKey<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetParameters> | (DeepReadonly<GoogleLoginApiV1AuthGoogleGetParameters> | void)): QueryState<GoogleLoginApiV1AuthGoogleGetData, GoogleLoginApiV1AuthGoogleGetError> | undefined;
        /**
         * @summary Google Login
         * @description Initiate Google OAuth authentication flow.
         *
         * Args:
         *     request (Request): FastAPI request object.
         *
         * Returns:
         *     RedirectResponse: Redirect to Google OAuth consent screen.
         */
        getInfiniteQueryState(parameters: DeepReadonly<GoogleLoginApiV1AuthGoogleGetParameters> | ServiceOperationInfiniteQueryKey<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetParameters> | void): QueryState<OperationInfiniteData<GoogleLoginApiV1AuthGoogleGetData, GoogleLoginApiV1AuthGoogleGetParameters>, GoogleLoginApiV1AuthGoogleGetError> | undefined;
        /**
         * @summary Google Login
         * @description Initiate Google OAuth authentication flow.
         *
         * Args:
         *     request (Request): FastAPI request object.
         *
         * Returns:
         *     RedirectResponse: Redirect to Google OAuth consent screen.
         */
        setQueryData(parameters: (DeepReadonly<GoogleLoginApiV1AuthGoogleGetParameters> | undefined) | ServiceOperationQueryKey<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetParameters>, updater: Updater<NoInfer<GoogleLoginApiV1AuthGoogleGetData> | undefined, NoInfer<DeepReadonly<GoogleLoginApiV1AuthGoogleGetData>> | undefined>, options?: SetDataOptions): GoogleLoginApiV1AuthGoogleGetData | undefined;
        /**
         * @summary Google Login
         * @description Initiate Google OAuth authentication flow.
         *
         * Args:
         *     request (Request): FastAPI request object.
         *
         * Returns:
         *     RedirectResponse: Redirect to Google OAuth consent screen.
         */
        setInfiniteQueryData(parameters: (DeepReadonly<GoogleLoginApiV1AuthGoogleGetParameters> | undefined) | ServiceOperationInfiniteQueryKey<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetParameters>, updater: Updater<NoInfer<OperationInfiniteData<GoogleLoginApiV1AuthGoogleGetData, GoogleLoginApiV1AuthGoogleGetParameters>> | undefined, NoInfer<DeepReadonly<OperationInfiniteData<GoogleLoginApiV1AuthGoogleGetData, GoogleLoginApiV1AuthGoogleGetParameters>>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GoogleLoginApiV1AuthGoogleGetData, GoogleLoginApiV1AuthGoogleGetParameters> | undefined;
        /**
         * @summary Google Login
         * @description Initiate Google OAuth authentication flow.
         *
         * Args:
         *     request (Request): FastAPI request object.
         *
         * Returns:
         *     RedirectResponse: Redirect to Google OAuth consent screen.
         */
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetData, TInfinite, GoogleLoginApiV1AuthGoogleGetParameters, GoogleLoginApiV1AuthGoogleGetError> | QueryFiltersByQueryKey<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetData, TInfinite, GoogleLoginApiV1AuthGoogleGetParameters, GoogleLoginApiV1AuthGoogleGetError>, updater: Updater<NoInfer<GoogleLoginApiV1AuthGoogleGetData> | undefined, NoInfer<GoogleLoginApiV1AuthGoogleGetData> | undefined>, options?: SetDataOptions): Array<GoogleLoginApiV1AuthGoogleGetData | undefined>;
        /**
         * @summary Google Login
         * @description Initiate Google OAuth authentication flow.
         *
         * Args:
         *     request (Request): FastAPI request object.
         *
         * Returns:
         *     RedirectResponse: Redirect to Google OAuth consent screen.
         */
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetData, TInfinite, GoogleLoginApiV1AuthGoogleGetParameters, GoogleLoginApiV1AuthGoogleGetError>, options?: InvalidateOptions): Promise<void>;
        /**
         * @summary Google Login
         * @description Initiate Google OAuth authentication flow.
         *
         * Args:
         *     request (Request): FastAPI request object.
         *
         * Returns:
         *     RedirectResponse: Redirect to Google OAuth consent screen.
         */
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetData, TInfinite, GoogleLoginApiV1AuthGoogleGetParameters, GoogleLoginApiV1AuthGoogleGetError> | QueryFiltersByQueryKey<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetData, TInfinite, GoogleLoginApiV1AuthGoogleGetParameters, GoogleLoginApiV1AuthGoogleGetError>, options?: RefetchOptions): Promise<void>;
        /**
         * @summary Google Login
         * @description Initiate Google OAuth authentication flow.
         *
         * Args:
         *     request (Request): FastAPI request object.
         *
         * Returns:
         *     RedirectResponse: Redirect to Google OAuth consent screen.
         */
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetData, TInfinite, GoogleLoginApiV1AuthGoogleGetParameters, GoogleLoginApiV1AuthGoogleGetError> | QueryFiltersByQueryKey<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetData, TInfinite, GoogleLoginApiV1AuthGoogleGetParameters, GoogleLoginApiV1AuthGoogleGetError>, options?: CancelOptions): Promise<void>;
        /**
         * @summary Google Login
         * @description Initiate Google OAuth authentication flow.
         *
         * Args:
         *     request (Request): FastAPI request object.
         *
         * Returns:
         *     RedirectResponse: Redirect to Google OAuth consent screen.
         */
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetData, TInfinite, GoogleLoginApiV1AuthGoogleGetParameters, GoogleLoginApiV1AuthGoogleGetError> | QueryFiltersByQueryKey<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetData, TInfinite, GoogleLoginApiV1AuthGoogleGetParameters, GoogleLoginApiV1AuthGoogleGetError>): void;
        /**
         * @summary Google Login
         * @description Initiate Google OAuth authentication flow.
         *
         * Args:
         *     request (Request): FastAPI request object.
         *
         * Returns:
         *     RedirectResponse: Redirect to Google OAuth consent screen.
         */
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetData, TInfinite, GoogleLoginApiV1AuthGoogleGetParameters, GoogleLoginApiV1AuthGoogleGetError> | QueryFiltersByQueryKey<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetData, TInfinite, GoogleLoginApiV1AuthGoogleGetParameters, GoogleLoginApiV1AuthGoogleGetError>, options?: ResetOptions): Promise<void>;
        /**
         * @summary Google Login
         * @description Initiate Google OAuth authentication flow.
         *
         * Args:
         *     request (Request): FastAPI request object.
         *
         * Returns:
         *     RedirectResponse: Redirect to Google OAuth consent screen.
         */
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetData, TInfinite, GoogleLoginApiV1AuthGoogleGetParameters, GoogleLoginApiV1AuthGoogleGetError> | QueryFiltersByQueryKey<GoogleLoginApiV1AuthGoogleGetSchema, GoogleLoginApiV1AuthGoogleGetData, TInfinite, GoogleLoginApiV1AuthGoogleGetParameters, GoogleLoginApiV1AuthGoogleGetError>): number;
        schema: GoogleLoginApiV1AuthGoogleGetSchema;
        types: {
            parameters: GoogleLoginApiV1AuthGoogleGetParameters;
            data: GoogleLoginApiV1AuthGoogleGetData;
            error: GoogleLoginApiV1AuthGoogleGetError;
        };
    };
    /**
     * @summary Google Auth
     * @description Handle Google OAuth callback and create user session.
     *
     * Args:
     *     request (Request): FastAPI request object containing OAuth callback data.
     *     db (Session): Database session.
     *
     * Returns:
     *     RedirectResponse: Redirect to frontend with access token.
     *
     * Raises:
     *     HTTPException: If Google authentication fails.
     */
    googleAuthApiV1AuthGoogleCallbackGet: {
        /**
         * @summary Google Auth
         * @description Handle Google OAuth callback and create user session.
         *
         * Args:
         *     request (Request): FastAPI request object containing OAuth callback data.
         *     db (Session): Database session.
         *
         * Returns:
         *     RedirectResponse: Redirect to frontend with access token.
         *
         * Raises:
         *     HTTPException: If Google authentication fails.
         */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GoogleAuthApiV1AuthGoogleCallbackGetParameters, TMeta, TSignal> | void), client?: (schema: GoogleAuthApiV1AuthGoogleCallbackGetSchema, options: {
            parameters: GoogleAuthApiV1AuthGoogleCallbackGetParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GoogleAuthApiV1AuthGoogleCallbackGetData, GoogleAuthApiV1AuthGoogleCallbackGetError>>): Promise<RequestFnResponse<GoogleAuthApiV1AuthGoogleCallbackGetData, GoogleAuthApiV1AuthGoogleCallbackGetError>>;
        /**
         * @summary Google Auth
         * @description Handle Google OAuth callback and create user session.
         *
         * Args:
         *     request (Request): FastAPI request object containing OAuth callback data.
         *     db (Session): Database session.
         *
         * Returns:
         *     RedirectResponse: Redirect to frontend with access token.
         *
         * Raises:
         *     HTTPException: If Google authentication fails.
         */
        getQueryKey(parameters: DeepReadonly<GoogleAuthApiV1AuthGoogleCallbackGetParameters> | void): ServiceOperationQueryKey<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Google Auth
         * @description Handle Google OAuth callback and create user session.
         *
         * Args:
         *     request (Request): FastAPI request object containing OAuth callback data.
         *     db (Session): Database session.
         *
         * Returns:
         *     RedirectResponse: Redirect to frontend with access token.
         *
         * Raises:
         *     HTTPException: If Google authentication fails.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.apiService.googleAuthApiV1AuthGoogleCallbackGet.useQuery()
         * ```
         */
        useQuery<TData = GoogleAuthApiV1AuthGoogleCallbackGetData>(parameters: ServiceOperationQueryKey<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetParameters> | (DeepReadonly<GoogleAuthApiV1AuthGoogleCallbackGetParameters> | void), options?: Omit<UndefinedInitialDataOptions<GoogleAuthApiV1AuthGoogleCallbackGetData, GoogleAuthApiV1AuthGoogleCallbackGetError, TData, ServiceOperationQueryKey<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetParameters>>, "queryKey">): UseQueryResult<TData, OperationError<GoogleAuthApiV1AuthGoogleCallbackGetError>>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Google Auth
         * @description Handle Google OAuth callback and create user session.
         *
         * Args:
         *     request (Request): FastAPI request object containing OAuth callback data.
         *     db (Session): Database session.
         *
         * Returns:
         *     RedirectResponse: Redirect to frontend with access token.
         *
         * Raises:
         *     HTTPException: If Google authentication fails.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.apiService.googleAuthApiV1AuthGoogleCallbackGet.useQuery()
         * ```
         */
        useQuery<TData = GoogleAuthApiV1AuthGoogleCallbackGetData>(parameters: ServiceOperationQueryKey<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetParameters> | (DeepReadonly<GoogleAuthApiV1AuthGoogleCallbackGetParameters> | void), options: Omit<DefinedInitialDataOptions<GoogleAuthApiV1AuthGoogleCallbackGetData, GoogleAuthApiV1AuthGoogleCallbackGetError, TData, ServiceOperationQueryKey<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetParameters>>, "queryKey">): DefinedUseQueryResult<TData, OperationError<GoogleAuthApiV1AuthGoogleCallbackGetError>>;
        /**
         * @summary Google Auth
         * @description Handle Google OAuth callback and create user session.
         *
         * Args:
         *     request (Request): FastAPI request object containing OAuth callback data.
         *     db (Session): Database session.
         *
         * Returns:
         *     RedirectResponse: Redirect to frontend with access token.
         *
         * Raises:
         *     HTTPException: If Google authentication fails.
         */
        getInfiniteQueryKey(parameters: DeepReadonly<GoogleAuthApiV1AuthGoogleCallbackGetParameters> | void): ServiceOperationInfiniteQueryKey<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @summary Google Auth
         * @description Handle Google OAuth callback and create user session.
         *
         * Args:
         *     request (Request): FastAPI request object containing OAuth callback data.
         *     db (Session): Database session.
         *
         * Returns:
         *     RedirectResponse: Redirect to frontend with access token.
         *
         * Raises:
         *     HTTPException: If Google authentication fails.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.googleAuthApiV1AuthGoogleCallbackGet.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GoogleAuthApiV1AuthGoogleCallbackGetParameters, TQueryFnData = GoogleAuthApiV1AuthGoogleCallbackGetData, TData = OperationInfiniteData<TQueryFnData, GoogleAuthApiV1AuthGoogleCallbackGetParameters>>(parameters: ServiceOperationInfiniteQueryKey<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetParameters> | (DeepReadonly<GoogleAuthApiV1AuthGoogleCallbackGetParameters> | void), options: Omit<UndefinedInitialDataInfiniteOptions<TQueryFnData, GoogleAuthApiV1AuthGoogleCallbackGetError, TData, ServiceOperationInfiniteQueryKey<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>): UseInfiniteQueryResult<TData, OperationError<GoogleAuthApiV1AuthGoogleCallbackGetError>>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @summary Google Auth
         * @description Handle Google OAuth callback and create user session.
         *
         * Args:
         *     request (Request): FastAPI request object containing OAuth callback data.
         *     db (Session): Database session.
         *
         * Returns:
         *     RedirectResponse: Redirect to frontend with access token.
         *
         * Raises:
         *     HTTPException: If Google authentication fails.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.googleAuthApiV1AuthGoogleCallbackGet.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GoogleAuthApiV1AuthGoogleCallbackGetParameters, TQueryFnData = GoogleAuthApiV1AuthGoogleCallbackGetData, TData = OperationInfiniteData<TQueryFnData, GoogleAuthApiV1AuthGoogleCallbackGetParameters>>(parameters: ServiceOperationInfiniteQueryKey<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetParameters> | (DeepReadonly<GoogleAuthApiV1AuthGoogleCallbackGetParameters> | void), options: Omit<DefinedInitialDataInfiniteOptions<TQueryFnData, GoogleAuthApiV1AuthGoogleCallbackGetError, TData, ServiceOperationInfiniteQueryKey<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GoogleAuthApiV1AuthGoogleCallbackGetData, PartialParameters<DeepReadonly<TPageParam>>>): DefinedUseInfiniteQueryResult<TData, OperationError<GoogleAuthApiV1AuthGoogleCallbackGetError>>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @summary Google Auth
         * @description Handle Google OAuth callback and create user session.
         *
         * Args:
         *     request (Request): FastAPI request object containing OAuth callback data.
         *     db (Session): Database session.
         *
         * Returns:
         *     RedirectResponse: Redirect to frontend with access token.
         *
         * Raises:
         *     HTTPException: If Google authentication fails.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const googleAuthApiV1AuthGoogleCallbackGetTotal = qraft.apiService.googleAuthApiV1AuthGoogleCallbackGet.useIsFetching()
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetData, TInfinite, GoogleAuthApiV1AuthGoogleCallbackGetParameters, GoogleAuthApiV1AuthGoogleCallbackGetError> | QueryFiltersByQueryKey<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetData, TInfinite, GoogleAuthApiV1AuthGoogleCallbackGetParameters, GoogleAuthApiV1AuthGoogleCallbackGetError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @summary Google Auth
         * @description Handle Google OAuth callback and create user session.
         *
         * Args:
         *     request (Request): FastAPI request object containing OAuth callback data.
         *     db (Session): Database session.
         *
         * Returns:
         *     RedirectResponse: Redirect to frontend with access token.
         *
         * Raises:
         *     HTTPException: If Google authentication fails.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const googleAuthApiV1AuthGoogleCallbackGetResults = qraft.apiService.googleAuthApiV1AuthGoogleCallbackGet.useQueries({
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * googleAuthApiV1AuthGoogleCallbackGetResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const googleAuthApiV1AuthGoogleCallbackGetCombinedResults = qraft.apiService.googleAuthApiV1AuthGoogleCallbackGet.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * googleAuthApiV1AuthGoogleCallbackGetCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetParameters, GoogleAuthApiV1AuthGoogleCallbackGetData, GoogleAuthApiV1AuthGoogleCallbackGetError>>, TCombinedResult = Array<UseQueryResult<GoogleAuthApiV1AuthGoogleCallbackGetData, GoogleAuthApiV1AuthGoogleCallbackGetError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GoogleAuthApiV1AuthGoogleCallbackGetData, GoogleAuthApiV1AuthGoogleCallbackGetError>>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * Performs asynchronous data fetching with Suspense support.
         * Similar to useQuery but integrates with React Suspense for loading states.
         *
         * @summary Google Auth
         * @description Handle Google OAuth callback and create user session.
         *
         * Args:
         *     request (Request): FastAPI request object containing OAuth callback data.
         *     db (Session): Database session.
         *
         * Returns:
         *     RedirectResponse: Redirect to frontend with access token.
         *
         * Raises:
         *     HTTPException: If Google authentication fails.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
         * @example Suspense Query without parameters
         * ```ts
         * const data = qraft.apiService.googleAuthApiV1AuthGoogleCallbackGet.useSuspenseQuery()
         * ```
         */
        useSuspenseQuery<TData = GoogleAuthApiV1AuthGoogleCallbackGetData>(parameters: ServiceOperationQueryKey<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetParameters> | (DeepReadonly<GoogleAuthApiV1AuthGoogleCallbackGetParameters> | void), options?: Omit<UseSuspenseQueryOptions<GoogleAuthApiV1AuthGoogleCallbackGetData, GoogleAuthApiV1AuthGoogleCallbackGetError, TData, ServiceOperationQueryKey<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetParameters>>, "queryKey">): UseSuspenseQueryResult<TData, OperationError<GoogleAuthApiV1AuthGoogleCallbackGetError>>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @summary Google Auth
         * @description Handle Google OAuth callback and create user session.
         *
         * Args:
         *     request (Request): FastAPI request object containing OAuth callback data.
         *     db (Session): Database session.
         *
         * Returns:
         *     RedirectResponse: Redirect to frontend with access token.
         *
         * Raises:
         *     HTTPException: If Google authentication fails.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.googleAuthApiV1AuthGoogleCallbackGet.useSuspenseInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GoogleAuthApiV1AuthGoogleCallbackGetParameters, TData = GoogleAuthApiV1AuthGoogleCallbackGetData>(parameters: ServiceOperationInfiniteQueryKey<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetParameters> | (DeepReadonly<GoogleAuthApiV1AuthGoogleCallbackGetParameters> | void), options: Omit<UseSuspenseInfiniteQueryOptions<GoogleAuthApiV1AuthGoogleCallbackGetData, GoogleAuthApiV1AuthGoogleCallbackGetError, OperationInfiniteData<TData, GoogleAuthApiV1AuthGoogleCallbackGetParameters>, ServiceOperationInfiniteQueryKey<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GoogleAuthApiV1AuthGoogleCallbackGetData, PartialParameters<DeepReadonly<TPageParam>>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GoogleAuthApiV1AuthGoogleCallbackGetParameters>, OperationError<GoogleAuthApiV1AuthGoogleCallbackGetError>>;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
         * Similar to useQueries but integrates with React Suspense for loading states.
         *
         * @summary Google Auth
         * @description Handle Google OAuth callback and create user session.
         *
         * Args:
         *     request (Request): FastAPI request object containing OAuth callback data.
         *     db (Session): Database session.
         *
         * Returns:
         *     RedirectResponse: Redirect to frontend with access token.
         *
         * Raises:
         *     HTTPException: If Google authentication fails.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
         * @example Basic usage with Suspense
         * ```ts
         * const googleAuthApiV1AuthGoogleCallbackGetData = qraft.apiService.googleAuthApiV1AuthGoogleCallbackGet.useSuspenseQueries({
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * googleAuthApiV1AuthGoogleCallbackGetResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example With data transformation using combine
         * ```ts
         * const googleAuthApiV1AuthGoogleCallbackGetCombinedData = qraft.apiService.googleAuthApiV1AuthGoogleCallbackGet.useSuspenseQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * googleAuthApiV1AuthGoogleCallbackGetCombinedData.forEach(data => console.log({ data }));
         * ```
         */
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetParameters, GoogleAuthApiV1AuthGoogleCallbackGetData, GoogleAuthApiV1AuthGoogleCallbackGetError>>, TCombinedResult = Array<UseSuspenseQueryResult<GoogleAuthApiV1AuthGoogleCallbackGetData, GoogleAuthApiV1AuthGoogleCallbackGetError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GoogleAuthApiV1AuthGoogleCallbackGetData, GoogleAuthApiV1AuthGoogleCallbackGetError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * @summary Google Auth
         * @description Handle Google OAuth callback and create user session.
         *
         * Args:
         *     request (Request): FastAPI request object containing OAuth callback data.
         *     db (Session): Database session.
         *
         * Returns:
         *     RedirectResponse: Redirect to frontend with access token.
         *
         * Raises:
         *     HTTPException: If Google authentication fails.
         */
        fetchQuery(options: ServiceOperationFetchQueryOptions<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetData, GoogleAuthApiV1AuthGoogleCallbackGetParameters, GoogleAuthApiV1AuthGoogleCallbackGetError> | void): Promise<GoogleAuthApiV1AuthGoogleCallbackGetData>;
        /**
         * @summary Google Auth
         * @description Handle Google OAuth callback and create user session.
         *
         * Args:
         *     request (Request): FastAPI request object containing OAuth callback data.
         *     db (Session): Database session.
         *
         * Returns:
         *     RedirectResponse: Redirect to frontend with access token.
         *
         * Raises:
         *     HTTPException: If Google authentication fails.
         */
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetData, GoogleAuthApiV1AuthGoogleCallbackGetParameters, GoogleAuthApiV1AuthGoogleCallbackGetError> | void): Promise<void>;
        /**
         * @summary Google Auth
         * @description Handle Google OAuth callback and create user session.
         *
         * Args:
         *     request (Request): FastAPI request object containing OAuth callback data.
         *     db (Session): Database session.
         *
         * Returns:
         *     RedirectResponse: Redirect to frontend with access token.
         *
         * Raises:
         *     HTTPException: If Google authentication fails.
         */
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetData, GoogleAuthApiV1AuthGoogleCallbackGetParameters, GoogleAuthApiV1AuthGoogleCallbackGetError> | void): Promise<GoogleAuthApiV1AuthGoogleCallbackGetData>;
        /**
         * @summary Google Auth
         * @description Handle Google OAuth callback and create user session.
         *
         * Args:
         *     request (Request): FastAPI request object containing OAuth callback data.
         *     db (Session): Database session.
         *
         * Returns:
         *     RedirectResponse: Redirect to frontend with access token.
         *
         * Raises:
         *     HTTPException: If Google authentication fails.
         */
        fetchInfiniteQuery<TPageParam extends GoogleAuthApiV1AuthGoogleCallbackGetParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetData, GoogleAuthApiV1AuthGoogleCallbackGetParameters, DeepReadonly<TPageParam>, GoogleAuthApiV1AuthGoogleCallbackGetError> | void): Promise<OperationInfiniteData<GoogleAuthApiV1AuthGoogleCallbackGetData, GoogleAuthApiV1AuthGoogleCallbackGetParameters>>;
        /**
         * @summary Google Auth
         * @description Handle Google OAuth callback and create user session.
         *
         * Args:
         *     request (Request): FastAPI request object containing OAuth callback data.
         *     db (Session): Database session.
         *
         * Returns:
         *     RedirectResponse: Redirect to frontend with access token.
         *
         * Raises:
         *     HTTPException: If Google authentication fails.
         */
        prefetchInfiniteQuery<TPageParam extends GoogleAuthApiV1AuthGoogleCallbackGetParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetData, GoogleAuthApiV1AuthGoogleCallbackGetParameters, DeepReadonly<TPageParam>, GoogleAuthApiV1AuthGoogleCallbackGetError> | void): Promise<void>;
        /**
         * @summary Google Auth
         * @description Handle Google OAuth callback and create user session.
         *
         * Args:
         *     request (Request): FastAPI request object containing OAuth callback data.
         *     db (Session): Database session.
         *
         * Returns:
         *     RedirectResponse: Redirect to frontend with access token.
         *
         * Raises:
         *     HTTPException: If Google authentication fails.
         */
        ensureInfiniteQueryData<TPageParam extends GoogleAuthApiV1AuthGoogleCallbackGetParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetData, GoogleAuthApiV1AuthGoogleCallbackGetParameters, DeepReadonly<TPageParam>, GoogleAuthApiV1AuthGoogleCallbackGetError> | void): Promise<OperationInfiniteData<GoogleAuthApiV1AuthGoogleCallbackGetData, GoogleAuthApiV1AuthGoogleCallbackGetParameters>>;
        /**
         * @summary Google Auth
         * @description Handle Google OAuth callback and create user session.
         *
         * Args:
         *     request (Request): FastAPI request object containing OAuth callback data.
         *     db (Session): Database session.
         *
         * Returns:
         *     RedirectResponse: Redirect to frontend with access token.
         *
         * Raises:
         *     HTTPException: If Google authentication fails.
         */
        getQueryData(parameters: ServiceOperationQueryKey<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetParameters> | (DeepReadonly<GoogleAuthApiV1AuthGoogleCallbackGetParameters> | void)): GoogleAuthApiV1AuthGoogleCallbackGetData | undefined;
        /**
         * @summary Google Auth
         * @description Handle Google OAuth callback and create user session.
         *
         * Args:
         *     request (Request): FastAPI request object containing OAuth callback data.
         *     db (Session): Database session.
         *
         * Returns:
         *     RedirectResponse: Redirect to frontend with access token.
         *
         * Raises:
         *     HTTPException: If Google authentication fails.
         */
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetParameters> | (DeepReadonly<GoogleAuthApiV1AuthGoogleCallbackGetParameters> | void)): OperationInfiniteData<GoogleAuthApiV1AuthGoogleCallbackGetData, GoogleAuthApiV1AuthGoogleCallbackGetParameters> | undefined;
        /**
         * @summary Google Auth
         * @description Handle Google OAuth callback and create user session.
         *
         * Args:
         *     request (Request): FastAPI request object containing OAuth callback data.
         *     db (Session): Database session.
         *
         * Returns:
         *     RedirectResponse: Redirect to frontend with access token.
         *
         * Raises:
         *     HTTPException: If Google authentication fails.
         */
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetData, TInfinite, GoogleAuthApiV1AuthGoogleCallbackGetParameters, GoogleAuthApiV1AuthGoogleCallbackGetError> | QueryFiltersByQueryKey<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetData, TInfinite, GoogleAuthApiV1AuthGoogleCallbackGetParameters, GoogleAuthApiV1AuthGoogleCallbackGetError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetParameters>,
            data: NoInfer<OperationInfiniteData<GoogleAuthApiV1AuthGoogleCallbackGetData, GoogleAuthApiV1AuthGoogleCallbackGetParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetParameters>,
            data: GoogleAuthApiV1AuthGoogleCallbackGetData | undefined
        ]>;
        /**
         * @summary Google Auth
         * @description Handle Google OAuth callback and create user session.
         *
         * Args:
         *     request (Request): FastAPI request object containing OAuth callback data.
         *     db (Session): Database session.
         *
         * Returns:
         *     RedirectResponse: Redirect to frontend with access token.
         *
         * Raises:
         *     HTTPException: If Google authentication fails.
         */
        getQueryState(parameters: ServiceOperationQueryKey<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetParameters> | (DeepReadonly<GoogleAuthApiV1AuthGoogleCallbackGetParameters> | void)): QueryState<GoogleAuthApiV1AuthGoogleCallbackGetData, GoogleAuthApiV1AuthGoogleCallbackGetError> | undefined;
        /**
         * @summary Google Auth
         * @description Handle Google OAuth callback and create user session.
         *
         * Args:
         *     request (Request): FastAPI request object containing OAuth callback data.
         *     db (Session): Database session.
         *
         * Returns:
         *     RedirectResponse: Redirect to frontend with access token.
         *
         * Raises:
         *     HTTPException: If Google authentication fails.
         */
        getInfiniteQueryState(parameters: DeepReadonly<GoogleAuthApiV1AuthGoogleCallbackGetParameters> | ServiceOperationInfiniteQueryKey<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetParameters> | void): QueryState<OperationInfiniteData<GoogleAuthApiV1AuthGoogleCallbackGetData, GoogleAuthApiV1AuthGoogleCallbackGetParameters>, GoogleAuthApiV1AuthGoogleCallbackGetError> | undefined;
        /**
         * @summary Google Auth
         * @description Handle Google OAuth callback and create user session.
         *
         * Args:
         *     request (Request): FastAPI request object containing OAuth callback data.
         *     db (Session): Database session.
         *
         * Returns:
         *     RedirectResponse: Redirect to frontend with access token.
         *
         * Raises:
         *     HTTPException: If Google authentication fails.
         */
        setQueryData(parameters: (DeepReadonly<GoogleAuthApiV1AuthGoogleCallbackGetParameters> | undefined) | ServiceOperationQueryKey<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetParameters>, updater: Updater<NoInfer<GoogleAuthApiV1AuthGoogleCallbackGetData> | undefined, NoInfer<DeepReadonly<GoogleAuthApiV1AuthGoogleCallbackGetData>> | undefined>, options?: SetDataOptions): GoogleAuthApiV1AuthGoogleCallbackGetData | undefined;
        /**
         * @summary Google Auth
         * @description Handle Google OAuth callback and create user session.
         *
         * Args:
         *     request (Request): FastAPI request object containing OAuth callback data.
         *     db (Session): Database session.
         *
         * Returns:
         *     RedirectResponse: Redirect to frontend with access token.
         *
         * Raises:
         *     HTTPException: If Google authentication fails.
         */
        setInfiniteQueryData(parameters: (DeepReadonly<GoogleAuthApiV1AuthGoogleCallbackGetParameters> | undefined) | ServiceOperationInfiniteQueryKey<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetParameters>, updater: Updater<NoInfer<OperationInfiniteData<GoogleAuthApiV1AuthGoogleCallbackGetData, GoogleAuthApiV1AuthGoogleCallbackGetParameters>> | undefined, NoInfer<DeepReadonly<OperationInfiniteData<GoogleAuthApiV1AuthGoogleCallbackGetData, GoogleAuthApiV1AuthGoogleCallbackGetParameters>>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GoogleAuthApiV1AuthGoogleCallbackGetData, GoogleAuthApiV1AuthGoogleCallbackGetParameters> | undefined;
        /**
         * @summary Google Auth
         * @description Handle Google OAuth callback and create user session.
         *
         * Args:
         *     request (Request): FastAPI request object containing OAuth callback data.
         *     db (Session): Database session.
         *
         * Returns:
         *     RedirectResponse: Redirect to frontend with access token.
         *
         * Raises:
         *     HTTPException: If Google authentication fails.
         */
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetData, TInfinite, GoogleAuthApiV1AuthGoogleCallbackGetParameters, GoogleAuthApiV1AuthGoogleCallbackGetError> | QueryFiltersByQueryKey<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetData, TInfinite, GoogleAuthApiV1AuthGoogleCallbackGetParameters, GoogleAuthApiV1AuthGoogleCallbackGetError>, updater: Updater<NoInfer<GoogleAuthApiV1AuthGoogleCallbackGetData> | undefined, NoInfer<GoogleAuthApiV1AuthGoogleCallbackGetData> | undefined>, options?: SetDataOptions): Array<GoogleAuthApiV1AuthGoogleCallbackGetData | undefined>;
        /**
         * @summary Google Auth
         * @description Handle Google OAuth callback and create user session.
         *
         * Args:
         *     request (Request): FastAPI request object containing OAuth callback data.
         *     db (Session): Database session.
         *
         * Returns:
         *     RedirectResponse: Redirect to frontend with access token.
         *
         * Raises:
         *     HTTPException: If Google authentication fails.
         */
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetData, TInfinite, GoogleAuthApiV1AuthGoogleCallbackGetParameters, GoogleAuthApiV1AuthGoogleCallbackGetError>, options?: InvalidateOptions): Promise<void>;
        /**
         * @summary Google Auth
         * @description Handle Google OAuth callback and create user session.
         *
         * Args:
         *     request (Request): FastAPI request object containing OAuth callback data.
         *     db (Session): Database session.
         *
         * Returns:
         *     RedirectResponse: Redirect to frontend with access token.
         *
         * Raises:
         *     HTTPException: If Google authentication fails.
         */
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetData, TInfinite, GoogleAuthApiV1AuthGoogleCallbackGetParameters, GoogleAuthApiV1AuthGoogleCallbackGetError> | QueryFiltersByQueryKey<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetData, TInfinite, GoogleAuthApiV1AuthGoogleCallbackGetParameters, GoogleAuthApiV1AuthGoogleCallbackGetError>, options?: RefetchOptions): Promise<void>;
        /**
         * @summary Google Auth
         * @description Handle Google OAuth callback and create user session.
         *
         * Args:
         *     request (Request): FastAPI request object containing OAuth callback data.
         *     db (Session): Database session.
         *
         * Returns:
         *     RedirectResponse: Redirect to frontend with access token.
         *
         * Raises:
         *     HTTPException: If Google authentication fails.
         */
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetData, TInfinite, GoogleAuthApiV1AuthGoogleCallbackGetParameters, GoogleAuthApiV1AuthGoogleCallbackGetError> | QueryFiltersByQueryKey<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetData, TInfinite, GoogleAuthApiV1AuthGoogleCallbackGetParameters, GoogleAuthApiV1AuthGoogleCallbackGetError>, options?: CancelOptions): Promise<void>;
        /**
         * @summary Google Auth
         * @description Handle Google OAuth callback and create user session.
         *
         * Args:
         *     request (Request): FastAPI request object containing OAuth callback data.
         *     db (Session): Database session.
         *
         * Returns:
         *     RedirectResponse: Redirect to frontend with access token.
         *
         * Raises:
         *     HTTPException: If Google authentication fails.
         */
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetData, TInfinite, GoogleAuthApiV1AuthGoogleCallbackGetParameters, GoogleAuthApiV1AuthGoogleCallbackGetError> | QueryFiltersByQueryKey<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetData, TInfinite, GoogleAuthApiV1AuthGoogleCallbackGetParameters, GoogleAuthApiV1AuthGoogleCallbackGetError>): void;
        /**
         * @summary Google Auth
         * @description Handle Google OAuth callback and create user session.
         *
         * Args:
         *     request (Request): FastAPI request object containing OAuth callback data.
         *     db (Session): Database session.
         *
         * Returns:
         *     RedirectResponse: Redirect to frontend with access token.
         *
         * Raises:
         *     HTTPException: If Google authentication fails.
         */
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetData, TInfinite, GoogleAuthApiV1AuthGoogleCallbackGetParameters, GoogleAuthApiV1AuthGoogleCallbackGetError> | QueryFiltersByQueryKey<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetData, TInfinite, GoogleAuthApiV1AuthGoogleCallbackGetParameters, GoogleAuthApiV1AuthGoogleCallbackGetError>, options?: ResetOptions): Promise<void>;
        /**
         * @summary Google Auth
         * @description Handle Google OAuth callback and create user session.
         *
         * Args:
         *     request (Request): FastAPI request object containing OAuth callback data.
         *     db (Session): Database session.
         *
         * Returns:
         *     RedirectResponse: Redirect to frontend with access token.
         *
         * Raises:
         *     HTTPException: If Google authentication fails.
         */
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetData, TInfinite, GoogleAuthApiV1AuthGoogleCallbackGetParameters, GoogleAuthApiV1AuthGoogleCallbackGetError> | QueryFiltersByQueryKey<GoogleAuthApiV1AuthGoogleCallbackGetSchema, GoogleAuthApiV1AuthGoogleCallbackGetData, TInfinite, GoogleAuthApiV1AuthGoogleCallbackGetParameters, GoogleAuthApiV1AuthGoogleCallbackGetError>): number;
        schema: GoogleAuthApiV1AuthGoogleCallbackGetSchema;
        types: {
            parameters: GoogleAuthApiV1AuthGoogleCallbackGetParameters;
            data: GoogleAuthApiV1AuthGoogleCallbackGetData;
            error: GoogleAuthApiV1AuthGoogleCallbackGetError;
        };
    };
    /**
     * @summary Forgot Password
     * @description Handles password reset requests.
     *
     * args:
     *     request (ForgotPasswordRequest): Request containing the user's email.
     *
     * Returns:
     *     dict: Confirmation message about password reset email.
     */
    forgotPasswordApiV1AuthForgotPasswordPost: {
        /**
         * @summary Forgot Password
         * @description Handles password reset requests.
         *
         * args:
         *     request (ForgotPasswordRequest): Request containing the user's email.
         *
         * Returns:
         *     dict: Confirmation message about password reset email.
         */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: ServiceOperationMutationFnOptions<ForgotPasswordApiV1AuthForgotPasswordPostBody, ForgotPasswordApiV1AuthForgotPasswordPostParameters, TMeta, TSignal>, client?: (schema: ForgotPasswordApiV1AuthForgotPasswordPostSchema, options: ServiceOperationMutationFnOptions<ForgotPasswordApiV1AuthForgotPasswordPostBody, ForgotPasswordApiV1AuthForgotPasswordPostParameters, TMeta, TSignal>) => Promise<RequestFnResponse<ForgotPasswordApiV1AuthForgotPasswordPostData, ForgotPasswordApiV1AuthForgotPasswordPostError>>): Promise<RequestFnResponse<ForgotPasswordApiV1AuthForgotPasswordPostData, ForgotPasswordApiV1AuthForgotPasswordPostError>>;
        /**
         * @summary Forgot Password
         * @description Handles password reset requests.
         *
         * args:
         *     request (ForgotPasswordRequest): Request containing the user's email.
         *
         * Returns:
         *     dict: Confirmation message about password reset email.
         */
        getMutationKey(parameters: DeepReadonly<ForgotPasswordApiV1AuthForgotPasswordPostParameters> | void): ServiceOperationMutationKey<ForgotPasswordApiV1AuthForgotPasswordPostSchema, ForgotPasswordApiV1AuthForgotPasswordPostParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Forgot Password
         * @description Handles password reset requests.
         *
         * args:
         *     request (ForgotPasswordRequest): Request containing the user's email.
         *
         * Returns:
         *     dict: Confirmation message about password reset email.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.forgotPasswordApiV1AuthForgotPasswordPost.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.forgotPasswordApiV1AuthForgotPasswordPost.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends ForgotPasswordApiV1AuthForgotPasswordPostBody, TContext = unknown>(parameters: DeepReadonly<ForgotPasswordApiV1AuthForgotPasswordPostParameters>, options?: ServiceOperationUseMutationOptions<ForgotPasswordApiV1AuthForgotPasswordPostSchema, ForgotPasswordApiV1AuthForgotPasswordPostData, ForgotPasswordApiV1AuthForgotPasswordPostParameters, TVariables, OperationError<ForgotPasswordApiV1AuthForgotPasswordPostError>, TContext>): UseMutationResult<ForgotPasswordApiV1AuthForgotPasswordPostData, OperationError<ForgotPasswordApiV1AuthForgotPasswordPostError>, TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Forgot Password
         * @description Handles password reset requests.
         *
         * args:
         *     request (ForgotPasswordRequest): Request containing the user's email.
         *
         * Returns:
         *     dict: Confirmation message about password reset email.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.forgotPasswordApiV1AuthForgotPasswordPost.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.forgotPasswordApiV1AuthForgotPasswordPost.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<ForgotPasswordApiV1AuthForgotPasswordPostBody, ForgotPasswordApiV1AuthForgotPasswordPostParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<ForgotPasswordApiV1AuthForgotPasswordPostSchema, ForgotPasswordApiV1AuthForgotPasswordPostData, ForgotPasswordApiV1AuthForgotPasswordPostParameters, TVariables, OperationError<ForgotPasswordApiV1AuthForgotPasswordPostError>, TContext>): UseMutationResult<ForgotPasswordApiV1AuthForgotPasswordPostData, OperationError<ForgotPasswordApiV1AuthForgotPasswordPostError>, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @summary Forgot Password
         * @description Handles password reset requests.
         *
         * args:
         *     request (ForgotPasswordRequest): Request containing the user's email.
         *
         * Returns:
         *     dict: Confirmation message about password reset email.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const forgotPasswordApiV1AuthForgotPasswordPostTotal = qraft.apiService.forgotPasswordApiV1AuthForgotPasswordPost.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const forgotPasswordApiV1AuthForgotPasswordPostTotal = qraft.apiService.forgotPasswordApiV1AuthForgotPasswordPost.useIsMutating({
         *     parameters: {}
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<ForgotPasswordApiV1AuthForgotPasswordPostBody, ForgotPasswordApiV1AuthForgotPasswordPostData, ForgotPasswordApiV1AuthForgotPasswordPostParameters, OperationError<ForgotPasswordApiV1AuthForgotPasswordPostError>, TContext> | MutationFiltersByMutationKey<ForgotPasswordApiV1AuthForgotPasswordPostSchema, ForgotPasswordApiV1AuthForgotPasswordPostBody, ForgotPasswordApiV1AuthForgotPasswordPostData, ForgotPasswordApiV1AuthForgotPasswordPostParameters, OperationError<ForgotPasswordApiV1AuthForgotPasswordPostError>, TContext>): number;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @summary Forgot Password
         * @description Handles password reset requests.
         *
         * args:
         *     request (ForgotPasswordRequest): Request containing the user's email.
         *
         * Returns:
         *     dict: Confirmation message about password reset email.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const forgotPasswordApiV1AuthForgotPasswordPostPendingMutationVariables = qraft.apiService.forgotPasswordApiV1AuthForgotPasswordPost.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const forgotPasswordApiV1AuthForgotPasswordPostMutationData = qraft.apiService.forgotPasswordApiV1AuthForgotPasswordPost.useMutationState({
         *     filters: {
         *         parameters: {}
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<ForgotPasswordApiV1AuthForgotPasswordPostData, OperationError<ForgotPasswordApiV1AuthForgotPasswordPostError>, MutationVariables<ForgotPasswordApiV1AuthForgotPasswordPostBody, ForgotPasswordApiV1AuthForgotPasswordPostParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<ForgotPasswordApiV1AuthForgotPasswordPostBody, ForgotPasswordApiV1AuthForgotPasswordPostData, ForgotPasswordApiV1AuthForgotPasswordPostParameters, OperationError<ForgotPasswordApiV1AuthForgotPasswordPostError>, TContext> | MutationFiltersByMutationKey<ForgotPasswordApiV1AuthForgotPasswordPostSchema, ForgotPasswordApiV1AuthForgotPasswordPostBody, ForgotPasswordApiV1AuthForgotPasswordPostData, ForgotPasswordApiV1AuthForgotPasswordPostParameters, OperationError<ForgotPasswordApiV1AuthForgotPasswordPostError>, TContext>;
            select?: (mutation: Mutation<ForgotPasswordApiV1AuthForgotPasswordPostData, OperationError<ForgotPasswordApiV1AuthForgotPasswordPostError>, MutationVariables<ForgotPasswordApiV1AuthForgotPasswordPostBody, ForgotPasswordApiV1AuthForgotPasswordPostParameters>, TContext>) => TResult;
        }): Array<TResult>;
        /**
         * @summary Forgot Password
         * @description Handles password reset requests.
         *
         * args:
         *     request (ForgotPasswordRequest): Request containing the user's email.
         *
         * Returns:
         *     dict: Confirmation message about password reset email.
         */
        isMutating<TContext>(filters?: MutationFiltersByParameters<ForgotPasswordApiV1AuthForgotPasswordPostBody, ForgotPasswordApiV1AuthForgotPasswordPostData, ForgotPasswordApiV1AuthForgotPasswordPostParameters, OperationError<ForgotPasswordApiV1AuthForgotPasswordPostError>, TContext> | MutationFiltersByMutationKey<ForgotPasswordApiV1AuthForgotPasswordPostSchema, ForgotPasswordApiV1AuthForgotPasswordPostBody, ForgotPasswordApiV1AuthForgotPasswordPostData, ForgotPasswordApiV1AuthForgotPasswordPostParameters, OperationError<ForgotPasswordApiV1AuthForgotPasswordPostError>, TContext>): number;
        /**
         * Returns a `MutationCache` object that provides access to mutation cache operations
         * for the specific endpoint.
         *
         * @summary Forgot Password
         * @description Handles password reset requests.
         *
         * args:
         *     request (ForgotPasswordRequest): Request containing the user's email.
         *
         * Returns:
         *     dict: Confirmation message about password reset email.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/query-client/getMutationCache|`getMutationCache(...)` documentation}
         *
         * @example Find a mutation with specific parameters
         * ```ts
         * const mutationCache = qraft.apiService.forgotPasswordApiV1AuthForgotPasswordPost.getMutationCache();
         * const mutation = mutationCache.find({
         *     parameters: {}
         * });
         * ```
         *
         * @example Find all mutations for the endpoint
         * ```ts
         * const mutationCache = qraft.apiService.forgotPasswordApiV1AuthForgotPasswordPost.getMutationCache();
         * const mutations = mutationCache.findAll();
         * ```
         */
        getMutationCache(): Omit<MutationCache, "find" | "findAll"> & {
            find<TContext = unknown>(filters: MutationFiltersByParameters<ForgotPasswordApiV1AuthForgotPasswordPostBody, ForgotPasswordApiV1AuthForgotPasswordPostData, ForgotPasswordApiV1AuthForgotPasswordPostParameters, OperationError<ForgotPasswordApiV1AuthForgotPasswordPostError>, TContext> | MutationFiltersByMutationKey<ForgotPasswordApiV1AuthForgotPasswordPostSchema, ForgotPasswordApiV1AuthForgotPasswordPostBody, ForgotPasswordApiV1AuthForgotPasswordPostData, ForgotPasswordApiV1AuthForgotPasswordPostParameters, OperationError<ForgotPasswordApiV1AuthForgotPasswordPostError>, TContext>): Mutation<ForgotPasswordApiV1AuthForgotPasswordPostData, ForgotPasswordApiV1AuthForgotPasswordPostError, MutationVariables<ForgotPasswordApiV1AuthForgotPasswordPostBody, ForgotPasswordApiV1AuthForgotPasswordPostParameters>, TContext> | undefined;
            findAll<TContext = unknown>(filters?: MutationFiltersByParameters<ForgotPasswordApiV1AuthForgotPasswordPostBody, ForgotPasswordApiV1AuthForgotPasswordPostData, ForgotPasswordApiV1AuthForgotPasswordPostParameters, OperationError<ForgotPasswordApiV1AuthForgotPasswordPostError>, TContext> | MutationFiltersByMutationKey<ForgotPasswordApiV1AuthForgotPasswordPostSchema, ForgotPasswordApiV1AuthForgotPasswordPostBody, ForgotPasswordApiV1AuthForgotPasswordPostData, ForgotPasswordApiV1AuthForgotPasswordPostParameters, OperationError<ForgotPasswordApiV1AuthForgotPasswordPostError>, TContext>): Array<Mutation<ForgotPasswordApiV1AuthForgotPasswordPostData, ForgotPasswordApiV1AuthForgotPasswordPostError, MutationVariables<ForgotPasswordApiV1AuthForgotPasswordPostBody, ForgotPasswordApiV1AuthForgotPasswordPostParameters>, TContext>>;
        };
        schema: ForgotPasswordApiV1AuthForgotPasswordPostSchema;
        types: {
            parameters: ForgotPasswordApiV1AuthForgotPasswordPostParameters;
            data: ForgotPasswordApiV1AuthForgotPasswordPostData;
            error: ForgotPasswordApiV1AuthForgotPasswordPostError;
            body: ForgotPasswordApiV1AuthForgotPasswordPostBody;
        };
    };
    /**
     * @summary Verify Reset Token
     * @description Verify the validity of a password reset token.
     *
     * Args:
     *     request (VerifyResetTokenRequest): Request containing the reset token.
     *     auth_service (AuthService): Authentication service.
     * Returns:
     *     VerifyResetTokenResponse: Response indicating if the token is valid.
     */
    verifyResetTokenApiV1AuthVerifyResetTokenPost: {
        /**
         * @summary Verify Reset Token
         * @description Verify the validity of a password reset token.
         *
         * Args:
         *     request (VerifyResetTokenRequest): Request containing the reset token.
         *     auth_service (AuthService): Authentication service.
         * Returns:
         *     VerifyResetTokenResponse: Response indicating if the token is valid.
         */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: ServiceOperationMutationFnOptions<VerifyResetTokenApiV1AuthVerifyResetTokenPostBody, VerifyResetTokenApiV1AuthVerifyResetTokenPostParameters, TMeta, TSignal>, client?: (schema: VerifyResetTokenApiV1AuthVerifyResetTokenPostSchema, options: ServiceOperationMutationFnOptions<VerifyResetTokenApiV1AuthVerifyResetTokenPostBody, VerifyResetTokenApiV1AuthVerifyResetTokenPostParameters, TMeta, TSignal>) => Promise<RequestFnResponse<VerifyResetTokenApiV1AuthVerifyResetTokenPostData, VerifyResetTokenApiV1AuthVerifyResetTokenPostError>>): Promise<RequestFnResponse<VerifyResetTokenApiV1AuthVerifyResetTokenPostData, VerifyResetTokenApiV1AuthVerifyResetTokenPostError>>;
        /**
         * @summary Verify Reset Token
         * @description Verify the validity of a password reset token.
         *
         * Args:
         *     request (VerifyResetTokenRequest): Request containing the reset token.
         *     auth_service (AuthService): Authentication service.
         * Returns:
         *     VerifyResetTokenResponse: Response indicating if the token is valid.
         */
        getMutationKey(parameters: DeepReadonly<VerifyResetTokenApiV1AuthVerifyResetTokenPostParameters> | void): ServiceOperationMutationKey<VerifyResetTokenApiV1AuthVerifyResetTokenPostSchema, VerifyResetTokenApiV1AuthVerifyResetTokenPostParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Verify Reset Token
         * @description Verify the validity of a password reset token.
         *
         * Args:
         *     request (VerifyResetTokenRequest): Request containing the reset token.
         *     auth_service (AuthService): Authentication service.
         * Returns:
         *     VerifyResetTokenResponse: Response indicating if the token is valid.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.verifyResetTokenApiV1AuthVerifyResetTokenPost.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.verifyResetTokenApiV1AuthVerifyResetTokenPost.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends VerifyResetTokenApiV1AuthVerifyResetTokenPostBody, TContext = unknown>(parameters: DeepReadonly<VerifyResetTokenApiV1AuthVerifyResetTokenPostParameters>, options?: ServiceOperationUseMutationOptions<VerifyResetTokenApiV1AuthVerifyResetTokenPostSchema, VerifyResetTokenApiV1AuthVerifyResetTokenPostData, VerifyResetTokenApiV1AuthVerifyResetTokenPostParameters, TVariables, OperationError<VerifyResetTokenApiV1AuthVerifyResetTokenPostError>, TContext>): UseMutationResult<VerifyResetTokenApiV1AuthVerifyResetTokenPostData, OperationError<VerifyResetTokenApiV1AuthVerifyResetTokenPostError>, TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Verify Reset Token
         * @description Verify the validity of a password reset token.
         *
         * Args:
         *     request (VerifyResetTokenRequest): Request containing the reset token.
         *     auth_service (AuthService): Authentication service.
         * Returns:
         *     VerifyResetTokenResponse: Response indicating if the token is valid.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.verifyResetTokenApiV1AuthVerifyResetTokenPost.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.verifyResetTokenApiV1AuthVerifyResetTokenPost.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<VerifyResetTokenApiV1AuthVerifyResetTokenPostBody, VerifyResetTokenApiV1AuthVerifyResetTokenPostParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<VerifyResetTokenApiV1AuthVerifyResetTokenPostSchema, VerifyResetTokenApiV1AuthVerifyResetTokenPostData, VerifyResetTokenApiV1AuthVerifyResetTokenPostParameters, TVariables, OperationError<VerifyResetTokenApiV1AuthVerifyResetTokenPostError>, TContext>): UseMutationResult<VerifyResetTokenApiV1AuthVerifyResetTokenPostData, OperationError<VerifyResetTokenApiV1AuthVerifyResetTokenPostError>, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @summary Verify Reset Token
         * @description Verify the validity of a password reset token.
         *
         * Args:
         *     request (VerifyResetTokenRequest): Request containing the reset token.
         *     auth_service (AuthService): Authentication service.
         * Returns:
         *     VerifyResetTokenResponse: Response indicating if the token is valid.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const verifyResetTokenApiV1AuthVerifyResetTokenPostTotal = qraft.apiService.verifyResetTokenApiV1AuthVerifyResetTokenPost.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const verifyResetTokenApiV1AuthVerifyResetTokenPostTotal = qraft.apiService.verifyResetTokenApiV1AuthVerifyResetTokenPost.useIsMutating({
         *     parameters: {}
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<VerifyResetTokenApiV1AuthVerifyResetTokenPostBody, VerifyResetTokenApiV1AuthVerifyResetTokenPostData, VerifyResetTokenApiV1AuthVerifyResetTokenPostParameters, OperationError<VerifyResetTokenApiV1AuthVerifyResetTokenPostError>, TContext> | MutationFiltersByMutationKey<VerifyResetTokenApiV1AuthVerifyResetTokenPostSchema, VerifyResetTokenApiV1AuthVerifyResetTokenPostBody, VerifyResetTokenApiV1AuthVerifyResetTokenPostData, VerifyResetTokenApiV1AuthVerifyResetTokenPostParameters, OperationError<VerifyResetTokenApiV1AuthVerifyResetTokenPostError>, TContext>): number;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @summary Verify Reset Token
         * @description Verify the validity of a password reset token.
         *
         * Args:
         *     request (VerifyResetTokenRequest): Request containing the reset token.
         *     auth_service (AuthService): Authentication service.
         * Returns:
         *     VerifyResetTokenResponse: Response indicating if the token is valid.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const verifyResetTokenApiV1AuthVerifyResetTokenPostPendingMutationVariables = qraft.apiService.verifyResetTokenApiV1AuthVerifyResetTokenPost.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const verifyResetTokenApiV1AuthVerifyResetTokenPostMutationData = qraft.apiService.verifyResetTokenApiV1AuthVerifyResetTokenPost.useMutationState({
         *     filters: {
         *         parameters: {}
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<VerifyResetTokenApiV1AuthVerifyResetTokenPostData, OperationError<VerifyResetTokenApiV1AuthVerifyResetTokenPostError>, MutationVariables<VerifyResetTokenApiV1AuthVerifyResetTokenPostBody, VerifyResetTokenApiV1AuthVerifyResetTokenPostParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<VerifyResetTokenApiV1AuthVerifyResetTokenPostBody, VerifyResetTokenApiV1AuthVerifyResetTokenPostData, VerifyResetTokenApiV1AuthVerifyResetTokenPostParameters, OperationError<VerifyResetTokenApiV1AuthVerifyResetTokenPostError>, TContext> | MutationFiltersByMutationKey<VerifyResetTokenApiV1AuthVerifyResetTokenPostSchema, VerifyResetTokenApiV1AuthVerifyResetTokenPostBody, VerifyResetTokenApiV1AuthVerifyResetTokenPostData, VerifyResetTokenApiV1AuthVerifyResetTokenPostParameters, OperationError<VerifyResetTokenApiV1AuthVerifyResetTokenPostError>, TContext>;
            select?: (mutation: Mutation<VerifyResetTokenApiV1AuthVerifyResetTokenPostData, OperationError<VerifyResetTokenApiV1AuthVerifyResetTokenPostError>, MutationVariables<VerifyResetTokenApiV1AuthVerifyResetTokenPostBody, VerifyResetTokenApiV1AuthVerifyResetTokenPostParameters>, TContext>) => TResult;
        }): Array<TResult>;
        /**
         * @summary Verify Reset Token
         * @description Verify the validity of a password reset token.
         *
         * Args:
         *     request (VerifyResetTokenRequest): Request containing the reset token.
         *     auth_service (AuthService): Authentication service.
         * Returns:
         *     VerifyResetTokenResponse: Response indicating if the token is valid.
         */
        isMutating<TContext>(filters?: MutationFiltersByParameters<VerifyResetTokenApiV1AuthVerifyResetTokenPostBody, VerifyResetTokenApiV1AuthVerifyResetTokenPostData, VerifyResetTokenApiV1AuthVerifyResetTokenPostParameters, OperationError<VerifyResetTokenApiV1AuthVerifyResetTokenPostError>, TContext> | MutationFiltersByMutationKey<VerifyResetTokenApiV1AuthVerifyResetTokenPostSchema, VerifyResetTokenApiV1AuthVerifyResetTokenPostBody, VerifyResetTokenApiV1AuthVerifyResetTokenPostData, VerifyResetTokenApiV1AuthVerifyResetTokenPostParameters, OperationError<VerifyResetTokenApiV1AuthVerifyResetTokenPostError>, TContext>): number;
        /**
         * Returns a `MutationCache` object that provides access to mutation cache operations
         * for the specific endpoint.
         *
         * @summary Verify Reset Token
         * @description Verify the validity of a password reset token.
         *
         * Args:
         *     request (VerifyResetTokenRequest): Request containing the reset token.
         *     auth_service (AuthService): Authentication service.
         * Returns:
         *     VerifyResetTokenResponse: Response indicating if the token is valid.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/query-client/getMutationCache|`getMutationCache(...)` documentation}
         *
         * @example Find a mutation with specific parameters
         * ```ts
         * const mutationCache = qraft.apiService.verifyResetTokenApiV1AuthVerifyResetTokenPost.getMutationCache();
         * const mutation = mutationCache.find({
         *     parameters: {}
         * });
         * ```
         *
         * @example Find all mutations for the endpoint
         * ```ts
         * const mutationCache = qraft.apiService.verifyResetTokenApiV1AuthVerifyResetTokenPost.getMutationCache();
         * const mutations = mutationCache.findAll();
         * ```
         */
        getMutationCache(): Omit<MutationCache, "find" | "findAll"> & {
            find<TContext = unknown>(filters: MutationFiltersByParameters<VerifyResetTokenApiV1AuthVerifyResetTokenPostBody, VerifyResetTokenApiV1AuthVerifyResetTokenPostData, VerifyResetTokenApiV1AuthVerifyResetTokenPostParameters, OperationError<VerifyResetTokenApiV1AuthVerifyResetTokenPostError>, TContext> | MutationFiltersByMutationKey<VerifyResetTokenApiV1AuthVerifyResetTokenPostSchema, VerifyResetTokenApiV1AuthVerifyResetTokenPostBody, VerifyResetTokenApiV1AuthVerifyResetTokenPostData, VerifyResetTokenApiV1AuthVerifyResetTokenPostParameters, OperationError<VerifyResetTokenApiV1AuthVerifyResetTokenPostError>, TContext>): Mutation<VerifyResetTokenApiV1AuthVerifyResetTokenPostData, VerifyResetTokenApiV1AuthVerifyResetTokenPostError, MutationVariables<VerifyResetTokenApiV1AuthVerifyResetTokenPostBody, VerifyResetTokenApiV1AuthVerifyResetTokenPostParameters>, TContext> | undefined;
            findAll<TContext = unknown>(filters?: MutationFiltersByParameters<VerifyResetTokenApiV1AuthVerifyResetTokenPostBody, VerifyResetTokenApiV1AuthVerifyResetTokenPostData, VerifyResetTokenApiV1AuthVerifyResetTokenPostParameters, OperationError<VerifyResetTokenApiV1AuthVerifyResetTokenPostError>, TContext> | MutationFiltersByMutationKey<VerifyResetTokenApiV1AuthVerifyResetTokenPostSchema, VerifyResetTokenApiV1AuthVerifyResetTokenPostBody, VerifyResetTokenApiV1AuthVerifyResetTokenPostData, VerifyResetTokenApiV1AuthVerifyResetTokenPostParameters, OperationError<VerifyResetTokenApiV1AuthVerifyResetTokenPostError>, TContext>): Array<Mutation<VerifyResetTokenApiV1AuthVerifyResetTokenPostData, VerifyResetTokenApiV1AuthVerifyResetTokenPostError, MutationVariables<VerifyResetTokenApiV1AuthVerifyResetTokenPostBody, VerifyResetTokenApiV1AuthVerifyResetTokenPostParameters>, TContext>>;
        };
        schema: VerifyResetTokenApiV1AuthVerifyResetTokenPostSchema;
        types: {
            parameters: VerifyResetTokenApiV1AuthVerifyResetTokenPostParameters;
            data: VerifyResetTokenApiV1AuthVerifyResetTokenPostData;
            error: VerifyResetTokenApiV1AuthVerifyResetTokenPostError;
            body: VerifyResetTokenApiV1AuthVerifyResetTokenPostBody;
        };
    };
    /**
     * @summary Reset Password
     * @description Reset user's password using a valid reset token.
     *
     * Args:
     *     request (ResetPasswordRequest): Request containing the reset token and new password.
     *     auth_service (AuthService): Authentication service.
     * Returns:
     *     dict: Confirmation message about successful password reset.
     */
    resetPasswordApiV1AuthResetPasswordPost: {
        /**
         * @summary Reset Password
         * @description Reset user's password using a valid reset token.
         *
         * Args:
         *     request (ResetPasswordRequest): Request containing the reset token and new password.
         *     auth_service (AuthService): Authentication service.
         * Returns:
         *     dict: Confirmation message about successful password reset.
         */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: ServiceOperationMutationFnOptions<ResetPasswordApiV1AuthResetPasswordPostBody, ResetPasswordApiV1AuthResetPasswordPostParameters, TMeta, TSignal>, client?: (schema: ResetPasswordApiV1AuthResetPasswordPostSchema, options: ServiceOperationMutationFnOptions<ResetPasswordApiV1AuthResetPasswordPostBody, ResetPasswordApiV1AuthResetPasswordPostParameters, TMeta, TSignal>) => Promise<RequestFnResponse<ResetPasswordApiV1AuthResetPasswordPostData, ResetPasswordApiV1AuthResetPasswordPostError>>): Promise<RequestFnResponse<ResetPasswordApiV1AuthResetPasswordPostData, ResetPasswordApiV1AuthResetPasswordPostError>>;
        /**
         * @summary Reset Password
         * @description Reset user's password using a valid reset token.
         *
         * Args:
         *     request (ResetPasswordRequest): Request containing the reset token and new password.
         *     auth_service (AuthService): Authentication service.
         * Returns:
         *     dict: Confirmation message about successful password reset.
         */
        getMutationKey(parameters: DeepReadonly<ResetPasswordApiV1AuthResetPasswordPostParameters> | void): ServiceOperationMutationKey<ResetPasswordApiV1AuthResetPasswordPostSchema, ResetPasswordApiV1AuthResetPasswordPostParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Reset Password
         * @description Reset user's password using a valid reset token.
         *
         * Args:
         *     request (ResetPasswordRequest): Request containing the reset token and new password.
         *     auth_service (AuthService): Authentication service.
         * Returns:
         *     dict: Confirmation message about successful password reset.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.resetPasswordApiV1AuthResetPasswordPost.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.resetPasswordApiV1AuthResetPasswordPost.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends ResetPasswordApiV1AuthResetPasswordPostBody, TContext = unknown>(parameters: DeepReadonly<ResetPasswordApiV1AuthResetPasswordPostParameters>, options?: ServiceOperationUseMutationOptions<ResetPasswordApiV1AuthResetPasswordPostSchema, ResetPasswordApiV1AuthResetPasswordPostData, ResetPasswordApiV1AuthResetPasswordPostParameters, TVariables, OperationError<ResetPasswordApiV1AuthResetPasswordPostError>, TContext>): UseMutationResult<ResetPasswordApiV1AuthResetPasswordPostData, OperationError<ResetPasswordApiV1AuthResetPasswordPostError>, TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Reset Password
         * @description Reset user's password using a valid reset token.
         *
         * Args:
         *     request (ResetPasswordRequest): Request containing the reset token and new password.
         *     auth_service (AuthService): Authentication service.
         * Returns:
         *     dict: Confirmation message about successful password reset.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.resetPasswordApiV1AuthResetPasswordPost.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.resetPasswordApiV1AuthResetPasswordPost.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<ResetPasswordApiV1AuthResetPasswordPostBody, ResetPasswordApiV1AuthResetPasswordPostParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<ResetPasswordApiV1AuthResetPasswordPostSchema, ResetPasswordApiV1AuthResetPasswordPostData, ResetPasswordApiV1AuthResetPasswordPostParameters, TVariables, OperationError<ResetPasswordApiV1AuthResetPasswordPostError>, TContext>): UseMutationResult<ResetPasswordApiV1AuthResetPasswordPostData, OperationError<ResetPasswordApiV1AuthResetPasswordPostError>, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @summary Reset Password
         * @description Reset user's password using a valid reset token.
         *
         * Args:
         *     request (ResetPasswordRequest): Request containing the reset token and new password.
         *     auth_service (AuthService): Authentication service.
         * Returns:
         *     dict: Confirmation message about successful password reset.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const resetPasswordApiV1AuthResetPasswordPostTotal = qraft.apiService.resetPasswordApiV1AuthResetPasswordPost.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const resetPasswordApiV1AuthResetPasswordPostTotal = qraft.apiService.resetPasswordApiV1AuthResetPasswordPost.useIsMutating({
         *     parameters: {}
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<ResetPasswordApiV1AuthResetPasswordPostBody, ResetPasswordApiV1AuthResetPasswordPostData, ResetPasswordApiV1AuthResetPasswordPostParameters, OperationError<ResetPasswordApiV1AuthResetPasswordPostError>, TContext> | MutationFiltersByMutationKey<ResetPasswordApiV1AuthResetPasswordPostSchema, ResetPasswordApiV1AuthResetPasswordPostBody, ResetPasswordApiV1AuthResetPasswordPostData, ResetPasswordApiV1AuthResetPasswordPostParameters, OperationError<ResetPasswordApiV1AuthResetPasswordPostError>, TContext>): number;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @summary Reset Password
         * @description Reset user's password using a valid reset token.
         *
         * Args:
         *     request (ResetPasswordRequest): Request containing the reset token and new password.
         *     auth_service (AuthService): Authentication service.
         * Returns:
         *     dict: Confirmation message about successful password reset.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const resetPasswordApiV1AuthResetPasswordPostPendingMutationVariables = qraft.apiService.resetPasswordApiV1AuthResetPasswordPost.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const resetPasswordApiV1AuthResetPasswordPostMutationData = qraft.apiService.resetPasswordApiV1AuthResetPasswordPost.useMutationState({
         *     filters: {
         *         parameters: {}
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<ResetPasswordApiV1AuthResetPasswordPostData, OperationError<ResetPasswordApiV1AuthResetPasswordPostError>, MutationVariables<ResetPasswordApiV1AuthResetPasswordPostBody, ResetPasswordApiV1AuthResetPasswordPostParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<ResetPasswordApiV1AuthResetPasswordPostBody, ResetPasswordApiV1AuthResetPasswordPostData, ResetPasswordApiV1AuthResetPasswordPostParameters, OperationError<ResetPasswordApiV1AuthResetPasswordPostError>, TContext> | MutationFiltersByMutationKey<ResetPasswordApiV1AuthResetPasswordPostSchema, ResetPasswordApiV1AuthResetPasswordPostBody, ResetPasswordApiV1AuthResetPasswordPostData, ResetPasswordApiV1AuthResetPasswordPostParameters, OperationError<ResetPasswordApiV1AuthResetPasswordPostError>, TContext>;
            select?: (mutation: Mutation<ResetPasswordApiV1AuthResetPasswordPostData, OperationError<ResetPasswordApiV1AuthResetPasswordPostError>, MutationVariables<ResetPasswordApiV1AuthResetPasswordPostBody, ResetPasswordApiV1AuthResetPasswordPostParameters>, TContext>) => TResult;
        }): Array<TResult>;
        /**
         * @summary Reset Password
         * @description Reset user's password using a valid reset token.
         *
         * Args:
         *     request (ResetPasswordRequest): Request containing the reset token and new password.
         *     auth_service (AuthService): Authentication service.
         * Returns:
         *     dict: Confirmation message about successful password reset.
         */
        isMutating<TContext>(filters?: MutationFiltersByParameters<ResetPasswordApiV1AuthResetPasswordPostBody, ResetPasswordApiV1AuthResetPasswordPostData, ResetPasswordApiV1AuthResetPasswordPostParameters, OperationError<ResetPasswordApiV1AuthResetPasswordPostError>, TContext> | MutationFiltersByMutationKey<ResetPasswordApiV1AuthResetPasswordPostSchema, ResetPasswordApiV1AuthResetPasswordPostBody, ResetPasswordApiV1AuthResetPasswordPostData, ResetPasswordApiV1AuthResetPasswordPostParameters, OperationError<ResetPasswordApiV1AuthResetPasswordPostError>, TContext>): number;
        /**
         * Returns a `MutationCache` object that provides access to mutation cache operations
         * for the specific endpoint.
         *
         * @summary Reset Password
         * @description Reset user's password using a valid reset token.
         *
         * Args:
         *     request (ResetPasswordRequest): Request containing the reset token and new password.
         *     auth_service (AuthService): Authentication service.
         * Returns:
         *     dict: Confirmation message about successful password reset.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/query-client/getMutationCache|`getMutationCache(...)` documentation}
         *
         * @example Find a mutation with specific parameters
         * ```ts
         * const mutationCache = qraft.apiService.resetPasswordApiV1AuthResetPasswordPost.getMutationCache();
         * const mutation = mutationCache.find({
         *     parameters: {}
         * });
         * ```
         *
         * @example Find all mutations for the endpoint
         * ```ts
         * const mutationCache = qraft.apiService.resetPasswordApiV1AuthResetPasswordPost.getMutationCache();
         * const mutations = mutationCache.findAll();
         * ```
         */
        getMutationCache(): Omit<MutationCache, "find" | "findAll"> & {
            find<TContext = unknown>(filters: MutationFiltersByParameters<ResetPasswordApiV1AuthResetPasswordPostBody, ResetPasswordApiV1AuthResetPasswordPostData, ResetPasswordApiV1AuthResetPasswordPostParameters, OperationError<ResetPasswordApiV1AuthResetPasswordPostError>, TContext> | MutationFiltersByMutationKey<ResetPasswordApiV1AuthResetPasswordPostSchema, ResetPasswordApiV1AuthResetPasswordPostBody, ResetPasswordApiV1AuthResetPasswordPostData, ResetPasswordApiV1AuthResetPasswordPostParameters, OperationError<ResetPasswordApiV1AuthResetPasswordPostError>, TContext>): Mutation<ResetPasswordApiV1AuthResetPasswordPostData, ResetPasswordApiV1AuthResetPasswordPostError, MutationVariables<ResetPasswordApiV1AuthResetPasswordPostBody, ResetPasswordApiV1AuthResetPasswordPostParameters>, TContext> | undefined;
            findAll<TContext = unknown>(filters?: MutationFiltersByParameters<ResetPasswordApiV1AuthResetPasswordPostBody, ResetPasswordApiV1AuthResetPasswordPostData, ResetPasswordApiV1AuthResetPasswordPostParameters, OperationError<ResetPasswordApiV1AuthResetPasswordPostError>, TContext> | MutationFiltersByMutationKey<ResetPasswordApiV1AuthResetPasswordPostSchema, ResetPasswordApiV1AuthResetPasswordPostBody, ResetPasswordApiV1AuthResetPasswordPostData, ResetPasswordApiV1AuthResetPasswordPostParameters, OperationError<ResetPasswordApiV1AuthResetPasswordPostError>, TContext>): Array<Mutation<ResetPasswordApiV1AuthResetPasswordPostData, ResetPasswordApiV1AuthResetPasswordPostError, MutationVariables<ResetPasswordApiV1AuthResetPasswordPostBody, ResetPasswordApiV1AuthResetPasswordPostParameters>, TContext>>;
        };
        schema: ResetPasswordApiV1AuthResetPasswordPostSchema;
        types: {
            parameters: ResetPasswordApiV1AuthResetPasswordPostParameters;
            data: ResetPasswordApiV1AuthResetPasswordPostData;
            error: ResetPasswordApiV1AuthResetPasswordPostError;
            body: ResetPasswordApiV1AuthResetPasswordPostBody;
        };
    };
    /**
     * @summary Check Email Status
     * @description Check if the email is verified.
     *
     * Args:
     *     payload (CheckEmailStatusRequest): Request containing the user's email.
     *     auth_service (AuthService): Authentication service.
     * Returns:
     *     CheckEmailStatusResponse: Response indicating if the email is verified.
     */
    checkEmailStatusApiV1AuthCheckEmailStatusPost: {
        /**
         * @summary Check Email Status
         * @description Check if the email is verified.
         *
         * Args:
         *     payload (CheckEmailStatusRequest): Request containing the user's email.
         *     auth_service (AuthService): Authentication service.
         * Returns:
         *     CheckEmailStatusResponse: Response indicating if the email is verified.
         */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: ServiceOperationMutationFnOptions<CheckEmailStatusApiV1AuthCheckEmailStatusPostBody, CheckEmailStatusApiV1AuthCheckEmailStatusPostParameters, TMeta, TSignal>, client?: (schema: CheckEmailStatusApiV1AuthCheckEmailStatusPostSchema, options: ServiceOperationMutationFnOptions<CheckEmailStatusApiV1AuthCheckEmailStatusPostBody, CheckEmailStatusApiV1AuthCheckEmailStatusPostParameters, TMeta, TSignal>) => Promise<RequestFnResponse<CheckEmailStatusApiV1AuthCheckEmailStatusPostData, CheckEmailStatusApiV1AuthCheckEmailStatusPostError>>): Promise<RequestFnResponse<CheckEmailStatusApiV1AuthCheckEmailStatusPostData, CheckEmailStatusApiV1AuthCheckEmailStatusPostError>>;
        /**
         * @summary Check Email Status
         * @description Check if the email is verified.
         *
         * Args:
         *     payload (CheckEmailStatusRequest): Request containing the user's email.
         *     auth_service (AuthService): Authentication service.
         * Returns:
         *     CheckEmailStatusResponse: Response indicating if the email is verified.
         */
        getMutationKey(parameters: DeepReadonly<CheckEmailStatusApiV1AuthCheckEmailStatusPostParameters> | void): ServiceOperationMutationKey<CheckEmailStatusApiV1AuthCheckEmailStatusPostSchema, CheckEmailStatusApiV1AuthCheckEmailStatusPostParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Check Email Status
         * @description Check if the email is verified.
         *
         * Args:
         *     payload (CheckEmailStatusRequest): Request containing the user's email.
         *     auth_service (AuthService): Authentication service.
         * Returns:
         *     CheckEmailStatusResponse: Response indicating if the email is verified.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.checkEmailStatusApiV1AuthCheckEmailStatusPost.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.checkEmailStatusApiV1AuthCheckEmailStatusPost.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends CheckEmailStatusApiV1AuthCheckEmailStatusPostBody, TContext = unknown>(parameters: DeepReadonly<CheckEmailStatusApiV1AuthCheckEmailStatusPostParameters>, options?: ServiceOperationUseMutationOptions<CheckEmailStatusApiV1AuthCheckEmailStatusPostSchema, CheckEmailStatusApiV1AuthCheckEmailStatusPostData, CheckEmailStatusApiV1AuthCheckEmailStatusPostParameters, TVariables, OperationError<CheckEmailStatusApiV1AuthCheckEmailStatusPostError>, TContext>): UseMutationResult<CheckEmailStatusApiV1AuthCheckEmailStatusPostData, OperationError<CheckEmailStatusApiV1AuthCheckEmailStatusPostError>, TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Check Email Status
         * @description Check if the email is verified.
         *
         * Args:
         *     payload (CheckEmailStatusRequest): Request containing the user's email.
         *     auth_service (AuthService): Authentication service.
         * Returns:
         *     CheckEmailStatusResponse: Response indicating if the email is verified.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.checkEmailStatusApiV1AuthCheckEmailStatusPost.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.checkEmailStatusApiV1AuthCheckEmailStatusPost.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<CheckEmailStatusApiV1AuthCheckEmailStatusPostBody, CheckEmailStatusApiV1AuthCheckEmailStatusPostParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<CheckEmailStatusApiV1AuthCheckEmailStatusPostSchema, CheckEmailStatusApiV1AuthCheckEmailStatusPostData, CheckEmailStatusApiV1AuthCheckEmailStatusPostParameters, TVariables, OperationError<CheckEmailStatusApiV1AuthCheckEmailStatusPostError>, TContext>): UseMutationResult<CheckEmailStatusApiV1AuthCheckEmailStatusPostData, OperationError<CheckEmailStatusApiV1AuthCheckEmailStatusPostError>, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @summary Check Email Status
         * @description Check if the email is verified.
         *
         * Args:
         *     payload (CheckEmailStatusRequest): Request containing the user's email.
         *     auth_service (AuthService): Authentication service.
         * Returns:
         *     CheckEmailStatusResponse: Response indicating if the email is verified.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const checkEmailStatusApiV1AuthCheckEmailStatusPostTotal = qraft.apiService.checkEmailStatusApiV1AuthCheckEmailStatusPost.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const checkEmailStatusApiV1AuthCheckEmailStatusPostTotal = qraft.apiService.checkEmailStatusApiV1AuthCheckEmailStatusPost.useIsMutating({
         *     parameters: {}
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<CheckEmailStatusApiV1AuthCheckEmailStatusPostBody, CheckEmailStatusApiV1AuthCheckEmailStatusPostData, CheckEmailStatusApiV1AuthCheckEmailStatusPostParameters, OperationError<CheckEmailStatusApiV1AuthCheckEmailStatusPostError>, TContext> | MutationFiltersByMutationKey<CheckEmailStatusApiV1AuthCheckEmailStatusPostSchema, CheckEmailStatusApiV1AuthCheckEmailStatusPostBody, CheckEmailStatusApiV1AuthCheckEmailStatusPostData, CheckEmailStatusApiV1AuthCheckEmailStatusPostParameters, OperationError<CheckEmailStatusApiV1AuthCheckEmailStatusPostError>, TContext>): number;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @summary Check Email Status
         * @description Check if the email is verified.
         *
         * Args:
         *     payload (CheckEmailStatusRequest): Request containing the user's email.
         *     auth_service (AuthService): Authentication service.
         * Returns:
         *     CheckEmailStatusResponse: Response indicating if the email is verified.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const checkEmailStatusApiV1AuthCheckEmailStatusPostPendingMutationVariables = qraft.apiService.checkEmailStatusApiV1AuthCheckEmailStatusPost.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const checkEmailStatusApiV1AuthCheckEmailStatusPostMutationData = qraft.apiService.checkEmailStatusApiV1AuthCheckEmailStatusPost.useMutationState({
         *     filters: {
         *         parameters: {}
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<CheckEmailStatusApiV1AuthCheckEmailStatusPostData, OperationError<CheckEmailStatusApiV1AuthCheckEmailStatusPostError>, MutationVariables<CheckEmailStatusApiV1AuthCheckEmailStatusPostBody, CheckEmailStatusApiV1AuthCheckEmailStatusPostParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<CheckEmailStatusApiV1AuthCheckEmailStatusPostBody, CheckEmailStatusApiV1AuthCheckEmailStatusPostData, CheckEmailStatusApiV1AuthCheckEmailStatusPostParameters, OperationError<CheckEmailStatusApiV1AuthCheckEmailStatusPostError>, TContext> | MutationFiltersByMutationKey<CheckEmailStatusApiV1AuthCheckEmailStatusPostSchema, CheckEmailStatusApiV1AuthCheckEmailStatusPostBody, CheckEmailStatusApiV1AuthCheckEmailStatusPostData, CheckEmailStatusApiV1AuthCheckEmailStatusPostParameters, OperationError<CheckEmailStatusApiV1AuthCheckEmailStatusPostError>, TContext>;
            select?: (mutation: Mutation<CheckEmailStatusApiV1AuthCheckEmailStatusPostData, OperationError<CheckEmailStatusApiV1AuthCheckEmailStatusPostError>, MutationVariables<CheckEmailStatusApiV1AuthCheckEmailStatusPostBody, CheckEmailStatusApiV1AuthCheckEmailStatusPostParameters>, TContext>) => TResult;
        }): Array<TResult>;
        /**
         * @summary Check Email Status
         * @description Check if the email is verified.
         *
         * Args:
         *     payload (CheckEmailStatusRequest): Request containing the user's email.
         *     auth_service (AuthService): Authentication service.
         * Returns:
         *     CheckEmailStatusResponse: Response indicating if the email is verified.
         */
        isMutating<TContext>(filters?: MutationFiltersByParameters<CheckEmailStatusApiV1AuthCheckEmailStatusPostBody, CheckEmailStatusApiV1AuthCheckEmailStatusPostData, CheckEmailStatusApiV1AuthCheckEmailStatusPostParameters, OperationError<CheckEmailStatusApiV1AuthCheckEmailStatusPostError>, TContext> | MutationFiltersByMutationKey<CheckEmailStatusApiV1AuthCheckEmailStatusPostSchema, CheckEmailStatusApiV1AuthCheckEmailStatusPostBody, CheckEmailStatusApiV1AuthCheckEmailStatusPostData, CheckEmailStatusApiV1AuthCheckEmailStatusPostParameters, OperationError<CheckEmailStatusApiV1AuthCheckEmailStatusPostError>, TContext>): number;
        /**
         * Returns a `MutationCache` object that provides access to mutation cache operations
         * for the specific endpoint.
         *
         * @summary Check Email Status
         * @description Check if the email is verified.
         *
         * Args:
         *     payload (CheckEmailStatusRequest): Request containing the user's email.
         *     auth_service (AuthService): Authentication service.
         * Returns:
         *     CheckEmailStatusResponse: Response indicating if the email is verified.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/query-client/getMutationCache|`getMutationCache(...)` documentation}
         *
         * @example Find a mutation with specific parameters
         * ```ts
         * const mutationCache = qraft.apiService.checkEmailStatusApiV1AuthCheckEmailStatusPost.getMutationCache();
         * const mutation = mutationCache.find({
         *     parameters: {}
         * });
         * ```
         *
         * @example Find all mutations for the endpoint
         * ```ts
         * const mutationCache = qraft.apiService.checkEmailStatusApiV1AuthCheckEmailStatusPost.getMutationCache();
         * const mutations = mutationCache.findAll();
         * ```
         */
        getMutationCache(): Omit<MutationCache, "find" | "findAll"> & {
            find<TContext = unknown>(filters: MutationFiltersByParameters<CheckEmailStatusApiV1AuthCheckEmailStatusPostBody, CheckEmailStatusApiV1AuthCheckEmailStatusPostData, CheckEmailStatusApiV1AuthCheckEmailStatusPostParameters, OperationError<CheckEmailStatusApiV1AuthCheckEmailStatusPostError>, TContext> | MutationFiltersByMutationKey<CheckEmailStatusApiV1AuthCheckEmailStatusPostSchema, CheckEmailStatusApiV1AuthCheckEmailStatusPostBody, CheckEmailStatusApiV1AuthCheckEmailStatusPostData, CheckEmailStatusApiV1AuthCheckEmailStatusPostParameters, OperationError<CheckEmailStatusApiV1AuthCheckEmailStatusPostError>, TContext>): Mutation<CheckEmailStatusApiV1AuthCheckEmailStatusPostData, CheckEmailStatusApiV1AuthCheckEmailStatusPostError, MutationVariables<CheckEmailStatusApiV1AuthCheckEmailStatusPostBody, CheckEmailStatusApiV1AuthCheckEmailStatusPostParameters>, TContext> | undefined;
            findAll<TContext = unknown>(filters?: MutationFiltersByParameters<CheckEmailStatusApiV1AuthCheckEmailStatusPostBody, CheckEmailStatusApiV1AuthCheckEmailStatusPostData, CheckEmailStatusApiV1AuthCheckEmailStatusPostParameters, OperationError<CheckEmailStatusApiV1AuthCheckEmailStatusPostError>, TContext> | MutationFiltersByMutationKey<CheckEmailStatusApiV1AuthCheckEmailStatusPostSchema, CheckEmailStatusApiV1AuthCheckEmailStatusPostBody, CheckEmailStatusApiV1AuthCheckEmailStatusPostData, CheckEmailStatusApiV1AuthCheckEmailStatusPostParameters, OperationError<CheckEmailStatusApiV1AuthCheckEmailStatusPostError>, TContext>): Array<Mutation<CheckEmailStatusApiV1AuthCheckEmailStatusPostData, CheckEmailStatusApiV1AuthCheckEmailStatusPostError, MutationVariables<CheckEmailStatusApiV1AuthCheckEmailStatusPostBody, CheckEmailStatusApiV1AuthCheckEmailStatusPostParameters>, TContext>>;
        };
        schema: CheckEmailStatusApiV1AuthCheckEmailStatusPostSchema;
        types: {
            parameters: CheckEmailStatusApiV1AuthCheckEmailStatusPostParameters;
            data: CheckEmailStatusApiV1AuthCheckEmailStatusPostData;
            error: CheckEmailStatusApiV1AuthCheckEmailStatusPostError;
            body: CheckEmailStatusApiV1AuthCheckEmailStatusPostBody;
        };
    };
    /**
     * @summary Verify Code Token
     * @description Verify the validity of a signup/login verification token.
     *
     * Args:
     *     payload (VerifyCodeTokenRequest): JWT token containing the verification code.
     *
     * Returns:
     *     dict: Response indicating if the token is valid.
     */
    verifyCodeTokenApiV1AuthVerifyCodeTokenPost: {
        /**
         * @summary Verify Code Token
         * @description Verify the validity of a signup/login verification token.
         *
         * Args:
         *     payload (VerifyCodeTokenRequest): JWT token containing the verification code.
         *
         * Returns:
         *     dict: Response indicating if the token is valid.
         */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: ServiceOperationMutationFnOptions<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostBody, VerifyCodeTokenApiV1AuthVerifyCodeTokenPostParameters, TMeta, TSignal>, client?: (schema: VerifyCodeTokenApiV1AuthVerifyCodeTokenPostSchema, options: ServiceOperationMutationFnOptions<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostBody, VerifyCodeTokenApiV1AuthVerifyCodeTokenPostParameters, TMeta, TSignal>) => Promise<RequestFnResponse<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostData, VerifyCodeTokenApiV1AuthVerifyCodeTokenPostError>>): Promise<RequestFnResponse<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostData, VerifyCodeTokenApiV1AuthVerifyCodeTokenPostError>>;
        /**
         * @summary Verify Code Token
         * @description Verify the validity of a signup/login verification token.
         *
         * Args:
         *     payload (VerifyCodeTokenRequest): JWT token containing the verification code.
         *
         * Returns:
         *     dict: Response indicating if the token is valid.
         */
        getMutationKey(parameters: DeepReadonly<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostParameters> | void): ServiceOperationMutationKey<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostSchema, VerifyCodeTokenApiV1AuthVerifyCodeTokenPostParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Verify Code Token
         * @description Verify the validity of a signup/login verification token.
         *
         * Args:
         *     payload (VerifyCodeTokenRequest): JWT token containing the verification code.
         *
         * Returns:
         *     dict: Response indicating if the token is valid.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.verifyCodeTokenApiV1AuthVerifyCodeTokenPost.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.verifyCodeTokenApiV1AuthVerifyCodeTokenPost.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends VerifyCodeTokenApiV1AuthVerifyCodeTokenPostBody, TContext = unknown>(parameters: DeepReadonly<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostParameters>, options?: ServiceOperationUseMutationOptions<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostSchema, VerifyCodeTokenApiV1AuthVerifyCodeTokenPostData, VerifyCodeTokenApiV1AuthVerifyCodeTokenPostParameters, TVariables, OperationError<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostError>, TContext>): UseMutationResult<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostData, OperationError<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostError>, TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Verify Code Token
         * @description Verify the validity of a signup/login verification token.
         *
         * Args:
         *     payload (VerifyCodeTokenRequest): JWT token containing the verification code.
         *
         * Returns:
         *     dict: Response indicating if the token is valid.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.verifyCodeTokenApiV1AuthVerifyCodeTokenPost.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.verifyCodeTokenApiV1AuthVerifyCodeTokenPost.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostBody, VerifyCodeTokenApiV1AuthVerifyCodeTokenPostParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostSchema, VerifyCodeTokenApiV1AuthVerifyCodeTokenPostData, VerifyCodeTokenApiV1AuthVerifyCodeTokenPostParameters, TVariables, OperationError<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostError>, TContext>): UseMutationResult<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostData, OperationError<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostError>, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @summary Verify Code Token
         * @description Verify the validity of a signup/login verification token.
         *
         * Args:
         *     payload (VerifyCodeTokenRequest): JWT token containing the verification code.
         *
         * Returns:
         *     dict: Response indicating if the token is valid.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const verifyCodeTokenApiV1AuthVerifyCodeTokenPostTotal = qraft.apiService.verifyCodeTokenApiV1AuthVerifyCodeTokenPost.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const verifyCodeTokenApiV1AuthVerifyCodeTokenPostTotal = qraft.apiService.verifyCodeTokenApiV1AuthVerifyCodeTokenPost.useIsMutating({
         *     parameters: {}
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostBody, VerifyCodeTokenApiV1AuthVerifyCodeTokenPostData, VerifyCodeTokenApiV1AuthVerifyCodeTokenPostParameters, OperationError<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostError>, TContext> | MutationFiltersByMutationKey<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostSchema, VerifyCodeTokenApiV1AuthVerifyCodeTokenPostBody, VerifyCodeTokenApiV1AuthVerifyCodeTokenPostData, VerifyCodeTokenApiV1AuthVerifyCodeTokenPostParameters, OperationError<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostError>, TContext>): number;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @summary Verify Code Token
         * @description Verify the validity of a signup/login verification token.
         *
         * Args:
         *     payload (VerifyCodeTokenRequest): JWT token containing the verification code.
         *
         * Returns:
         *     dict: Response indicating if the token is valid.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const verifyCodeTokenApiV1AuthVerifyCodeTokenPostPendingMutationVariables = qraft.apiService.verifyCodeTokenApiV1AuthVerifyCodeTokenPost.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const verifyCodeTokenApiV1AuthVerifyCodeTokenPostMutationData = qraft.apiService.verifyCodeTokenApiV1AuthVerifyCodeTokenPost.useMutationState({
         *     filters: {
         *         parameters: {}
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostData, OperationError<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostError>, MutationVariables<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostBody, VerifyCodeTokenApiV1AuthVerifyCodeTokenPostParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostBody, VerifyCodeTokenApiV1AuthVerifyCodeTokenPostData, VerifyCodeTokenApiV1AuthVerifyCodeTokenPostParameters, OperationError<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostError>, TContext> | MutationFiltersByMutationKey<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostSchema, VerifyCodeTokenApiV1AuthVerifyCodeTokenPostBody, VerifyCodeTokenApiV1AuthVerifyCodeTokenPostData, VerifyCodeTokenApiV1AuthVerifyCodeTokenPostParameters, OperationError<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostError>, TContext>;
            select?: (mutation: Mutation<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostData, OperationError<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostError>, MutationVariables<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostBody, VerifyCodeTokenApiV1AuthVerifyCodeTokenPostParameters>, TContext>) => TResult;
        }): Array<TResult>;
        /**
         * @summary Verify Code Token
         * @description Verify the validity of a signup/login verification token.
         *
         * Args:
         *     payload (VerifyCodeTokenRequest): JWT token containing the verification code.
         *
         * Returns:
         *     dict: Response indicating if the token is valid.
         */
        isMutating<TContext>(filters?: MutationFiltersByParameters<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostBody, VerifyCodeTokenApiV1AuthVerifyCodeTokenPostData, VerifyCodeTokenApiV1AuthVerifyCodeTokenPostParameters, OperationError<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostError>, TContext> | MutationFiltersByMutationKey<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostSchema, VerifyCodeTokenApiV1AuthVerifyCodeTokenPostBody, VerifyCodeTokenApiV1AuthVerifyCodeTokenPostData, VerifyCodeTokenApiV1AuthVerifyCodeTokenPostParameters, OperationError<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostError>, TContext>): number;
        /**
         * Returns a `MutationCache` object that provides access to mutation cache operations
         * for the specific endpoint.
         *
         * @summary Verify Code Token
         * @description Verify the validity of a signup/login verification token.
         *
         * Args:
         *     payload (VerifyCodeTokenRequest): JWT token containing the verification code.
         *
         * Returns:
         *     dict: Response indicating if the token is valid.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/query-client/getMutationCache|`getMutationCache(...)` documentation}
         *
         * @example Find a mutation with specific parameters
         * ```ts
         * const mutationCache = qraft.apiService.verifyCodeTokenApiV1AuthVerifyCodeTokenPost.getMutationCache();
         * const mutation = mutationCache.find({
         *     parameters: {}
         * });
         * ```
         *
         * @example Find all mutations for the endpoint
         * ```ts
         * const mutationCache = qraft.apiService.verifyCodeTokenApiV1AuthVerifyCodeTokenPost.getMutationCache();
         * const mutations = mutationCache.findAll();
         * ```
         */
        getMutationCache(): Omit<MutationCache, "find" | "findAll"> & {
            find<TContext = unknown>(filters: MutationFiltersByParameters<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostBody, VerifyCodeTokenApiV1AuthVerifyCodeTokenPostData, VerifyCodeTokenApiV1AuthVerifyCodeTokenPostParameters, OperationError<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostError>, TContext> | MutationFiltersByMutationKey<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostSchema, VerifyCodeTokenApiV1AuthVerifyCodeTokenPostBody, VerifyCodeTokenApiV1AuthVerifyCodeTokenPostData, VerifyCodeTokenApiV1AuthVerifyCodeTokenPostParameters, OperationError<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostError>, TContext>): Mutation<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostData, VerifyCodeTokenApiV1AuthVerifyCodeTokenPostError, MutationVariables<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostBody, VerifyCodeTokenApiV1AuthVerifyCodeTokenPostParameters>, TContext> | undefined;
            findAll<TContext = unknown>(filters?: MutationFiltersByParameters<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostBody, VerifyCodeTokenApiV1AuthVerifyCodeTokenPostData, VerifyCodeTokenApiV1AuthVerifyCodeTokenPostParameters, OperationError<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostError>, TContext> | MutationFiltersByMutationKey<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostSchema, VerifyCodeTokenApiV1AuthVerifyCodeTokenPostBody, VerifyCodeTokenApiV1AuthVerifyCodeTokenPostData, VerifyCodeTokenApiV1AuthVerifyCodeTokenPostParameters, OperationError<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostError>, TContext>): Array<Mutation<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostData, VerifyCodeTokenApiV1AuthVerifyCodeTokenPostError, MutationVariables<VerifyCodeTokenApiV1AuthVerifyCodeTokenPostBody, VerifyCodeTokenApiV1AuthVerifyCodeTokenPostParameters>, TContext>>;
        };
        schema: VerifyCodeTokenApiV1AuthVerifyCodeTokenPostSchema;
        types: {
            parameters: VerifyCodeTokenApiV1AuthVerifyCodeTokenPostParameters;
            data: VerifyCodeTokenApiV1AuthVerifyCodeTokenPostData;
            error: VerifyCodeTokenApiV1AuthVerifyCodeTokenPostError;
            body: VerifyCodeTokenApiV1AuthVerifyCodeTokenPostBody;
        };
    };
    /**
     * @summary Read Current User
     * @description Retrieve authenticated user profile.
     *
     * Args:
     *     current_user (User): Authenticated user via dependency.
     *
     * Returns:
     *     UserBase: Current user information.
     */
    readCurrentUserApiV1UserMeGet: {
        /**
         * @summary Read Current User
         * @description Retrieve authenticated user profile.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     UserBase: Current user information.
         */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<ReadCurrentUserApiV1UserMeGetParameters, TMeta, TSignal>), client?: (schema: ReadCurrentUserApiV1UserMeGetSchema, options: {
            parameters: ReadCurrentUserApiV1UserMeGetParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<ReadCurrentUserApiV1UserMeGetData, ReadCurrentUserApiV1UserMeGetError>>): Promise<RequestFnResponse<ReadCurrentUserApiV1UserMeGetData, ReadCurrentUserApiV1UserMeGetError>>;
        /**
         * @summary Read Current User
         * @description Retrieve authenticated user profile.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     UserBase: Current user information.
         */
        getQueryKey(parameters: DeepReadonly<ReadCurrentUserApiV1UserMeGetParameters>): ServiceOperationQueryKey<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Read Current User
         * @description Retrieve authenticated user profile.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     UserBase: Current user information.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.apiService.readCurrentUserApiV1UserMeGet.useQuery({
         *     cookie: {
         *         access_token: accessToken
         *     }
         * })
         * ```
         */
        useQuery<TData = ReadCurrentUserApiV1UserMeGetData>(parameters: ServiceOperationQueryKey<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetParameters> | (DeepReadonly<ReadCurrentUserApiV1UserMeGetParameters>), options?: Omit<UndefinedInitialDataOptions<ReadCurrentUserApiV1UserMeGetData, ReadCurrentUserApiV1UserMeGetError, TData, ServiceOperationQueryKey<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetParameters>>, "queryKey">): UseQueryResult<TData, OperationError<ReadCurrentUserApiV1UserMeGetError>>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Read Current User
         * @description Retrieve authenticated user profile.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     UserBase: Current user information.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.apiService.readCurrentUserApiV1UserMeGet.useQuery({
         *     cookie: {
         *         access_token: accessToken
         *     }
         * })
         * ```
         */
        useQuery<TData = ReadCurrentUserApiV1UserMeGetData>(parameters: ServiceOperationQueryKey<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetParameters> | (DeepReadonly<ReadCurrentUserApiV1UserMeGetParameters>), options: Omit<DefinedInitialDataOptions<ReadCurrentUserApiV1UserMeGetData, ReadCurrentUserApiV1UserMeGetError, TData, ServiceOperationQueryKey<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetParameters>>, "queryKey">): DefinedUseQueryResult<TData, OperationError<ReadCurrentUserApiV1UserMeGetError>>;
        /**
         * @summary Read Current User
         * @description Retrieve authenticated user profile.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     UserBase: Current user information.
         */
        getInfiniteQueryKey(parameters: DeepReadonly<ReadCurrentUserApiV1UserMeGetParameters>): ServiceOperationInfiniteQueryKey<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @summary Read Current User
         * @description Retrieve authenticated user profile.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     UserBase: Current user information.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.readCurrentUserApiV1UserMeGet.useInfiniteQuery({
         *     cookie: {
         *         access_token: accessToken
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends ReadCurrentUserApiV1UserMeGetParameters, TQueryFnData = ReadCurrentUserApiV1UserMeGetData, TData = OperationInfiniteData<TQueryFnData, ReadCurrentUserApiV1UserMeGetParameters>>(parameters: ServiceOperationInfiniteQueryKey<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetParameters> | (DeepReadonly<ReadCurrentUserApiV1UserMeGetParameters>), options: Omit<UndefinedInitialDataInfiniteOptions<TQueryFnData, ReadCurrentUserApiV1UserMeGetError, TData, ServiceOperationInfiniteQueryKey<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>): UseInfiniteQueryResult<TData, OperationError<ReadCurrentUserApiV1UserMeGetError>>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @summary Read Current User
         * @description Retrieve authenticated user profile.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     UserBase: Current user information.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.readCurrentUserApiV1UserMeGet.useInfiniteQuery({
         *     cookie: {
         *         access_token: accessToken
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends ReadCurrentUserApiV1UserMeGetParameters, TQueryFnData = ReadCurrentUserApiV1UserMeGetData, TData = OperationInfiniteData<TQueryFnData, ReadCurrentUserApiV1UserMeGetParameters>>(parameters: ServiceOperationInfiniteQueryKey<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetParameters> | (DeepReadonly<ReadCurrentUserApiV1UserMeGetParameters>), options: Omit<DefinedInitialDataInfiniteOptions<TQueryFnData, ReadCurrentUserApiV1UserMeGetError, TData, ServiceOperationInfiniteQueryKey<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<ReadCurrentUserApiV1UserMeGetData, PartialParameters<DeepReadonly<TPageParam>>>): DefinedUseInfiniteQueryResult<TData, OperationError<ReadCurrentUserApiV1UserMeGetError>>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @summary Read Current User
         * @description Retrieve authenticated user profile.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     UserBase: Current user information.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const readCurrentUserApiV1UserMeGetTotal = qraft.apiService.readCurrentUserApiV1UserMeGet.useIsFetching()
         * ```
         * @example Checks the number of normal queries fetching with the specified parameters.
         * ```ts
         * const readCurrentUserApiV1UserMeGetByParametersTotal = qraft.apiService.readCurrentUserApiV1UserMeGet.useIsFetching({
         *     infinite: false,
         *     parameters: {
         *         cookie: {
         *             access_token: accessToken
         *         }
         *     }
         * })
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetData, TInfinite, ReadCurrentUserApiV1UserMeGetParameters, ReadCurrentUserApiV1UserMeGetError> | QueryFiltersByQueryKey<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetData, TInfinite, ReadCurrentUserApiV1UserMeGetParameters, ReadCurrentUserApiV1UserMeGetError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @summary Read Current User
         * @description Retrieve authenticated user profile.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     UserBase: Current user information.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const readCurrentUserApiV1UserMeGetResults = qraft.apiService.readCurrentUserApiV1UserMeGet.useQueries({
         *     queries: [
         *         {
         *             cookie: {
         *                 access_token: accessToken1
         *             }
         *         },
         *         {
         *             cookie: {
         *                 access_token: accessToken2
         *             }
         *         }
         *     ]
         * });
         * readCurrentUserApiV1UserMeGetResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const readCurrentUserApiV1UserMeGetCombinedResults = qraft.apiService.readCurrentUserApiV1UserMeGet.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             cookie: {
         *                 access_token: accessToken1
         *             }
         *         },
         *         {
         *             cookie: {
         *                 access_token: accessToken2
         *             }
         *         }
         *     ]
         * });
         * readCurrentUserApiV1UserMeGetCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetParameters, ReadCurrentUserApiV1UserMeGetData, ReadCurrentUserApiV1UserMeGetError>>, TCombinedResult = Array<UseQueryResult<ReadCurrentUserApiV1UserMeGetData, ReadCurrentUserApiV1UserMeGetError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<ReadCurrentUserApiV1UserMeGetData, ReadCurrentUserApiV1UserMeGetError>>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * Performs asynchronous data fetching with Suspense support.
         * Similar to useQuery but integrates with React Suspense for loading states.
         *
         * @summary Read Current User
         * @description Retrieve authenticated user profile.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     UserBase: Current user information.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
         * @example Suspense Query with parameters
         * ```ts
         * const data = qraft.apiService.readCurrentUserApiV1UserMeGet.useSuspenseQuery({
         *     cookie: {
         *         access_token: accessToken
         *     }
         * })
         * ```
         */
        useSuspenseQuery<TData = ReadCurrentUserApiV1UserMeGetData>(parameters: ServiceOperationQueryKey<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetParameters> | (DeepReadonly<ReadCurrentUserApiV1UserMeGetParameters>), options?: Omit<UseSuspenseQueryOptions<ReadCurrentUserApiV1UserMeGetData, ReadCurrentUserApiV1UserMeGetError, TData, ServiceOperationQueryKey<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetParameters>>, "queryKey">): UseSuspenseQueryResult<TData, OperationError<ReadCurrentUserApiV1UserMeGetError>>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @summary Read Current User
         * @description Retrieve authenticated user profile.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     UserBase: Current user information.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.readCurrentUserApiV1UserMeGet.useSuspenseInfiniteQuery({
         *     cookie: {
         *         access_token: accessToken
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends ReadCurrentUserApiV1UserMeGetParameters, TData = ReadCurrentUserApiV1UserMeGetData>(parameters: ServiceOperationInfiniteQueryKey<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetParameters> | (DeepReadonly<ReadCurrentUserApiV1UserMeGetParameters>), options: Omit<UseSuspenseInfiniteQueryOptions<ReadCurrentUserApiV1UserMeGetData, ReadCurrentUserApiV1UserMeGetError, OperationInfiniteData<TData, ReadCurrentUserApiV1UserMeGetParameters>, ServiceOperationInfiniteQueryKey<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<ReadCurrentUserApiV1UserMeGetData, PartialParameters<DeepReadonly<TPageParam>>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, ReadCurrentUserApiV1UserMeGetParameters>, OperationError<ReadCurrentUserApiV1UserMeGetError>>;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
         * Similar to useQueries but integrates with React Suspense for loading states.
         *
         * @summary Read Current User
         * @description Retrieve authenticated user profile.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     UserBase: Current user information.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
         * @example Basic usage with Suspense
         * ```ts
         * const readCurrentUserApiV1UserMeGetData = qraft.apiService.readCurrentUserApiV1UserMeGet.useSuspenseQueries({
         *     queries: [
         *         {
         *             cookie: {
         *                 access_token: accessToken1
         *             }
         *         },
         *         {
         *             cookie: {
         *                 access_token: accessToken2
         *             }
         *         }
         *     ]
         * });
         * readCurrentUserApiV1UserMeGetResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example With data transformation using combine
         * ```ts
         * const readCurrentUserApiV1UserMeGetCombinedData = qraft.apiService.readCurrentUserApiV1UserMeGet.useSuspenseQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             cookie: {
         *                 access_token: accessToken1
         *             }
         *         },
         *         {
         *             cookie: {
         *                 access_token: accessToken2
         *             }
         *         }
         *     ]
         * });
         * readCurrentUserApiV1UserMeGetCombinedData.forEach(data => console.log({ data }));
         * ```
         */
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetParameters, ReadCurrentUserApiV1UserMeGetData, ReadCurrentUserApiV1UserMeGetError>>, TCombinedResult = Array<UseSuspenseQueryResult<ReadCurrentUserApiV1UserMeGetData, ReadCurrentUserApiV1UserMeGetError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<ReadCurrentUserApiV1UserMeGetData, ReadCurrentUserApiV1UserMeGetError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * @summary Read Current User
         * @description Retrieve authenticated user profile.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     UserBase: Current user information.
         */
        fetchQuery(options: ServiceOperationFetchQueryOptions<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetData, ReadCurrentUserApiV1UserMeGetParameters, ReadCurrentUserApiV1UserMeGetError>): Promise<ReadCurrentUserApiV1UserMeGetData>;
        /**
         * @summary Read Current User
         * @description Retrieve authenticated user profile.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     UserBase: Current user information.
         */
        prefetchQuery(options: ServiceOperationFetchQueryOptions<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetData, ReadCurrentUserApiV1UserMeGetParameters, ReadCurrentUserApiV1UserMeGetError>): Promise<void>;
        /**
         * @summary Read Current User
         * @description Retrieve authenticated user profile.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     UserBase: Current user information.
         */
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetData, ReadCurrentUserApiV1UserMeGetParameters, ReadCurrentUserApiV1UserMeGetError>): Promise<ReadCurrentUserApiV1UserMeGetData>;
        /**
         * @summary Read Current User
         * @description Retrieve authenticated user profile.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     UserBase: Current user information.
         */
        fetchInfiniteQuery<TPageParam extends ReadCurrentUserApiV1UserMeGetParameters>(options: ServiceOperationFetchInfiniteQueryOptions<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetData, ReadCurrentUserApiV1UserMeGetParameters, DeepReadonly<TPageParam>, ReadCurrentUserApiV1UserMeGetError>): Promise<OperationInfiniteData<ReadCurrentUserApiV1UserMeGetData, ReadCurrentUserApiV1UserMeGetParameters>>;
        /**
         * @summary Read Current User
         * @description Retrieve authenticated user profile.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     UserBase: Current user information.
         */
        prefetchInfiniteQuery<TPageParam extends ReadCurrentUserApiV1UserMeGetParameters>(options: ServiceOperationFetchInfiniteQueryOptions<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetData, ReadCurrentUserApiV1UserMeGetParameters, DeepReadonly<TPageParam>, ReadCurrentUserApiV1UserMeGetError>): Promise<void>;
        /**
         * @summary Read Current User
         * @description Retrieve authenticated user profile.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     UserBase: Current user information.
         */
        ensureInfiniteQueryData<TPageParam extends ReadCurrentUserApiV1UserMeGetParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetData, ReadCurrentUserApiV1UserMeGetParameters, DeepReadonly<TPageParam>, ReadCurrentUserApiV1UserMeGetError>): Promise<OperationInfiniteData<ReadCurrentUserApiV1UserMeGetData, ReadCurrentUserApiV1UserMeGetParameters>>;
        /**
         * @summary Read Current User
         * @description Retrieve authenticated user profile.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     UserBase: Current user information.
         */
        getQueryData(parameters: ServiceOperationQueryKey<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetParameters> | (DeepReadonly<ReadCurrentUserApiV1UserMeGetParameters>)): ReadCurrentUserApiV1UserMeGetData | undefined;
        /**
         * @summary Read Current User
         * @description Retrieve authenticated user profile.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     UserBase: Current user information.
         */
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetParameters> | (DeepReadonly<ReadCurrentUserApiV1UserMeGetParameters>)): OperationInfiniteData<ReadCurrentUserApiV1UserMeGetData, ReadCurrentUserApiV1UserMeGetParameters> | undefined;
        /**
         * @summary Read Current User
         * @description Retrieve authenticated user profile.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     UserBase: Current user information.
         */
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetData, TInfinite, ReadCurrentUserApiV1UserMeGetParameters, ReadCurrentUserApiV1UserMeGetError> | QueryFiltersByQueryKey<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetData, TInfinite, ReadCurrentUserApiV1UserMeGetParameters, ReadCurrentUserApiV1UserMeGetError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetParameters>,
            data: NoInfer<OperationInfiniteData<ReadCurrentUserApiV1UserMeGetData, ReadCurrentUserApiV1UserMeGetParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetParameters>,
            data: ReadCurrentUserApiV1UserMeGetData | undefined
        ]>;
        /**
         * @summary Read Current User
         * @description Retrieve authenticated user profile.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     UserBase: Current user information.
         */
        getQueryState(parameters: ServiceOperationQueryKey<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetParameters> | (DeepReadonly<ReadCurrentUserApiV1UserMeGetParameters>)): QueryState<ReadCurrentUserApiV1UserMeGetData, ReadCurrentUserApiV1UserMeGetError> | undefined;
        /**
         * @summary Read Current User
         * @description Retrieve authenticated user profile.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     UserBase: Current user information.
         */
        getInfiniteQueryState(parameters: DeepReadonly<ReadCurrentUserApiV1UserMeGetParameters> | ServiceOperationInfiniteQueryKey<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetParameters>): QueryState<OperationInfiniteData<ReadCurrentUserApiV1UserMeGetData, ReadCurrentUserApiV1UserMeGetParameters>, ReadCurrentUserApiV1UserMeGetError> | undefined;
        /**
         * @summary Read Current User
         * @description Retrieve authenticated user profile.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     UserBase: Current user information.
         */
        setQueryData(parameters: (DeepReadonly<ReadCurrentUserApiV1UserMeGetParameters>) | ServiceOperationQueryKey<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetParameters>, updater: Updater<NoInfer<ReadCurrentUserApiV1UserMeGetData> | undefined, NoInfer<DeepReadonly<ReadCurrentUserApiV1UserMeGetData>> | undefined>, options?: SetDataOptions): ReadCurrentUserApiV1UserMeGetData | undefined;
        /**
         * @summary Read Current User
         * @description Retrieve authenticated user profile.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     UserBase: Current user information.
         */
        setInfiniteQueryData(parameters: (DeepReadonly<ReadCurrentUserApiV1UserMeGetParameters>) | ServiceOperationInfiniteQueryKey<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetParameters>, updater: Updater<NoInfer<OperationInfiniteData<ReadCurrentUserApiV1UserMeGetData, ReadCurrentUserApiV1UserMeGetParameters>> | undefined, NoInfer<DeepReadonly<OperationInfiniteData<ReadCurrentUserApiV1UserMeGetData, ReadCurrentUserApiV1UserMeGetParameters>>> | undefined>, options?: SetDataOptions): OperationInfiniteData<ReadCurrentUserApiV1UserMeGetData, ReadCurrentUserApiV1UserMeGetParameters> | undefined;
        /**
         * @summary Read Current User
         * @description Retrieve authenticated user profile.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     UserBase: Current user information.
         */
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetData, TInfinite, ReadCurrentUserApiV1UserMeGetParameters, ReadCurrentUserApiV1UserMeGetError> | QueryFiltersByQueryKey<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetData, TInfinite, ReadCurrentUserApiV1UserMeGetParameters, ReadCurrentUserApiV1UserMeGetError>, updater: Updater<NoInfer<ReadCurrentUserApiV1UserMeGetData> | undefined, NoInfer<ReadCurrentUserApiV1UserMeGetData> | undefined>, options?: SetDataOptions): Array<ReadCurrentUserApiV1UserMeGetData | undefined>;
        /**
         * @summary Read Current User
         * @description Retrieve authenticated user profile.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     UserBase: Current user information.
         */
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetData, TInfinite, ReadCurrentUserApiV1UserMeGetParameters, ReadCurrentUserApiV1UserMeGetError>, options?: InvalidateOptions): Promise<void>;
        /**
         * @summary Read Current User
         * @description Retrieve authenticated user profile.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     UserBase: Current user information.
         */
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetData, TInfinite, ReadCurrentUserApiV1UserMeGetParameters, ReadCurrentUserApiV1UserMeGetError> | QueryFiltersByQueryKey<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetData, TInfinite, ReadCurrentUserApiV1UserMeGetParameters, ReadCurrentUserApiV1UserMeGetError>, options?: RefetchOptions): Promise<void>;
        /**
         * @summary Read Current User
         * @description Retrieve authenticated user profile.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     UserBase: Current user information.
         */
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetData, TInfinite, ReadCurrentUserApiV1UserMeGetParameters, ReadCurrentUserApiV1UserMeGetError> | QueryFiltersByQueryKey<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetData, TInfinite, ReadCurrentUserApiV1UserMeGetParameters, ReadCurrentUserApiV1UserMeGetError>, options?: CancelOptions): Promise<void>;
        /**
         * @summary Read Current User
         * @description Retrieve authenticated user profile.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     UserBase: Current user information.
         */
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetData, TInfinite, ReadCurrentUserApiV1UserMeGetParameters, ReadCurrentUserApiV1UserMeGetError> | QueryFiltersByQueryKey<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetData, TInfinite, ReadCurrentUserApiV1UserMeGetParameters, ReadCurrentUserApiV1UserMeGetError>): void;
        /**
         * @summary Read Current User
         * @description Retrieve authenticated user profile.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     UserBase: Current user information.
         */
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetData, TInfinite, ReadCurrentUserApiV1UserMeGetParameters, ReadCurrentUserApiV1UserMeGetError> | QueryFiltersByQueryKey<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetData, TInfinite, ReadCurrentUserApiV1UserMeGetParameters, ReadCurrentUserApiV1UserMeGetError>, options?: ResetOptions): Promise<void>;
        /**
         * @summary Read Current User
         * @description Retrieve authenticated user profile.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     UserBase: Current user information.
         */
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetData, TInfinite, ReadCurrentUserApiV1UserMeGetParameters, ReadCurrentUserApiV1UserMeGetError> | QueryFiltersByQueryKey<ReadCurrentUserApiV1UserMeGetSchema, ReadCurrentUserApiV1UserMeGetData, TInfinite, ReadCurrentUserApiV1UserMeGetParameters, ReadCurrentUserApiV1UserMeGetError>): number;
        schema: ReadCurrentUserApiV1UserMeGetSchema;
        types: {
            parameters: ReadCurrentUserApiV1UserMeGetParameters;
            data: ReadCurrentUserApiV1UserMeGetData;
            error: ReadCurrentUserApiV1UserMeGetError;
        };
    };
    /**
     * @summary Get User Images
     * @description Retrieve user's generated images.
     *
     * Args:
     *     favourites (bool): If True, fetch only favourite images. Defaults to False.
     *     page (int): Page number for pagination. Defaults to 1.
     *     limit (int): Number of images per page. Defaults to 10.
     *     current_user (User): Authenticated user via dependency.
     *     db: Database session.
     */
    getUserImagesApiV1UserImagesGet: {
        /**
         * @summary Get User Images
         * @description Retrieve user's generated images.
         *
         * Args:
         *     favourites (bool): If True, fetch only favourite images. Defaults to False.
         *     page (int): Page number for pagination. Defaults to 1.
         *     limit (int): Number of images per page. Defaults to 10.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetUserImagesApiV1UserImagesGetParameters, TMeta, TSignal>), client?: (schema: GetUserImagesApiV1UserImagesGetSchema, options: {
            parameters: GetUserImagesApiV1UserImagesGetParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetUserImagesApiV1UserImagesGetData, GetUserImagesApiV1UserImagesGetError>>): Promise<RequestFnResponse<GetUserImagesApiV1UserImagesGetData, GetUserImagesApiV1UserImagesGetError>>;
        /**
         * @summary Get User Images
         * @description Retrieve user's generated images.
         *
         * Args:
         *     favourites (bool): If True, fetch only favourite images. Defaults to False.
         *     page (int): Page number for pagination. Defaults to 1.
         *     limit (int): Number of images per page. Defaults to 10.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         */
        getQueryKey(parameters: DeepReadonly<GetUserImagesApiV1UserImagesGetParameters>): ServiceOperationQueryKey<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get User Images
         * @description Retrieve user's generated images.
         *
         * Args:
         *     favourites (bool): If True, fetch only favourite images. Defaults to False.
         *     page (int): Page number for pagination. Defaults to 1.
         *     limit (int): Number of images per page. Defaults to 10.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.apiService.getUserImagesApiV1UserImagesGet.useQuery({
         *     query: {
         *         favourites: favourites
         *     },
         *     cookie: {
         *         access_token: accessToken
         *     }
         * })
         * ```
         */
        useQuery<TData = GetUserImagesApiV1UserImagesGetData>(parameters: ServiceOperationQueryKey<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetParameters> | (DeepReadonly<GetUserImagesApiV1UserImagesGetParameters>), options?: Omit<UndefinedInitialDataOptions<GetUserImagesApiV1UserImagesGetData, GetUserImagesApiV1UserImagesGetError, TData, ServiceOperationQueryKey<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetParameters>>, "queryKey">): UseQueryResult<TData, OperationError<GetUserImagesApiV1UserImagesGetError>>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get User Images
         * @description Retrieve user's generated images.
         *
         * Args:
         *     favourites (bool): If True, fetch only favourite images. Defaults to False.
         *     page (int): Page number for pagination. Defaults to 1.
         *     limit (int): Number of images per page. Defaults to 10.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.apiService.getUserImagesApiV1UserImagesGet.useQuery({
         *     query: {
         *         favourites: favourites
         *     },
         *     cookie: {
         *         access_token: accessToken
         *     }
         * })
         * ```
         */
        useQuery<TData = GetUserImagesApiV1UserImagesGetData>(parameters: ServiceOperationQueryKey<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetParameters> | (DeepReadonly<GetUserImagesApiV1UserImagesGetParameters>), options: Omit<DefinedInitialDataOptions<GetUserImagesApiV1UserImagesGetData, GetUserImagesApiV1UserImagesGetError, TData, ServiceOperationQueryKey<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetParameters>>, "queryKey">): DefinedUseQueryResult<TData, OperationError<GetUserImagesApiV1UserImagesGetError>>;
        /**
         * @summary Get User Images
         * @description Retrieve user's generated images.
         *
         * Args:
         *     favourites (bool): If True, fetch only favourite images. Defaults to False.
         *     page (int): Page number for pagination. Defaults to 1.
         *     limit (int): Number of images per page. Defaults to 10.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         */
        getInfiniteQueryKey(parameters: DeepReadonly<GetUserImagesApiV1UserImagesGetParameters>): ServiceOperationInfiniteQueryKey<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @summary Get User Images
         * @description Retrieve user's generated images.
         *
         * Args:
         *     favourites (bool): If True, fetch only favourite images. Defaults to False.
         *     page (int): Page number for pagination. Defaults to 1.
         *     limit (int): Number of images per page. Defaults to 10.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.getUserImagesApiV1UserImagesGet.useInfiniteQuery({
         *     cookie: {
         *         access_token: accessToken
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             favourites: initialFavourites
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetUserImagesApiV1UserImagesGetParameters, TQueryFnData = GetUserImagesApiV1UserImagesGetData, TData = OperationInfiniteData<TQueryFnData, GetUserImagesApiV1UserImagesGetParameters>>(parameters: ServiceOperationInfiniteQueryKey<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetParameters> | (DeepReadonly<GetUserImagesApiV1UserImagesGetParameters>), options: Omit<UndefinedInitialDataInfiniteOptions<TQueryFnData, GetUserImagesApiV1UserImagesGetError, TData, ServiceOperationInfiniteQueryKey<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>): UseInfiniteQueryResult<TData, OperationError<GetUserImagesApiV1UserImagesGetError>>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @summary Get User Images
         * @description Retrieve user's generated images.
         *
         * Args:
         *     favourites (bool): If True, fetch only favourite images. Defaults to False.
         *     page (int): Page number for pagination. Defaults to 1.
         *     limit (int): Number of images per page. Defaults to 10.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.getUserImagesApiV1UserImagesGet.useInfiniteQuery({
         *     cookie: {
         *         access_token: accessToken
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             favourites: initialFavourites
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetUserImagesApiV1UserImagesGetParameters, TQueryFnData = GetUserImagesApiV1UserImagesGetData, TData = OperationInfiniteData<TQueryFnData, GetUserImagesApiV1UserImagesGetParameters>>(parameters: ServiceOperationInfiniteQueryKey<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetParameters> | (DeepReadonly<GetUserImagesApiV1UserImagesGetParameters>), options: Omit<DefinedInitialDataInfiniteOptions<TQueryFnData, GetUserImagesApiV1UserImagesGetError, TData, ServiceOperationInfiniteQueryKey<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetUserImagesApiV1UserImagesGetData, PartialParameters<DeepReadonly<TPageParam>>>): DefinedUseInfiniteQueryResult<TData, OperationError<GetUserImagesApiV1UserImagesGetError>>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @summary Get User Images
         * @description Retrieve user's generated images.
         *
         * Args:
         *     favourites (bool): If True, fetch only favourite images. Defaults to False.
         *     page (int): Page number for pagination. Defaults to 1.
         *     limit (int): Number of images per page. Defaults to 10.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getUserImagesApiV1UserImagesGetTotal = qraft.apiService.getUserImagesApiV1UserImagesGet.useIsFetching()
         * ```
         * @example Checks the number of normal queries fetching with the specified parameters.
         * ```ts
         * const getUserImagesApiV1UserImagesGetByParametersTotal = qraft.apiService.getUserImagesApiV1UserImagesGet.useIsFetching({
         *     infinite: false,
         *     parameters: {
         *         query: {
         *             favourites: favourites
         *         },
         *         cookie: {
         *             access_token: accessToken
         *         }
         *     }
         * })
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetData, TInfinite, GetUserImagesApiV1UserImagesGetParameters, GetUserImagesApiV1UserImagesGetError> | QueryFiltersByQueryKey<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetData, TInfinite, GetUserImagesApiV1UserImagesGetParameters, GetUserImagesApiV1UserImagesGetError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @summary Get User Images
         * @description Retrieve user's generated images.
         *
         * Args:
         *     favourites (bool): If True, fetch only favourite images. Defaults to False.
         *     page (int): Page number for pagination. Defaults to 1.
         *     limit (int): Number of images per page. Defaults to 10.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getUserImagesApiV1UserImagesGetResults = qraft.apiService.getUserImagesApiV1UserImagesGet.useQueries({
         *     queries: [
         *         {
         *             query: {
         *                 favourites: favourites1
         *             },
         *             cookie: {
         *                 access_token: accessToken1
         *             }
         *         },
         *         {
         *             query: {
         *                 favourites: favourites2
         *             },
         *             cookie: {
         *                 access_token: accessToken2
         *             }
         *         }
         *     ]
         * });
         * getUserImagesApiV1UserImagesGetResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getUserImagesApiV1UserImagesGetCombinedResults = qraft.apiService.getUserImagesApiV1UserImagesGet.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             query: {
         *                 favourites: favourites1
         *             },
         *             cookie: {
         *                 access_token: accessToken1
         *             }
         *         },
         *         {
         *             query: {
         *                 favourites: favourites2
         *             },
         *             cookie: {
         *                 access_token: accessToken2
         *             }
         *         }
         *     ]
         * });
         * getUserImagesApiV1UserImagesGetCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetParameters, GetUserImagesApiV1UserImagesGetData, GetUserImagesApiV1UserImagesGetError>>, TCombinedResult = Array<UseQueryResult<GetUserImagesApiV1UserImagesGetData, GetUserImagesApiV1UserImagesGetError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetUserImagesApiV1UserImagesGetData, GetUserImagesApiV1UserImagesGetError>>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * Performs asynchronous data fetching with Suspense support.
         * Similar to useQuery but integrates with React Suspense for loading states.
         *
         * @summary Get User Images
         * @description Retrieve user's generated images.
         *
         * Args:
         *     favourites (bool): If True, fetch only favourite images. Defaults to False.
         *     page (int): Page number for pagination. Defaults to 1.
         *     limit (int): Number of images per page. Defaults to 10.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
         * @example Suspense Query with parameters
         * ```ts
         * const data = qraft.apiService.getUserImagesApiV1UserImagesGet.useSuspenseQuery({
         *     query: {
         *         favourites: favourites
         *     },
         *     cookie: {
         *         access_token: accessToken
         *     }
         * })
         * ```
         */
        useSuspenseQuery<TData = GetUserImagesApiV1UserImagesGetData>(parameters: ServiceOperationQueryKey<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetParameters> | (DeepReadonly<GetUserImagesApiV1UserImagesGetParameters>), options?: Omit<UseSuspenseQueryOptions<GetUserImagesApiV1UserImagesGetData, GetUserImagesApiV1UserImagesGetError, TData, ServiceOperationQueryKey<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetParameters>>, "queryKey">): UseSuspenseQueryResult<TData, OperationError<GetUserImagesApiV1UserImagesGetError>>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @summary Get User Images
         * @description Retrieve user's generated images.
         *
         * Args:
         *     favourites (bool): If True, fetch only favourite images. Defaults to False.
         *     page (int): Page number for pagination. Defaults to 1.
         *     limit (int): Number of images per page. Defaults to 10.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.getUserImagesApiV1UserImagesGet.useSuspenseInfiniteQuery({
         *     cookie: {
         *         access_token: accessToken
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             favourites: initialFavourites
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetUserImagesApiV1UserImagesGetParameters, TData = GetUserImagesApiV1UserImagesGetData>(parameters: ServiceOperationInfiniteQueryKey<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetParameters> | (DeepReadonly<GetUserImagesApiV1UserImagesGetParameters>), options: Omit<UseSuspenseInfiniteQueryOptions<GetUserImagesApiV1UserImagesGetData, GetUserImagesApiV1UserImagesGetError, OperationInfiniteData<TData, GetUserImagesApiV1UserImagesGetParameters>, ServiceOperationInfiniteQueryKey<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetUserImagesApiV1UserImagesGetData, PartialParameters<DeepReadonly<TPageParam>>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetUserImagesApiV1UserImagesGetParameters>, OperationError<GetUserImagesApiV1UserImagesGetError>>;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
         * Similar to useQueries but integrates with React Suspense for loading states.
         *
         * @summary Get User Images
         * @description Retrieve user's generated images.
         *
         * Args:
         *     favourites (bool): If True, fetch only favourite images. Defaults to False.
         *     page (int): Page number for pagination. Defaults to 1.
         *     limit (int): Number of images per page. Defaults to 10.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
         * @example Basic usage with Suspense
         * ```ts
         * const getUserImagesApiV1UserImagesGetData = qraft.apiService.getUserImagesApiV1UserImagesGet.useSuspenseQueries({
         *     queries: [
         *         {
         *             query: {
         *                 favourites: favourites1
         *             },
         *             cookie: {
         *                 access_token: accessToken1
         *             }
         *         },
         *         {
         *             query: {
         *                 favourites: favourites2
         *             },
         *             cookie: {
         *                 access_token: accessToken2
         *             }
         *         }
         *     ]
         * });
         * getUserImagesApiV1UserImagesGetResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example With data transformation using combine
         * ```ts
         * const getUserImagesApiV1UserImagesGetCombinedData = qraft.apiService.getUserImagesApiV1UserImagesGet.useSuspenseQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             query: {
         *                 favourites: favourites1
         *             },
         *             cookie: {
         *                 access_token: accessToken1
         *             }
         *         },
         *         {
         *             query: {
         *                 favourites: favourites2
         *             },
         *             cookie: {
         *                 access_token: accessToken2
         *             }
         *         }
         *     ]
         * });
         * getUserImagesApiV1UserImagesGetCombinedData.forEach(data => console.log({ data }));
         * ```
         */
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetParameters, GetUserImagesApiV1UserImagesGetData, GetUserImagesApiV1UserImagesGetError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetUserImagesApiV1UserImagesGetData, GetUserImagesApiV1UserImagesGetError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetUserImagesApiV1UserImagesGetData, GetUserImagesApiV1UserImagesGetError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * @summary Get User Images
         * @description Retrieve user's generated images.
         *
         * Args:
         *     favourites (bool): If True, fetch only favourite images. Defaults to False.
         *     page (int): Page number for pagination. Defaults to 1.
         *     limit (int): Number of images per page. Defaults to 10.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         */
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetData, GetUserImagesApiV1UserImagesGetParameters, GetUserImagesApiV1UserImagesGetError>): Promise<GetUserImagesApiV1UserImagesGetData>;
        /**
         * @summary Get User Images
         * @description Retrieve user's generated images.
         *
         * Args:
         *     favourites (bool): If True, fetch only favourite images. Defaults to False.
         *     page (int): Page number for pagination. Defaults to 1.
         *     limit (int): Number of images per page. Defaults to 10.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         */
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetData, GetUserImagesApiV1UserImagesGetParameters, GetUserImagesApiV1UserImagesGetError>): Promise<void>;
        /**
         * @summary Get User Images
         * @description Retrieve user's generated images.
         *
         * Args:
         *     favourites (bool): If True, fetch only favourite images. Defaults to False.
         *     page (int): Page number for pagination. Defaults to 1.
         *     limit (int): Number of images per page. Defaults to 10.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         */
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetData, GetUserImagesApiV1UserImagesGetParameters, GetUserImagesApiV1UserImagesGetError>): Promise<GetUserImagesApiV1UserImagesGetData>;
        /**
         * @summary Get User Images
         * @description Retrieve user's generated images.
         *
         * Args:
         *     favourites (bool): If True, fetch only favourite images. Defaults to False.
         *     page (int): Page number for pagination. Defaults to 1.
         *     limit (int): Number of images per page. Defaults to 10.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         */
        fetchInfiniteQuery<TPageParam extends GetUserImagesApiV1UserImagesGetParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetData, GetUserImagesApiV1UserImagesGetParameters, DeepReadonly<TPageParam>, GetUserImagesApiV1UserImagesGetError>): Promise<OperationInfiniteData<GetUserImagesApiV1UserImagesGetData, GetUserImagesApiV1UserImagesGetParameters>>;
        /**
         * @summary Get User Images
         * @description Retrieve user's generated images.
         *
         * Args:
         *     favourites (bool): If True, fetch only favourite images. Defaults to False.
         *     page (int): Page number for pagination. Defaults to 1.
         *     limit (int): Number of images per page. Defaults to 10.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         */
        prefetchInfiniteQuery<TPageParam extends GetUserImagesApiV1UserImagesGetParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetData, GetUserImagesApiV1UserImagesGetParameters, DeepReadonly<TPageParam>, GetUserImagesApiV1UserImagesGetError>): Promise<void>;
        /**
         * @summary Get User Images
         * @description Retrieve user's generated images.
         *
         * Args:
         *     favourites (bool): If True, fetch only favourite images. Defaults to False.
         *     page (int): Page number for pagination. Defaults to 1.
         *     limit (int): Number of images per page. Defaults to 10.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         */
        ensureInfiniteQueryData<TPageParam extends GetUserImagesApiV1UserImagesGetParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetData, GetUserImagesApiV1UserImagesGetParameters, DeepReadonly<TPageParam>, GetUserImagesApiV1UserImagesGetError>): Promise<OperationInfiniteData<GetUserImagesApiV1UserImagesGetData, GetUserImagesApiV1UserImagesGetParameters>>;
        /**
         * @summary Get User Images
         * @description Retrieve user's generated images.
         *
         * Args:
         *     favourites (bool): If True, fetch only favourite images. Defaults to False.
         *     page (int): Page number for pagination. Defaults to 1.
         *     limit (int): Number of images per page. Defaults to 10.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         */
        getQueryData(parameters: ServiceOperationQueryKey<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetParameters> | (DeepReadonly<GetUserImagesApiV1UserImagesGetParameters>)): GetUserImagesApiV1UserImagesGetData | undefined;
        /**
         * @summary Get User Images
         * @description Retrieve user's generated images.
         *
         * Args:
         *     favourites (bool): If True, fetch only favourite images. Defaults to False.
         *     page (int): Page number for pagination. Defaults to 1.
         *     limit (int): Number of images per page. Defaults to 10.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         */
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetParameters> | (DeepReadonly<GetUserImagesApiV1UserImagesGetParameters>)): OperationInfiniteData<GetUserImagesApiV1UserImagesGetData, GetUserImagesApiV1UserImagesGetParameters> | undefined;
        /**
         * @summary Get User Images
         * @description Retrieve user's generated images.
         *
         * Args:
         *     favourites (bool): If True, fetch only favourite images. Defaults to False.
         *     page (int): Page number for pagination. Defaults to 1.
         *     limit (int): Number of images per page. Defaults to 10.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         */
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetData, TInfinite, GetUserImagesApiV1UserImagesGetParameters, GetUserImagesApiV1UserImagesGetError> | QueryFiltersByQueryKey<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetData, TInfinite, GetUserImagesApiV1UserImagesGetParameters, GetUserImagesApiV1UserImagesGetError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetParameters>,
            data: NoInfer<OperationInfiniteData<GetUserImagesApiV1UserImagesGetData, GetUserImagesApiV1UserImagesGetParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetParameters>,
            data: GetUserImagesApiV1UserImagesGetData | undefined
        ]>;
        /**
         * @summary Get User Images
         * @description Retrieve user's generated images.
         *
         * Args:
         *     favourites (bool): If True, fetch only favourite images. Defaults to False.
         *     page (int): Page number for pagination. Defaults to 1.
         *     limit (int): Number of images per page. Defaults to 10.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         */
        getQueryState(parameters: ServiceOperationQueryKey<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetParameters> | (DeepReadonly<GetUserImagesApiV1UserImagesGetParameters>)): QueryState<GetUserImagesApiV1UserImagesGetData, GetUserImagesApiV1UserImagesGetError> | undefined;
        /**
         * @summary Get User Images
         * @description Retrieve user's generated images.
         *
         * Args:
         *     favourites (bool): If True, fetch only favourite images. Defaults to False.
         *     page (int): Page number for pagination. Defaults to 1.
         *     limit (int): Number of images per page. Defaults to 10.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         */
        getInfiniteQueryState(parameters: DeepReadonly<GetUserImagesApiV1UserImagesGetParameters> | ServiceOperationInfiniteQueryKey<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetParameters>): QueryState<OperationInfiniteData<GetUserImagesApiV1UserImagesGetData, GetUserImagesApiV1UserImagesGetParameters>, GetUserImagesApiV1UserImagesGetError> | undefined;
        /**
         * @summary Get User Images
         * @description Retrieve user's generated images.
         *
         * Args:
         *     favourites (bool): If True, fetch only favourite images. Defaults to False.
         *     page (int): Page number for pagination. Defaults to 1.
         *     limit (int): Number of images per page. Defaults to 10.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         */
        setQueryData(parameters: (DeepReadonly<GetUserImagesApiV1UserImagesGetParameters>) | ServiceOperationQueryKey<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetParameters>, updater: Updater<NoInfer<GetUserImagesApiV1UserImagesGetData> | undefined, NoInfer<DeepReadonly<GetUserImagesApiV1UserImagesGetData>> | undefined>, options?: SetDataOptions): GetUserImagesApiV1UserImagesGetData | undefined;
        /**
         * @summary Get User Images
         * @description Retrieve user's generated images.
         *
         * Args:
         *     favourites (bool): If True, fetch only favourite images. Defaults to False.
         *     page (int): Page number for pagination. Defaults to 1.
         *     limit (int): Number of images per page. Defaults to 10.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         */
        setInfiniteQueryData(parameters: (DeepReadonly<GetUserImagesApiV1UserImagesGetParameters>) | ServiceOperationInfiniteQueryKey<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetUserImagesApiV1UserImagesGetData, GetUserImagesApiV1UserImagesGetParameters>> | undefined, NoInfer<DeepReadonly<OperationInfiniteData<GetUserImagesApiV1UserImagesGetData, GetUserImagesApiV1UserImagesGetParameters>>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetUserImagesApiV1UserImagesGetData, GetUserImagesApiV1UserImagesGetParameters> | undefined;
        /**
         * @summary Get User Images
         * @description Retrieve user's generated images.
         *
         * Args:
         *     favourites (bool): If True, fetch only favourite images. Defaults to False.
         *     page (int): Page number for pagination. Defaults to 1.
         *     limit (int): Number of images per page. Defaults to 10.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         */
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetData, TInfinite, GetUserImagesApiV1UserImagesGetParameters, GetUserImagesApiV1UserImagesGetError> | QueryFiltersByQueryKey<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetData, TInfinite, GetUserImagesApiV1UserImagesGetParameters, GetUserImagesApiV1UserImagesGetError>, updater: Updater<NoInfer<GetUserImagesApiV1UserImagesGetData> | undefined, NoInfer<GetUserImagesApiV1UserImagesGetData> | undefined>, options?: SetDataOptions): Array<GetUserImagesApiV1UserImagesGetData | undefined>;
        /**
         * @summary Get User Images
         * @description Retrieve user's generated images.
         *
         * Args:
         *     favourites (bool): If True, fetch only favourite images. Defaults to False.
         *     page (int): Page number for pagination. Defaults to 1.
         *     limit (int): Number of images per page. Defaults to 10.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         */
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetData, TInfinite, GetUserImagesApiV1UserImagesGetParameters, GetUserImagesApiV1UserImagesGetError>, options?: InvalidateOptions): Promise<void>;
        /**
         * @summary Get User Images
         * @description Retrieve user's generated images.
         *
         * Args:
         *     favourites (bool): If True, fetch only favourite images. Defaults to False.
         *     page (int): Page number for pagination. Defaults to 1.
         *     limit (int): Number of images per page. Defaults to 10.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         */
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetData, TInfinite, GetUserImagesApiV1UserImagesGetParameters, GetUserImagesApiV1UserImagesGetError> | QueryFiltersByQueryKey<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetData, TInfinite, GetUserImagesApiV1UserImagesGetParameters, GetUserImagesApiV1UserImagesGetError>, options?: RefetchOptions): Promise<void>;
        /**
         * @summary Get User Images
         * @description Retrieve user's generated images.
         *
         * Args:
         *     favourites (bool): If True, fetch only favourite images. Defaults to False.
         *     page (int): Page number for pagination. Defaults to 1.
         *     limit (int): Number of images per page. Defaults to 10.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         */
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetData, TInfinite, GetUserImagesApiV1UserImagesGetParameters, GetUserImagesApiV1UserImagesGetError> | QueryFiltersByQueryKey<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetData, TInfinite, GetUserImagesApiV1UserImagesGetParameters, GetUserImagesApiV1UserImagesGetError>, options?: CancelOptions): Promise<void>;
        /**
         * @summary Get User Images
         * @description Retrieve user's generated images.
         *
         * Args:
         *     favourites (bool): If True, fetch only favourite images. Defaults to False.
         *     page (int): Page number for pagination. Defaults to 1.
         *     limit (int): Number of images per page. Defaults to 10.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         */
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetData, TInfinite, GetUserImagesApiV1UserImagesGetParameters, GetUserImagesApiV1UserImagesGetError> | QueryFiltersByQueryKey<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetData, TInfinite, GetUserImagesApiV1UserImagesGetParameters, GetUserImagesApiV1UserImagesGetError>): void;
        /**
         * @summary Get User Images
         * @description Retrieve user's generated images.
         *
         * Args:
         *     favourites (bool): If True, fetch only favourite images. Defaults to False.
         *     page (int): Page number for pagination. Defaults to 1.
         *     limit (int): Number of images per page. Defaults to 10.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         */
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetData, TInfinite, GetUserImagesApiV1UserImagesGetParameters, GetUserImagesApiV1UserImagesGetError> | QueryFiltersByQueryKey<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetData, TInfinite, GetUserImagesApiV1UserImagesGetParameters, GetUserImagesApiV1UserImagesGetError>, options?: ResetOptions): Promise<void>;
        /**
         * @summary Get User Images
         * @description Retrieve user's generated images.
         *
         * Args:
         *     favourites (bool): If True, fetch only favourite images. Defaults to False.
         *     page (int): Page number for pagination. Defaults to 1.
         *     limit (int): Number of images per page. Defaults to 10.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         */
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetData, TInfinite, GetUserImagesApiV1UserImagesGetParameters, GetUserImagesApiV1UserImagesGetError> | QueryFiltersByQueryKey<GetUserImagesApiV1UserImagesGetSchema, GetUserImagesApiV1UserImagesGetData, TInfinite, GetUserImagesApiV1UserImagesGetParameters, GetUserImagesApiV1UserImagesGetError>): number;
        schema: GetUserImagesApiV1UserImagesGetSchema;
        types: {
            parameters: GetUserImagesApiV1UserImagesGetParameters;
            data: GetUserImagesApiV1UserImagesGetData;
            error: GetUserImagesApiV1UserImagesGetError;
        };
    };
    /**
     * @summary Get User Uploads
     * @description Retrieve URLs of user's uploaded images.
     *
     * Args:
     *     current_user (User): Authenticated user via dependency.
     *     db: Database session.
     *
     * Returns:
     *     List[HttpUrl]: List of URLs of uploaded images.
     */
    getUserUploadsApiV1UserUploadsGet: {
        /**
         * @summary Get User Uploads
         * @description Retrieve URLs of user's uploaded images.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[HttpUrl]: List of URLs of uploaded images.
         */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetUserUploadsApiV1UserUploadsGetParameters, TMeta, TSignal>), client?: (schema: GetUserUploadsApiV1UserUploadsGetSchema, options: {
            parameters: GetUserUploadsApiV1UserUploadsGetParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetUserUploadsApiV1UserUploadsGetData, GetUserUploadsApiV1UserUploadsGetError>>): Promise<RequestFnResponse<GetUserUploadsApiV1UserUploadsGetData, GetUserUploadsApiV1UserUploadsGetError>>;
        /**
         * @summary Get User Uploads
         * @description Retrieve URLs of user's uploaded images.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[HttpUrl]: List of URLs of uploaded images.
         */
        getQueryKey(parameters: DeepReadonly<GetUserUploadsApiV1UserUploadsGetParameters>): ServiceOperationQueryKey<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get User Uploads
         * @description Retrieve URLs of user's uploaded images.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[HttpUrl]: List of URLs of uploaded images.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.apiService.getUserUploadsApiV1UserUploadsGet.useQuery({
         *     cookie: {
         *         access_token: accessToken
         *     }
         * })
         * ```
         */
        useQuery<TData = GetUserUploadsApiV1UserUploadsGetData>(parameters: ServiceOperationQueryKey<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetParameters> | (DeepReadonly<GetUserUploadsApiV1UserUploadsGetParameters>), options?: Omit<UndefinedInitialDataOptions<GetUserUploadsApiV1UserUploadsGetData, GetUserUploadsApiV1UserUploadsGetError, TData, ServiceOperationQueryKey<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetParameters>>, "queryKey">): UseQueryResult<TData, OperationError<GetUserUploadsApiV1UserUploadsGetError>>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get User Uploads
         * @description Retrieve URLs of user's uploaded images.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[HttpUrl]: List of URLs of uploaded images.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.apiService.getUserUploadsApiV1UserUploadsGet.useQuery({
         *     cookie: {
         *         access_token: accessToken
         *     }
         * })
         * ```
         */
        useQuery<TData = GetUserUploadsApiV1UserUploadsGetData>(parameters: ServiceOperationQueryKey<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetParameters> | (DeepReadonly<GetUserUploadsApiV1UserUploadsGetParameters>), options: Omit<DefinedInitialDataOptions<GetUserUploadsApiV1UserUploadsGetData, GetUserUploadsApiV1UserUploadsGetError, TData, ServiceOperationQueryKey<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetParameters>>, "queryKey">): DefinedUseQueryResult<TData, OperationError<GetUserUploadsApiV1UserUploadsGetError>>;
        /**
         * @summary Get User Uploads
         * @description Retrieve URLs of user's uploaded images.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[HttpUrl]: List of URLs of uploaded images.
         */
        getInfiniteQueryKey(parameters: DeepReadonly<GetUserUploadsApiV1UserUploadsGetParameters>): ServiceOperationInfiniteQueryKey<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @summary Get User Uploads
         * @description Retrieve URLs of user's uploaded images.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[HttpUrl]: List of URLs of uploaded images.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.getUserUploadsApiV1UserUploadsGet.useInfiniteQuery({
         *     cookie: {
         *         access_token: accessToken
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetUserUploadsApiV1UserUploadsGetParameters, TQueryFnData = GetUserUploadsApiV1UserUploadsGetData, TData = OperationInfiniteData<TQueryFnData, GetUserUploadsApiV1UserUploadsGetParameters>>(parameters: ServiceOperationInfiniteQueryKey<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetParameters> | (DeepReadonly<GetUserUploadsApiV1UserUploadsGetParameters>), options: Omit<UndefinedInitialDataInfiniteOptions<TQueryFnData, GetUserUploadsApiV1UserUploadsGetError, TData, ServiceOperationInfiniteQueryKey<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>): UseInfiniteQueryResult<TData, OperationError<GetUserUploadsApiV1UserUploadsGetError>>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @summary Get User Uploads
         * @description Retrieve URLs of user's uploaded images.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[HttpUrl]: List of URLs of uploaded images.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.getUserUploadsApiV1UserUploadsGet.useInfiniteQuery({
         *     cookie: {
         *         access_token: accessToken
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetUserUploadsApiV1UserUploadsGetParameters, TQueryFnData = GetUserUploadsApiV1UserUploadsGetData, TData = OperationInfiniteData<TQueryFnData, GetUserUploadsApiV1UserUploadsGetParameters>>(parameters: ServiceOperationInfiniteQueryKey<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetParameters> | (DeepReadonly<GetUserUploadsApiV1UserUploadsGetParameters>), options: Omit<DefinedInitialDataInfiniteOptions<TQueryFnData, GetUserUploadsApiV1UserUploadsGetError, TData, ServiceOperationInfiniteQueryKey<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetUserUploadsApiV1UserUploadsGetData, PartialParameters<DeepReadonly<TPageParam>>>): DefinedUseInfiniteQueryResult<TData, OperationError<GetUserUploadsApiV1UserUploadsGetError>>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @summary Get User Uploads
         * @description Retrieve URLs of user's uploaded images.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[HttpUrl]: List of URLs of uploaded images.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getUserUploadsApiV1UserUploadsGetTotal = qraft.apiService.getUserUploadsApiV1UserUploadsGet.useIsFetching()
         * ```
         * @example Checks the number of normal queries fetching with the specified parameters.
         * ```ts
         * const getUserUploadsApiV1UserUploadsGetByParametersTotal = qraft.apiService.getUserUploadsApiV1UserUploadsGet.useIsFetching({
         *     infinite: false,
         *     parameters: {
         *         cookie: {
         *             access_token: accessToken
         *         }
         *     }
         * })
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetData, TInfinite, GetUserUploadsApiV1UserUploadsGetParameters, GetUserUploadsApiV1UserUploadsGetError> | QueryFiltersByQueryKey<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetData, TInfinite, GetUserUploadsApiV1UserUploadsGetParameters, GetUserUploadsApiV1UserUploadsGetError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @summary Get User Uploads
         * @description Retrieve URLs of user's uploaded images.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[HttpUrl]: List of URLs of uploaded images.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getUserUploadsApiV1UserUploadsGetResults = qraft.apiService.getUserUploadsApiV1UserUploadsGet.useQueries({
         *     queries: [
         *         {
         *             cookie: {
         *                 access_token: accessToken1
         *             }
         *         },
         *         {
         *             cookie: {
         *                 access_token: accessToken2
         *             }
         *         }
         *     ]
         * });
         * getUserUploadsApiV1UserUploadsGetResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getUserUploadsApiV1UserUploadsGetCombinedResults = qraft.apiService.getUserUploadsApiV1UserUploadsGet.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             cookie: {
         *                 access_token: accessToken1
         *             }
         *         },
         *         {
         *             cookie: {
         *                 access_token: accessToken2
         *             }
         *         }
         *     ]
         * });
         * getUserUploadsApiV1UserUploadsGetCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetParameters, GetUserUploadsApiV1UserUploadsGetData, GetUserUploadsApiV1UserUploadsGetError>>, TCombinedResult = Array<UseQueryResult<GetUserUploadsApiV1UserUploadsGetData, GetUserUploadsApiV1UserUploadsGetError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetUserUploadsApiV1UserUploadsGetData, GetUserUploadsApiV1UserUploadsGetError>>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * Performs asynchronous data fetching with Suspense support.
         * Similar to useQuery but integrates with React Suspense for loading states.
         *
         * @summary Get User Uploads
         * @description Retrieve URLs of user's uploaded images.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[HttpUrl]: List of URLs of uploaded images.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
         * @example Suspense Query with parameters
         * ```ts
         * const data = qraft.apiService.getUserUploadsApiV1UserUploadsGet.useSuspenseQuery({
         *     cookie: {
         *         access_token: accessToken
         *     }
         * })
         * ```
         */
        useSuspenseQuery<TData = GetUserUploadsApiV1UserUploadsGetData>(parameters: ServiceOperationQueryKey<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetParameters> | (DeepReadonly<GetUserUploadsApiV1UserUploadsGetParameters>), options?: Omit<UseSuspenseQueryOptions<GetUserUploadsApiV1UserUploadsGetData, GetUserUploadsApiV1UserUploadsGetError, TData, ServiceOperationQueryKey<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetParameters>>, "queryKey">): UseSuspenseQueryResult<TData, OperationError<GetUserUploadsApiV1UserUploadsGetError>>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @summary Get User Uploads
         * @description Retrieve URLs of user's uploaded images.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[HttpUrl]: List of URLs of uploaded images.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.getUserUploadsApiV1UserUploadsGet.useSuspenseInfiniteQuery({
         *     cookie: {
         *         access_token: accessToken
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetUserUploadsApiV1UserUploadsGetParameters, TData = GetUserUploadsApiV1UserUploadsGetData>(parameters: ServiceOperationInfiniteQueryKey<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetParameters> | (DeepReadonly<GetUserUploadsApiV1UserUploadsGetParameters>), options: Omit<UseSuspenseInfiniteQueryOptions<GetUserUploadsApiV1UserUploadsGetData, GetUserUploadsApiV1UserUploadsGetError, OperationInfiniteData<TData, GetUserUploadsApiV1UserUploadsGetParameters>, ServiceOperationInfiniteQueryKey<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetUserUploadsApiV1UserUploadsGetData, PartialParameters<DeepReadonly<TPageParam>>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetUserUploadsApiV1UserUploadsGetParameters>, OperationError<GetUserUploadsApiV1UserUploadsGetError>>;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
         * Similar to useQueries but integrates with React Suspense for loading states.
         *
         * @summary Get User Uploads
         * @description Retrieve URLs of user's uploaded images.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[HttpUrl]: List of URLs of uploaded images.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
         * @example Basic usage with Suspense
         * ```ts
         * const getUserUploadsApiV1UserUploadsGetData = qraft.apiService.getUserUploadsApiV1UserUploadsGet.useSuspenseQueries({
         *     queries: [
         *         {
         *             cookie: {
         *                 access_token: accessToken1
         *             }
         *         },
         *         {
         *             cookie: {
         *                 access_token: accessToken2
         *             }
         *         }
         *     ]
         * });
         * getUserUploadsApiV1UserUploadsGetResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example With data transformation using combine
         * ```ts
         * const getUserUploadsApiV1UserUploadsGetCombinedData = qraft.apiService.getUserUploadsApiV1UserUploadsGet.useSuspenseQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             cookie: {
         *                 access_token: accessToken1
         *             }
         *         },
         *         {
         *             cookie: {
         *                 access_token: accessToken2
         *             }
         *         }
         *     ]
         * });
         * getUserUploadsApiV1UserUploadsGetCombinedData.forEach(data => console.log({ data }));
         * ```
         */
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetParameters, GetUserUploadsApiV1UserUploadsGetData, GetUserUploadsApiV1UserUploadsGetError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetUserUploadsApiV1UserUploadsGetData, GetUserUploadsApiV1UserUploadsGetError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetUserUploadsApiV1UserUploadsGetData, GetUserUploadsApiV1UserUploadsGetError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * @summary Get User Uploads
         * @description Retrieve URLs of user's uploaded images.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[HttpUrl]: List of URLs of uploaded images.
         */
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetData, GetUserUploadsApiV1UserUploadsGetParameters, GetUserUploadsApiV1UserUploadsGetError>): Promise<GetUserUploadsApiV1UserUploadsGetData>;
        /**
         * @summary Get User Uploads
         * @description Retrieve URLs of user's uploaded images.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[HttpUrl]: List of URLs of uploaded images.
         */
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetData, GetUserUploadsApiV1UserUploadsGetParameters, GetUserUploadsApiV1UserUploadsGetError>): Promise<void>;
        /**
         * @summary Get User Uploads
         * @description Retrieve URLs of user's uploaded images.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[HttpUrl]: List of URLs of uploaded images.
         */
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetData, GetUserUploadsApiV1UserUploadsGetParameters, GetUserUploadsApiV1UserUploadsGetError>): Promise<GetUserUploadsApiV1UserUploadsGetData>;
        /**
         * @summary Get User Uploads
         * @description Retrieve URLs of user's uploaded images.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[HttpUrl]: List of URLs of uploaded images.
         */
        fetchInfiniteQuery<TPageParam extends GetUserUploadsApiV1UserUploadsGetParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetData, GetUserUploadsApiV1UserUploadsGetParameters, DeepReadonly<TPageParam>, GetUserUploadsApiV1UserUploadsGetError>): Promise<OperationInfiniteData<GetUserUploadsApiV1UserUploadsGetData, GetUserUploadsApiV1UserUploadsGetParameters>>;
        /**
         * @summary Get User Uploads
         * @description Retrieve URLs of user's uploaded images.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[HttpUrl]: List of URLs of uploaded images.
         */
        prefetchInfiniteQuery<TPageParam extends GetUserUploadsApiV1UserUploadsGetParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetData, GetUserUploadsApiV1UserUploadsGetParameters, DeepReadonly<TPageParam>, GetUserUploadsApiV1UserUploadsGetError>): Promise<void>;
        /**
         * @summary Get User Uploads
         * @description Retrieve URLs of user's uploaded images.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[HttpUrl]: List of URLs of uploaded images.
         */
        ensureInfiniteQueryData<TPageParam extends GetUserUploadsApiV1UserUploadsGetParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetData, GetUserUploadsApiV1UserUploadsGetParameters, DeepReadonly<TPageParam>, GetUserUploadsApiV1UserUploadsGetError>): Promise<OperationInfiniteData<GetUserUploadsApiV1UserUploadsGetData, GetUserUploadsApiV1UserUploadsGetParameters>>;
        /**
         * @summary Get User Uploads
         * @description Retrieve URLs of user's uploaded images.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[HttpUrl]: List of URLs of uploaded images.
         */
        getQueryData(parameters: ServiceOperationQueryKey<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetParameters> | (DeepReadonly<GetUserUploadsApiV1UserUploadsGetParameters>)): GetUserUploadsApiV1UserUploadsGetData | undefined;
        /**
         * @summary Get User Uploads
         * @description Retrieve URLs of user's uploaded images.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[HttpUrl]: List of URLs of uploaded images.
         */
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetParameters> | (DeepReadonly<GetUserUploadsApiV1UserUploadsGetParameters>)): OperationInfiniteData<GetUserUploadsApiV1UserUploadsGetData, GetUserUploadsApiV1UserUploadsGetParameters> | undefined;
        /**
         * @summary Get User Uploads
         * @description Retrieve URLs of user's uploaded images.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[HttpUrl]: List of URLs of uploaded images.
         */
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetData, TInfinite, GetUserUploadsApiV1UserUploadsGetParameters, GetUserUploadsApiV1UserUploadsGetError> | QueryFiltersByQueryKey<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetData, TInfinite, GetUserUploadsApiV1UserUploadsGetParameters, GetUserUploadsApiV1UserUploadsGetError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetParameters>,
            data: NoInfer<OperationInfiniteData<GetUserUploadsApiV1UserUploadsGetData, GetUserUploadsApiV1UserUploadsGetParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetParameters>,
            data: GetUserUploadsApiV1UserUploadsGetData | undefined
        ]>;
        /**
         * @summary Get User Uploads
         * @description Retrieve URLs of user's uploaded images.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[HttpUrl]: List of URLs of uploaded images.
         */
        getQueryState(parameters: ServiceOperationQueryKey<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetParameters> | (DeepReadonly<GetUserUploadsApiV1UserUploadsGetParameters>)): QueryState<GetUserUploadsApiV1UserUploadsGetData, GetUserUploadsApiV1UserUploadsGetError> | undefined;
        /**
         * @summary Get User Uploads
         * @description Retrieve URLs of user's uploaded images.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[HttpUrl]: List of URLs of uploaded images.
         */
        getInfiniteQueryState(parameters: DeepReadonly<GetUserUploadsApiV1UserUploadsGetParameters> | ServiceOperationInfiniteQueryKey<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetParameters>): QueryState<OperationInfiniteData<GetUserUploadsApiV1UserUploadsGetData, GetUserUploadsApiV1UserUploadsGetParameters>, GetUserUploadsApiV1UserUploadsGetError> | undefined;
        /**
         * @summary Get User Uploads
         * @description Retrieve URLs of user's uploaded images.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[HttpUrl]: List of URLs of uploaded images.
         */
        setQueryData(parameters: (DeepReadonly<GetUserUploadsApiV1UserUploadsGetParameters>) | ServiceOperationQueryKey<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetParameters>, updater: Updater<NoInfer<GetUserUploadsApiV1UserUploadsGetData> | undefined, NoInfer<DeepReadonly<GetUserUploadsApiV1UserUploadsGetData>> | undefined>, options?: SetDataOptions): GetUserUploadsApiV1UserUploadsGetData | undefined;
        /**
         * @summary Get User Uploads
         * @description Retrieve URLs of user's uploaded images.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[HttpUrl]: List of URLs of uploaded images.
         */
        setInfiniteQueryData(parameters: (DeepReadonly<GetUserUploadsApiV1UserUploadsGetParameters>) | ServiceOperationInfiniteQueryKey<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetUserUploadsApiV1UserUploadsGetData, GetUserUploadsApiV1UserUploadsGetParameters>> | undefined, NoInfer<DeepReadonly<OperationInfiniteData<GetUserUploadsApiV1UserUploadsGetData, GetUserUploadsApiV1UserUploadsGetParameters>>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetUserUploadsApiV1UserUploadsGetData, GetUserUploadsApiV1UserUploadsGetParameters> | undefined;
        /**
         * @summary Get User Uploads
         * @description Retrieve URLs of user's uploaded images.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[HttpUrl]: List of URLs of uploaded images.
         */
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetData, TInfinite, GetUserUploadsApiV1UserUploadsGetParameters, GetUserUploadsApiV1UserUploadsGetError> | QueryFiltersByQueryKey<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetData, TInfinite, GetUserUploadsApiV1UserUploadsGetParameters, GetUserUploadsApiV1UserUploadsGetError>, updater: Updater<NoInfer<GetUserUploadsApiV1UserUploadsGetData> | undefined, NoInfer<GetUserUploadsApiV1UserUploadsGetData> | undefined>, options?: SetDataOptions): Array<GetUserUploadsApiV1UserUploadsGetData | undefined>;
        /**
         * @summary Get User Uploads
         * @description Retrieve URLs of user's uploaded images.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[HttpUrl]: List of URLs of uploaded images.
         */
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetData, TInfinite, GetUserUploadsApiV1UserUploadsGetParameters, GetUserUploadsApiV1UserUploadsGetError>, options?: InvalidateOptions): Promise<void>;
        /**
         * @summary Get User Uploads
         * @description Retrieve URLs of user's uploaded images.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[HttpUrl]: List of URLs of uploaded images.
         */
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetData, TInfinite, GetUserUploadsApiV1UserUploadsGetParameters, GetUserUploadsApiV1UserUploadsGetError> | QueryFiltersByQueryKey<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetData, TInfinite, GetUserUploadsApiV1UserUploadsGetParameters, GetUserUploadsApiV1UserUploadsGetError>, options?: RefetchOptions): Promise<void>;
        /**
         * @summary Get User Uploads
         * @description Retrieve URLs of user's uploaded images.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[HttpUrl]: List of URLs of uploaded images.
         */
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetData, TInfinite, GetUserUploadsApiV1UserUploadsGetParameters, GetUserUploadsApiV1UserUploadsGetError> | QueryFiltersByQueryKey<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetData, TInfinite, GetUserUploadsApiV1UserUploadsGetParameters, GetUserUploadsApiV1UserUploadsGetError>, options?: CancelOptions): Promise<void>;
        /**
         * @summary Get User Uploads
         * @description Retrieve URLs of user's uploaded images.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[HttpUrl]: List of URLs of uploaded images.
         */
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetData, TInfinite, GetUserUploadsApiV1UserUploadsGetParameters, GetUserUploadsApiV1UserUploadsGetError> | QueryFiltersByQueryKey<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetData, TInfinite, GetUserUploadsApiV1UserUploadsGetParameters, GetUserUploadsApiV1UserUploadsGetError>): void;
        /**
         * @summary Get User Uploads
         * @description Retrieve URLs of user's uploaded images.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[HttpUrl]: List of URLs of uploaded images.
         */
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetData, TInfinite, GetUserUploadsApiV1UserUploadsGetParameters, GetUserUploadsApiV1UserUploadsGetError> | QueryFiltersByQueryKey<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetData, TInfinite, GetUserUploadsApiV1UserUploadsGetParameters, GetUserUploadsApiV1UserUploadsGetError>, options?: ResetOptions): Promise<void>;
        /**
         * @summary Get User Uploads
         * @description Retrieve URLs of user's uploaded images.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[HttpUrl]: List of URLs of uploaded images.
         */
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetData, TInfinite, GetUserUploadsApiV1UserUploadsGetParameters, GetUserUploadsApiV1UserUploadsGetError> | QueryFiltersByQueryKey<GetUserUploadsApiV1UserUploadsGetSchema, GetUserUploadsApiV1UserUploadsGetData, TInfinite, GetUserUploadsApiV1UserUploadsGetParameters, GetUserUploadsApiV1UserUploadsGetError>): number;
        schema: GetUserUploadsApiV1UserUploadsGetSchema;
        types: {
            parameters: GetUserUploadsApiV1UserUploadsGetParameters;
            data: GetUserUploadsApiV1UserUploadsGetData;
            error: GetUserUploadsApiV1UserUploadsGetError;
        };
    };
    /**
     * @summary Get Presigned Url
     * @description Generate presigned URL for direct S3 upload.
     *
     * Args:
     *     file_name (str): Name of the file to upload.
     *     file_type (str): MIME type of the file.
     *     current_user (User): Authenticated user via dependency.
     *
     * Returns:
     *     ImageUploadResponse: Presigned URL and upload details.
     */
    getPresignedUrlApiV1FilesPresignGet: {
        /**
         * @summary Get Presigned Url
         * @description Generate presigned URL for direct S3 upload.
         *
         * Args:
         *     file_name (str): Name of the file to upload.
         *     file_type (str): MIME type of the file.
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     ImageUploadResponse: Presigned URL and upload details.
         */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetPresignedUrlApiV1FilesPresignGetParameters, TMeta, TSignal>), client?: (schema: GetPresignedUrlApiV1FilesPresignGetSchema, options: {
            parameters: GetPresignedUrlApiV1FilesPresignGetParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetPresignedUrlApiV1FilesPresignGetData, GetPresignedUrlApiV1FilesPresignGetError>>): Promise<RequestFnResponse<GetPresignedUrlApiV1FilesPresignGetData, GetPresignedUrlApiV1FilesPresignGetError>>;
        /**
         * @summary Get Presigned Url
         * @description Generate presigned URL for direct S3 upload.
         *
         * Args:
         *     file_name (str): Name of the file to upload.
         *     file_type (str): MIME type of the file.
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     ImageUploadResponse: Presigned URL and upload details.
         */
        getQueryKey(parameters: DeepReadonly<GetPresignedUrlApiV1FilesPresignGetParameters>): ServiceOperationQueryKey<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get Presigned Url
         * @description Generate presigned URL for direct S3 upload.
         *
         * Args:
         *     file_name (str): Name of the file to upload.
         *     file_type (str): MIME type of the file.
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     ImageUploadResponse: Presigned URL and upload details.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.apiService.getPresignedUrlApiV1FilesPresignGet.useQuery({
         *     query: {
         *         file_name: fileName,
         *         file_type: fileType
         *     },
         *     cookie: {
         *         access_token: accessToken
         *     }
         * })
         * ```
         */
        useQuery<TData = GetPresignedUrlApiV1FilesPresignGetData>(parameters: ServiceOperationQueryKey<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetParameters> | (DeepReadonly<GetPresignedUrlApiV1FilesPresignGetParameters>), options?: Omit<UndefinedInitialDataOptions<GetPresignedUrlApiV1FilesPresignGetData, GetPresignedUrlApiV1FilesPresignGetError, TData, ServiceOperationQueryKey<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetParameters>>, "queryKey">): UseQueryResult<TData, OperationError<GetPresignedUrlApiV1FilesPresignGetError>>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get Presigned Url
         * @description Generate presigned URL for direct S3 upload.
         *
         * Args:
         *     file_name (str): Name of the file to upload.
         *     file_type (str): MIME type of the file.
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     ImageUploadResponse: Presigned URL and upload details.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.apiService.getPresignedUrlApiV1FilesPresignGet.useQuery({
         *     query: {
         *         file_name: fileName,
         *         file_type: fileType
         *     },
         *     cookie: {
         *         access_token: accessToken
         *     }
         * })
         * ```
         */
        useQuery<TData = GetPresignedUrlApiV1FilesPresignGetData>(parameters: ServiceOperationQueryKey<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetParameters> | (DeepReadonly<GetPresignedUrlApiV1FilesPresignGetParameters>), options: Omit<DefinedInitialDataOptions<GetPresignedUrlApiV1FilesPresignGetData, GetPresignedUrlApiV1FilesPresignGetError, TData, ServiceOperationQueryKey<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetParameters>>, "queryKey">): DefinedUseQueryResult<TData, OperationError<GetPresignedUrlApiV1FilesPresignGetError>>;
        /**
         * @summary Get Presigned Url
         * @description Generate presigned URL for direct S3 upload.
         *
         * Args:
         *     file_name (str): Name of the file to upload.
         *     file_type (str): MIME type of the file.
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     ImageUploadResponse: Presigned URL and upload details.
         */
        getInfiniteQueryKey(parameters: DeepReadonly<GetPresignedUrlApiV1FilesPresignGetParameters>): ServiceOperationInfiniteQueryKey<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @summary Get Presigned Url
         * @description Generate presigned URL for direct S3 upload.
         *
         * Args:
         *     file_name (str): Name of the file to upload.
         *     file_type (str): MIME type of the file.
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     ImageUploadResponse: Presigned URL and upload details.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.getPresignedUrlApiV1FilesPresignGet.useInfiniteQuery({
         *     query: {
         *         file_name: fileName,
         *         file_type: fileType
         *     },
         *     cookie: {
         *         access_token: accessToken
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             file_name: initialFileName,
         *             file_type: initialFileType
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetPresignedUrlApiV1FilesPresignGetParameters, TQueryFnData = GetPresignedUrlApiV1FilesPresignGetData, TData = OperationInfiniteData<TQueryFnData, GetPresignedUrlApiV1FilesPresignGetParameters>>(parameters: ServiceOperationInfiniteQueryKey<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetParameters> | (DeepReadonly<GetPresignedUrlApiV1FilesPresignGetParameters>), options: Omit<UndefinedInitialDataInfiniteOptions<TQueryFnData, GetPresignedUrlApiV1FilesPresignGetError, TData, ServiceOperationInfiniteQueryKey<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>): UseInfiniteQueryResult<TData, OperationError<GetPresignedUrlApiV1FilesPresignGetError>>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @summary Get Presigned Url
         * @description Generate presigned URL for direct S3 upload.
         *
         * Args:
         *     file_name (str): Name of the file to upload.
         *     file_type (str): MIME type of the file.
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     ImageUploadResponse: Presigned URL and upload details.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.getPresignedUrlApiV1FilesPresignGet.useInfiniteQuery({
         *     query: {
         *         file_name: fileName,
         *         file_type: fileType
         *     },
         *     cookie: {
         *         access_token: accessToken
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             file_name: initialFileName,
         *             file_type: initialFileType
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetPresignedUrlApiV1FilesPresignGetParameters, TQueryFnData = GetPresignedUrlApiV1FilesPresignGetData, TData = OperationInfiniteData<TQueryFnData, GetPresignedUrlApiV1FilesPresignGetParameters>>(parameters: ServiceOperationInfiniteQueryKey<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetParameters> | (DeepReadonly<GetPresignedUrlApiV1FilesPresignGetParameters>), options: Omit<DefinedInitialDataInfiniteOptions<TQueryFnData, GetPresignedUrlApiV1FilesPresignGetError, TData, ServiceOperationInfiniteQueryKey<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetPresignedUrlApiV1FilesPresignGetData, PartialParameters<DeepReadonly<TPageParam>>>): DefinedUseInfiniteQueryResult<TData, OperationError<GetPresignedUrlApiV1FilesPresignGetError>>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @summary Get Presigned Url
         * @description Generate presigned URL for direct S3 upload.
         *
         * Args:
         *     file_name (str): Name of the file to upload.
         *     file_type (str): MIME type of the file.
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     ImageUploadResponse: Presigned URL and upload details.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getPresignedUrlApiV1FilesPresignGetTotal = qraft.apiService.getPresignedUrlApiV1FilesPresignGet.useIsFetching()
         * ```
         * @example Checks the number of normal queries fetching with the specified parameters.
         * ```ts
         * const getPresignedUrlApiV1FilesPresignGetByParametersTotal = qraft.apiService.getPresignedUrlApiV1FilesPresignGet.useIsFetching({
         *     infinite: false,
         *     parameters: {
         *         query: {
         *             file_name: fileName,
         *             file_type: fileType
         *         },
         *         cookie: {
         *             access_token: accessToken
         *         }
         *     }
         * })
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetData, TInfinite, GetPresignedUrlApiV1FilesPresignGetParameters, GetPresignedUrlApiV1FilesPresignGetError> | QueryFiltersByQueryKey<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetData, TInfinite, GetPresignedUrlApiV1FilesPresignGetParameters, GetPresignedUrlApiV1FilesPresignGetError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @summary Get Presigned Url
         * @description Generate presigned URL for direct S3 upload.
         *
         * Args:
         *     file_name (str): Name of the file to upload.
         *     file_type (str): MIME type of the file.
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     ImageUploadResponse: Presigned URL and upload details.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getPresignedUrlApiV1FilesPresignGetResults = qraft.apiService.getPresignedUrlApiV1FilesPresignGet.useQueries({
         *     queries: [
         *         {
         *             query: {
         *                 file_name: fileName1,
         *                 file_type: fileType1
         *             },
         *             cookie: {
         *                 access_token: accessToken1
         *             }
         *         },
         *         {
         *             query: {
         *                 file_name: fileName2,
         *                 file_type: fileType2
         *             },
         *             cookie: {
         *                 access_token: accessToken2
         *             }
         *         }
         *     ]
         * });
         * getPresignedUrlApiV1FilesPresignGetResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getPresignedUrlApiV1FilesPresignGetCombinedResults = qraft.apiService.getPresignedUrlApiV1FilesPresignGet.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             query: {
         *                 file_name: fileName1,
         *                 file_type: fileType1
         *             },
         *             cookie: {
         *                 access_token: accessToken1
         *             }
         *         },
         *         {
         *             query: {
         *                 file_name: fileName2,
         *                 file_type: fileType2
         *             },
         *             cookie: {
         *                 access_token: accessToken2
         *             }
         *         }
         *     ]
         * });
         * getPresignedUrlApiV1FilesPresignGetCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetParameters, GetPresignedUrlApiV1FilesPresignGetData, GetPresignedUrlApiV1FilesPresignGetError>>, TCombinedResult = Array<UseQueryResult<GetPresignedUrlApiV1FilesPresignGetData, GetPresignedUrlApiV1FilesPresignGetError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetPresignedUrlApiV1FilesPresignGetData, GetPresignedUrlApiV1FilesPresignGetError>>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * Performs asynchronous data fetching with Suspense support.
         * Similar to useQuery but integrates with React Suspense for loading states.
         *
         * @summary Get Presigned Url
         * @description Generate presigned URL for direct S3 upload.
         *
         * Args:
         *     file_name (str): Name of the file to upload.
         *     file_type (str): MIME type of the file.
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     ImageUploadResponse: Presigned URL and upload details.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
         * @example Suspense Query with parameters
         * ```ts
         * const data = qraft.apiService.getPresignedUrlApiV1FilesPresignGet.useSuspenseQuery({
         *     query: {
         *         file_name: fileName,
         *         file_type: fileType
         *     },
         *     cookie: {
         *         access_token: accessToken
         *     }
         * })
         * ```
         */
        useSuspenseQuery<TData = GetPresignedUrlApiV1FilesPresignGetData>(parameters: ServiceOperationQueryKey<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetParameters> | (DeepReadonly<GetPresignedUrlApiV1FilesPresignGetParameters>), options?: Omit<UseSuspenseQueryOptions<GetPresignedUrlApiV1FilesPresignGetData, GetPresignedUrlApiV1FilesPresignGetError, TData, ServiceOperationQueryKey<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetParameters>>, "queryKey">): UseSuspenseQueryResult<TData, OperationError<GetPresignedUrlApiV1FilesPresignGetError>>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @summary Get Presigned Url
         * @description Generate presigned URL for direct S3 upload.
         *
         * Args:
         *     file_name (str): Name of the file to upload.
         *     file_type (str): MIME type of the file.
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     ImageUploadResponse: Presigned URL and upload details.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.getPresignedUrlApiV1FilesPresignGet.useSuspenseInfiniteQuery({
         *     query: {
         *         file_name: fileName,
         *         file_type: fileType
         *     },
         *     cookie: {
         *         access_token: accessToken
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             file_name: initialFileName,
         *             file_type: initialFileType
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetPresignedUrlApiV1FilesPresignGetParameters, TData = GetPresignedUrlApiV1FilesPresignGetData>(parameters: ServiceOperationInfiniteQueryKey<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetParameters> | (DeepReadonly<GetPresignedUrlApiV1FilesPresignGetParameters>), options: Omit<UseSuspenseInfiniteQueryOptions<GetPresignedUrlApiV1FilesPresignGetData, GetPresignedUrlApiV1FilesPresignGetError, OperationInfiniteData<TData, GetPresignedUrlApiV1FilesPresignGetParameters>, ServiceOperationInfiniteQueryKey<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetPresignedUrlApiV1FilesPresignGetData, PartialParameters<DeepReadonly<TPageParam>>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetPresignedUrlApiV1FilesPresignGetParameters>, OperationError<GetPresignedUrlApiV1FilesPresignGetError>>;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
         * Similar to useQueries but integrates with React Suspense for loading states.
         *
         * @summary Get Presigned Url
         * @description Generate presigned URL for direct S3 upload.
         *
         * Args:
         *     file_name (str): Name of the file to upload.
         *     file_type (str): MIME type of the file.
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     ImageUploadResponse: Presigned URL and upload details.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
         * @example Basic usage with Suspense
         * ```ts
         * const getPresignedUrlApiV1FilesPresignGetData = qraft.apiService.getPresignedUrlApiV1FilesPresignGet.useSuspenseQueries({
         *     queries: [
         *         {
         *             query: {
         *                 file_name: fileName1,
         *                 file_type: fileType1
         *             },
         *             cookie: {
         *                 access_token: accessToken1
         *             }
         *         },
         *         {
         *             query: {
         *                 file_name: fileName2,
         *                 file_type: fileType2
         *             },
         *             cookie: {
         *                 access_token: accessToken2
         *             }
         *         }
         *     ]
         * });
         * getPresignedUrlApiV1FilesPresignGetResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example With data transformation using combine
         * ```ts
         * const getPresignedUrlApiV1FilesPresignGetCombinedData = qraft.apiService.getPresignedUrlApiV1FilesPresignGet.useSuspenseQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             query: {
         *                 file_name: fileName1,
         *                 file_type: fileType1
         *             },
         *             cookie: {
         *                 access_token: accessToken1
         *             }
         *         },
         *         {
         *             query: {
         *                 file_name: fileName2,
         *                 file_type: fileType2
         *             },
         *             cookie: {
         *                 access_token: accessToken2
         *             }
         *         }
         *     ]
         * });
         * getPresignedUrlApiV1FilesPresignGetCombinedData.forEach(data => console.log({ data }));
         * ```
         */
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetParameters, GetPresignedUrlApiV1FilesPresignGetData, GetPresignedUrlApiV1FilesPresignGetError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetPresignedUrlApiV1FilesPresignGetData, GetPresignedUrlApiV1FilesPresignGetError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetPresignedUrlApiV1FilesPresignGetData, GetPresignedUrlApiV1FilesPresignGetError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * @summary Get Presigned Url
         * @description Generate presigned URL for direct S3 upload.
         *
         * Args:
         *     file_name (str): Name of the file to upload.
         *     file_type (str): MIME type of the file.
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     ImageUploadResponse: Presigned URL and upload details.
         */
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetData, GetPresignedUrlApiV1FilesPresignGetParameters, GetPresignedUrlApiV1FilesPresignGetError>): Promise<GetPresignedUrlApiV1FilesPresignGetData>;
        /**
         * @summary Get Presigned Url
         * @description Generate presigned URL for direct S3 upload.
         *
         * Args:
         *     file_name (str): Name of the file to upload.
         *     file_type (str): MIME type of the file.
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     ImageUploadResponse: Presigned URL and upload details.
         */
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetData, GetPresignedUrlApiV1FilesPresignGetParameters, GetPresignedUrlApiV1FilesPresignGetError>): Promise<void>;
        /**
         * @summary Get Presigned Url
         * @description Generate presigned URL for direct S3 upload.
         *
         * Args:
         *     file_name (str): Name of the file to upload.
         *     file_type (str): MIME type of the file.
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     ImageUploadResponse: Presigned URL and upload details.
         */
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetData, GetPresignedUrlApiV1FilesPresignGetParameters, GetPresignedUrlApiV1FilesPresignGetError>): Promise<GetPresignedUrlApiV1FilesPresignGetData>;
        /**
         * @summary Get Presigned Url
         * @description Generate presigned URL for direct S3 upload.
         *
         * Args:
         *     file_name (str): Name of the file to upload.
         *     file_type (str): MIME type of the file.
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     ImageUploadResponse: Presigned URL and upload details.
         */
        fetchInfiniteQuery<TPageParam extends GetPresignedUrlApiV1FilesPresignGetParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetData, GetPresignedUrlApiV1FilesPresignGetParameters, DeepReadonly<TPageParam>, GetPresignedUrlApiV1FilesPresignGetError>): Promise<OperationInfiniteData<GetPresignedUrlApiV1FilesPresignGetData, GetPresignedUrlApiV1FilesPresignGetParameters>>;
        /**
         * @summary Get Presigned Url
         * @description Generate presigned URL for direct S3 upload.
         *
         * Args:
         *     file_name (str): Name of the file to upload.
         *     file_type (str): MIME type of the file.
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     ImageUploadResponse: Presigned URL and upload details.
         */
        prefetchInfiniteQuery<TPageParam extends GetPresignedUrlApiV1FilesPresignGetParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetData, GetPresignedUrlApiV1FilesPresignGetParameters, DeepReadonly<TPageParam>, GetPresignedUrlApiV1FilesPresignGetError>): Promise<void>;
        /**
         * @summary Get Presigned Url
         * @description Generate presigned URL for direct S3 upload.
         *
         * Args:
         *     file_name (str): Name of the file to upload.
         *     file_type (str): MIME type of the file.
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     ImageUploadResponse: Presigned URL and upload details.
         */
        ensureInfiniteQueryData<TPageParam extends GetPresignedUrlApiV1FilesPresignGetParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetData, GetPresignedUrlApiV1FilesPresignGetParameters, DeepReadonly<TPageParam>, GetPresignedUrlApiV1FilesPresignGetError>): Promise<OperationInfiniteData<GetPresignedUrlApiV1FilesPresignGetData, GetPresignedUrlApiV1FilesPresignGetParameters>>;
        /**
         * @summary Get Presigned Url
         * @description Generate presigned URL for direct S3 upload.
         *
         * Args:
         *     file_name (str): Name of the file to upload.
         *     file_type (str): MIME type of the file.
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     ImageUploadResponse: Presigned URL and upload details.
         */
        getQueryData(parameters: ServiceOperationQueryKey<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetParameters> | (DeepReadonly<GetPresignedUrlApiV1FilesPresignGetParameters>)): GetPresignedUrlApiV1FilesPresignGetData | undefined;
        /**
         * @summary Get Presigned Url
         * @description Generate presigned URL for direct S3 upload.
         *
         * Args:
         *     file_name (str): Name of the file to upload.
         *     file_type (str): MIME type of the file.
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     ImageUploadResponse: Presigned URL and upload details.
         */
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetParameters> | (DeepReadonly<GetPresignedUrlApiV1FilesPresignGetParameters>)): OperationInfiniteData<GetPresignedUrlApiV1FilesPresignGetData, GetPresignedUrlApiV1FilesPresignGetParameters> | undefined;
        /**
         * @summary Get Presigned Url
         * @description Generate presigned URL for direct S3 upload.
         *
         * Args:
         *     file_name (str): Name of the file to upload.
         *     file_type (str): MIME type of the file.
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     ImageUploadResponse: Presigned URL and upload details.
         */
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetData, TInfinite, GetPresignedUrlApiV1FilesPresignGetParameters, GetPresignedUrlApiV1FilesPresignGetError> | QueryFiltersByQueryKey<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetData, TInfinite, GetPresignedUrlApiV1FilesPresignGetParameters, GetPresignedUrlApiV1FilesPresignGetError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetParameters>,
            data: NoInfer<OperationInfiniteData<GetPresignedUrlApiV1FilesPresignGetData, GetPresignedUrlApiV1FilesPresignGetParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetParameters>,
            data: GetPresignedUrlApiV1FilesPresignGetData | undefined
        ]>;
        /**
         * @summary Get Presigned Url
         * @description Generate presigned URL for direct S3 upload.
         *
         * Args:
         *     file_name (str): Name of the file to upload.
         *     file_type (str): MIME type of the file.
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     ImageUploadResponse: Presigned URL and upload details.
         */
        getQueryState(parameters: ServiceOperationQueryKey<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetParameters> | (DeepReadonly<GetPresignedUrlApiV1FilesPresignGetParameters>)): QueryState<GetPresignedUrlApiV1FilesPresignGetData, GetPresignedUrlApiV1FilesPresignGetError> | undefined;
        /**
         * @summary Get Presigned Url
         * @description Generate presigned URL for direct S3 upload.
         *
         * Args:
         *     file_name (str): Name of the file to upload.
         *     file_type (str): MIME type of the file.
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     ImageUploadResponse: Presigned URL and upload details.
         */
        getInfiniteQueryState(parameters: DeepReadonly<GetPresignedUrlApiV1FilesPresignGetParameters> | ServiceOperationInfiniteQueryKey<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetParameters>): QueryState<OperationInfiniteData<GetPresignedUrlApiV1FilesPresignGetData, GetPresignedUrlApiV1FilesPresignGetParameters>, GetPresignedUrlApiV1FilesPresignGetError> | undefined;
        /**
         * @summary Get Presigned Url
         * @description Generate presigned URL for direct S3 upload.
         *
         * Args:
         *     file_name (str): Name of the file to upload.
         *     file_type (str): MIME type of the file.
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     ImageUploadResponse: Presigned URL and upload details.
         */
        setQueryData(parameters: (DeepReadonly<GetPresignedUrlApiV1FilesPresignGetParameters>) | ServiceOperationQueryKey<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetParameters>, updater: Updater<NoInfer<GetPresignedUrlApiV1FilesPresignGetData> | undefined, NoInfer<DeepReadonly<GetPresignedUrlApiV1FilesPresignGetData>> | undefined>, options?: SetDataOptions): GetPresignedUrlApiV1FilesPresignGetData | undefined;
        /**
         * @summary Get Presigned Url
         * @description Generate presigned URL for direct S3 upload.
         *
         * Args:
         *     file_name (str): Name of the file to upload.
         *     file_type (str): MIME type of the file.
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     ImageUploadResponse: Presigned URL and upload details.
         */
        setInfiniteQueryData(parameters: (DeepReadonly<GetPresignedUrlApiV1FilesPresignGetParameters>) | ServiceOperationInfiniteQueryKey<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetPresignedUrlApiV1FilesPresignGetData, GetPresignedUrlApiV1FilesPresignGetParameters>> | undefined, NoInfer<DeepReadonly<OperationInfiniteData<GetPresignedUrlApiV1FilesPresignGetData, GetPresignedUrlApiV1FilesPresignGetParameters>>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetPresignedUrlApiV1FilesPresignGetData, GetPresignedUrlApiV1FilesPresignGetParameters> | undefined;
        /**
         * @summary Get Presigned Url
         * @description Generate presigned URL for direct S3 upload.
         *
         * Args:
         *     file_name (str): Name of the file to upload.
         *     file_type (str): MIME type of the file.
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     ImageUploadResponse: Presigned URL and upload details.
         */
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetData, TInfinite, GetPresignedUrlApiV1FilesPresignGetParameters, GetPresignedUrlApiV1FilesPresignGetError> | QueryFiltersByQueryKey<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetData, TInfinite, GetPresignedUrlApiV1FilesPresignGetParameters, GetPresignedUrlApiV1FilesPresignGetError>, updater: Updater<NoInfer<GetPresignedUrlApiV1FilesPresignGetData> | undefined, NoInfer<GetPresignedUrlApiV1FilesPresignGetData> | undefined>, options?: SetDataOptions): Array<GetPresignedUrlApiV1FilesPresignGetData | undefined>;
        /**
         * @summary Get Presigned Url
         * @description Generate presigned URL for direct S3 upload.
         *
         * Args:
         *     file_name (str): Name of the file to upload.
         *     file_type (str): MIME type of the file.
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     ImageUploadResponse: Presigned URL and upload details.
         */
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetData, TInfinite, GetPresignedUrlApiV1FilesPresignGetParameters, GetPresignedUrlApiV1FilesPresignGetError>, options?: InvalidateOptions): Promise<void>;
        /**
         * @summary Get Presigned Url
         * @description Generate presigned URL for direct S3 upload.
         *
         * Args:
         *     file_name (str): Name of the file to upload.
         *     file_type (str): MIME type of the file.
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     ImageUploadResponse: Presigned URL and upload details.
         */
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetData, TInfinite, GetPresignedUrlApiV1FilesPresignGetParameters, GetPresignedUrlApiV1FilesPresignGetError> | QueryFiltersByQueryKey<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetData, TInfinite, GetPresignedUrlApiV1FilesPresignGetParameters, GetPresignedUrlApiV1FilesPresignGetError>, options?: RefetchOptions): Promise<void>;
        /**
         * @summary Get Presigned Url
         * @description Generate presigned URL for direct S3 upload.
         *
         * Args:
         *     file_name (str): Name of the file to upload.
         *     file_type (str): MIME type of the file.
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     ImageUploadResponse: Presigned URL and upload details.
         */
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetData, TInfinite, GetPresignedUrlApiV1FilesPresignGetParameters, GetPresignedUrlApiV1FilesPresignGetError> | QueryFiltersByQueryKey<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetData, TInfinite, GetPresignedUrlApiV1FilesPresignGetParameters, GetPresignedUrlApiV1FilesPresignGetError>, options?: CancelOptions): Promise<void>;
        /**
         * @summary Get Presigned Url
         * @description Generate presigned URL for direct S3 upload.
         *
         * Args:
         *     file_name (str): Name of the file to upload.
         *     file_type (str): MIME type of the file.
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     ImageUploadResponse: Presigned URL and upload details.
         */
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetData, TInfinite, GetPresignedUrlApiV1FilesPresignGetParameters, GetPresignedUrlApiV1FilesPresignGetError> | QueryFiltersByQueryKey<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetData, TInfinite, GetPresignedUrlApiV1FilesPresignGetParameters, GetPresignedUrlApiV1FilesPresignGetError>): void;
        /**
         * @summary Get Presigned Url
         * @description Generate presigned URL for direct S3 upload.
         *
         * Args:
         *     file_name (str): Name of the file to upload.
         *     file_type (str): MIME type of the file.
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     ImageUploadResponse: Presigned URL and upload details.
         */
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetData, TInfinite, GetPresignedUrlApiV1FilesPresignGetParameters, GetPresignedUrlApiV1FilesPresignGetError> | QueryFiltersByQueryKey<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetData, TInfinite, GetPresignedUrlApiV1FilesPresignGetParameters, GetPresignedUrlApiV1FilesPresignGetError>, options?: ResetOptions): Promise<void>;
        /**
         * @summary Get Presigned Url
         * @description Generate presigned URL for direct S3 upload.
         *
         * Args:
         *     file_name (str): Name of the file to upload.
         *     file_type (str): MIME type of the file.
         *     current_user (User): Authenticated user via dependency.
         *
         * Returns:
         *     ImageUploadResponse: Presigned URL and upload details.
         */
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetData, TInfinite, GetPresignedUrlApiV1FilesPresignGetParameters, GetPresignedUrlApiV1FilesPresignGetError> | QueryFiltersByQueryKey<GetPresignedUrlApiV1FilesPresignGetSchema, GetPresignedUrlApiV1FilesPresignGetData, TInfinite, GetPresignedUrlApiV1FilesPresignGetParameters, GetPresignedUrlApiV1FilesPresignGetError>): number;
        schema: GetPresignedUrlApiV1FilesPresignGetSchema;
        types: {
            parameters: GetPresignedUrlApiV1FilesPresignGetParameters;
            data: GetPresignedUrlApiV1FilesPresignGetData;
            error: GetPresignedUrlApiV1FilesPresignGetError;
        };
    };
    /**
     * @summary Generate Image
     * @description Initiate an image generation request.
     *
     * Args:
     *     data (ImageGenRequest): User input including style ID and input image URL.
     *     background_tasks (BackgroundTasks): FastAPI background task handler.
     *     current_user (User): Authenticated user via dependency.
     *     db: Database session.
     *
     * Returns:
     *     ImageGenResponse: Contains image_id and confirmation message.
     *
     * Raises:
     *     HTTPException: If database record creation fails.
     */
    generateImageApiV1ImageGeneratePost: {
        /**
         * @summary Generate Image
         * @description Initiate an image generation request.
         *
         * Args:
         *     data (ImageGenRequest): User input including style ID and input image URL.
         *     background_tasks (BackgroundTasks): FastAPI background task handler.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenResponse: Contains image_id and confirmation message.
         *
         * Raises:
         *     HTTPException: If database record creation fails.
         */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: ServiceOperationMutationFnOptions<GenerateImageApiV1ImageGeneratePostBody, GenerateImageApiV1ImageGeneratePostParameters, TMeta, TSignal>, client?: (schema: GenerateImageApiV1ImageGeneratePostSchema, options: ServiceOperationMutationFnOptions<GenerateImageApiV1ImageGeneratePostBody, GenerateImageApiV1ImageGeneratePostParameters, TMeta, TSignal>) => Promise<RequestFnResponse<GenerateImageApiV1ImageGeneratePostData, GenerateImageApiV1ImageGeneratePostError>>): Promise<RequestFnResponse<GenerateImageApiV1ImageGeneratePostData, GenerateImageApiV1ImageGeneratePostError>>;
        /**
         * @summary Generate Image
         * @description Initiate an image generation request.
         *
         * Args:
         *     data (ImageGenRequest): User input including style ID and input image URL.
         *     background_tasks (BackgroundTasks): FastAPI background task handler.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenResponse: Contains image_id and confirmation message.
         *
         * Raises:
         *     HTTPException: If database record creation fails.
         */
        getMutationKey(parameters: DeepReadonly<GenerateImageApiV1ImageGeneratePostParameters> | void): ServiceOperationMutationKey<GenerateImageApiV1ImageGeneratePostSchema, GenerateImageApiV1ImageGeneratePostParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Generate Image
         * @description Initiate an image generation request.
         *
         * Args:
         *     data (ImageGenRequest): User input including style ID and input image URL.
         *     background_tasks (BackgroundTasks): FastAPI background task handler.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenResponse: Contains image_id and confirmation message.
         *
         * Raises:
         *     HTTPException: If database record creation fails.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.generateImageApiV1ImageGeneratePost.useMutation({
         *     cookie: {
         *         access_token: accessToken
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.generateImageApiV1ImageGeneratePost.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     cookie: {
         *         access_token: accessToken
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends GenerateImageApiV1ImageGeneratePostBody, TContext = unknown>(parameters: DeepReadonly<GenerateImageApiV1ImageGeneratePostParameters>, options?: ServiceOperationUseMutationOptions<GenerateImageApiV1ImageGeneratePostSchema, GenerateImageApiV1ImageGeneratePostData, GenerateImageApiV1ImageGeneratePostParameters, TVariables, OperationError<GenerateImageApiV1ImageGeneratePostError>, TContext>): UseMutationResult<GenerateImageApiV1ImageGeneratePostData, OperationError<GenerateImageApiV1ImageGeneratePostError>, TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Generate Image
         * @description Initiate an image generation request.
         *
         * Args:
         *     data (ImageGenRequest): User input including style ID and input image URL.
         *     background_tasks (BackgroundTasks): FastAPI background task handler.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenResponse: Contains image_id and confirmation message.
         *
         * Raises:
         *     HTTPException: If database record creation fails.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.generateImageApiV1ImageGeneratePost.useMutation({
         *     cookie: {
         *         access_token: accessToken
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.generateImageApiV1ImageGeneratePost.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     cookie: {
         *         access_token: accessToken
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<GenerateImageApiV1ImageGeneratePostBody, GenerateImageApiV1ImageGeneratePostParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<GenerateImageApiV1ImageGeneratePostSchema, GenerateImageApiV1ImageGeneratePostData, GenerateImageApiV1ImageGeneratePostParameters, TVariables, OperationError<GenerateImageApiV1ImageGeneratePostError>, TContext>): UseMutationResult<GenerateImageApiV1ImageGeneratePostData, OperationError<GenerateImageApiV1ImageGeneratePostError>, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @summary Generate Image
         * @description Initiate an image generation request.
         *
         * Args:
         *     data (ImageGenRequest): User input including style ID and input image URL.
         *     background_tasks (BackgroundTasks): FastAPI background task handler.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenResponse: Contains image_id and confirmation message.
         *
         * Raises:
         *     HTTPException: If database record creation fails.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const generateImageApiV1ImageGeneratePostTotal = qraft.apiService.generateImageApiV1ImageGeneratePost.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const generateImageApiV1ImageGeneratePostTotal = qraft.apiService.generateImageApiV1ImageGeneratePost.useIsMutating({
         *     parameters: {
         *         cookie: {
         *             access_token: accessToken
         *         }
         *     }
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<GenerateImageApiV1ImageGeneratePostBody, GenerateImageApiV1ImageGeneratePostData, GenerateImageApiV1ImageGeneratePostParameters, OperationError<GenerateImageApiV1ImageGeneratePostError>, TContext> | MutationFiltersByMutationKey<GenerateImageApiV1ImageGeneratePostSchema, GenerateImageApiV1ImageGeneratePostBody, GenerateImageApiV1ImageGeneratePostData, GenerateImageApiV1ImageGeneratePostParameters, OperationError<GenerateImageApiV1ImageGeneratePostError>, TContext>): number;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @summary Generate Image
         * @description Initiate an image generation request.
         *
         * Args:
         *     data (ImageGenRequest): User input including style ID and input image URL.
         *     background_tasks (BackgroundTasks): FastAPI background task handler.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenResponse: Contains image_id and confirmation message.
         *
         * Raises:
         *     HTTPException: If database record creation fails.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const generateImageApiV1ImageGeneratePostPendingMutationVariables = qraft.apiService.generateImageApiV1ImageGeneratePost.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const generateImageApiV1ImageGeneratePostMutationData = qraft.apiService.generateImageApiV1ImageGeneratePost.useMutationState({
         *     filters: {
         *         parameters: {
         *             cookie: {
         *                 access_token: accessToken
         *             }
         *         }
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<GenerateImageApiV1ImageGeneratePostData, OperationError<GenerateImageApiV1ImageGeneratePostError>, MutationVariables<GenerateImageApiV1ImageGeneratePostBody, GenerateImageApiV1ImageGeneratePostParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<GenerateImageApiV1ImageGeneratePostBody, GenerateImageApiV1ImageGeneratePostData, GenerateImageApiV1ImageGeneratePostParameters, OperationError<GenerateImageApiV1ImageGeneratePostError>, TContext> | MutationFiltersByMutationKey<GenerateImageApiV1ImageGeneratePostSchema, GenerateImageApiV1ImageGeneratePostBody, GenerateImageApiV1ImageGeneratePostData, GenerateImageApiV1ImageGeneratePostParameters, OperationError<GenerateImageApiV1ImageGeneratePostError>, TContext>;
            select?: (mutation: Mutation<GenerateImageApiV1ImageGeneratePostData, OperationError<GenerateImageApiV1ImageGeneratePostError>, MutationVariables<GenerateImageApiV1ImageGeneratePostBody, GenerateImageApiV1ImageGeneratePostParameters>, TContext>) => TResult;
        }): Array<TResult>;
        /**
         * @summary Generate Image
         * @description Initiate an image generation request.
         *
         * Args:
         *     data (ImageGenRequest): User input including style ID and input image URL.
         *     background_tasks (BackgroundTasks): FastAPI background task handler.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenResponse: Contains image_id and confirmation message.
         *
         * Raises:
         *     HTTPException: If database record creation fails.
         */
        isMutating<TContext>(filters?: MutationFiltersByParameters<GenerateImageApiV1ImageGeneratePostBody, GenerateImageApiV1ImageGeneratePostData, GenerateImageApiV1ImageGeneratePostParameters, OperationError<GenerateImageApiV1ImageGeneratePostError>, TContext> | MutationFiltersByMutationKey<GenerateImageApiV1ImageGeneratePostSchema, GenerateImageApiV1ImageGeneratePostBody, GenerateImageApiV1ImageGeneratePostData, GenerateImageApiV1ImageGeneratePostParameters, OperationError<GenerateImageApiV1ImageGeneratePostError>, TContext>): number;
        /**
         * Returns a `MutationCache` object that provides access to mutation cache operations
         * for the specific endpoint.
         *
         * @summary Generate Image
         * @description Initiate an image generation request.
         *
         * Args:
         *     data (ImageGenRequest): User input including style ID and input image URL.
         *     background_tasks (BackgroundTasks): FastAPI background task handler.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenResponse: Contains image_id and confirmation message.
         *
         * Raises:
         *     HTTPException: If database record creation fails.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/query-client/getMutationCache|`getMutationCache(...)` documentation}
         *
         * @example Find a mutation with specific parameters
         * ```ts
         * const mutationCache = qraft.apiService.generateImageApiV1ImageGeneratePost.getMutationCache();
         * const mutation = mutationCache.find({
         *     parameters: {
         *         cookie: {
         *             access_token: accessToken
         *         }
         *     }
         * });
         * ```
         *
         * @example Find all mutations for the endpoint
         * ```ts
         * const mutationCache = qraft.apiService.generateImageApiV1ImageGeneratePost.getMutationCache();
         * const mutations = mutationCache.findAll();
         * ```
         */
        getMutationCache(): Omit<MutationCache, "find" | "findAll"> & {
            find<TContext = unknown>(filters: MutationFiltersByParameters<GenerateImageApiV1ImageGeneratePostBody, GenerateImageApiV1ImageGeneratePostData, GenerateImageApiV1ImageGeneratePostParameters, OperationError<GenerateImageApiV1ImageGeneratePostError>, TContext> | MutationFiltersByMutationKey<GenerateImageApiV1ImageGeneratePostSchema, GenerateImageApiV1ImageGeneratePostBody, GenerateImageApiV1ImageGeneratePostData, GenerateImageApiV1ImageGeneratePostParameters, OperationError<GenerateImageApiV1ImageGeneratePostError>, TContext>): Mutation<GenerateImageApiV1ImageGeneratePostData, GenerateImageApiV1ImageGeneratePostError, MutationVariables<GenerateImageApiV1ImageGeneratePostBody, GenerateImageApiV1ImageGeneratePostParameters>, TContext> | undefined;
            findAll<TContext = unknown>(filters?: MutationFiltersByParameters<GenerateImageApiV1ImageGeneratePostBody, GenerateImageApiV1ImageGeneratePostData, GenerateImageApiV1ImageGeneratePostParameters, OperationError<GenerateImageApiV1ImageGeneratePostError>, TContext> | MutationFiltersByMutationKey<GenerateImageApiV1ImageGeneratePostSchema, GenerateImageApiV1ImageGeneratePostBody, GenerateImageApiV1ImageGeneratePostData, GenerateImageApiV1ImageGeneratePostParameters, OperationError<GenerateImageApiV1ImageGeneratePostError>, TContext>): Array<Mutation<GenerateImageApiV1ImageGeneratePostData, GenerateImageApiV1ImageGeneratePostError, MutationVariables<GenerateImageApiV1ImageGeneratePostBody, GenerateImageApiV1ImageGeneratePostParameters>, TContext>>;
        };
        schema: GenerateImageApiV1ImageGeneratePostSchema;
        types: {
            parameters: GenerateImageApiV1ImageGeneratePostParameters;
            data: GenerateImageApiV1ImageGeneratePostData;
            error: GenerateImageApiV1ImageGeneratePostError;
            body: GenerateImageApiV1ImageGeneratePostBody;
        };
    };
    /**
     * @summary Get Image Status
     * @description Retrieve image generation status and results.
     *
     * Args:
     *     image_id (int): ID of the image generation record.
     *     current_user (User): Authenticated user via dependency.
     *     db: Database session.
     *
     * Returns:
     *     ImageGenStatusResponse: Status and output URL if completed.
     *
     * Raises:
     *     HTTPException: If image not found or doesn't belong to user.
     */
    getImageStatusApiV1ImageStatusImageIdGet: {
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetImageStatusApiV1ImageStatusImageIdGetParameters, TMeta, TSignal>), client?: (schema: GetImageStatusApiV1ImageStatusImageIdGetSchema, options: {
            parameters: GetImageStatusApiV1ImageStatusImageIdGetParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetError>>): Promise<RequestFnResponse<GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetError>>;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        getQueryKey(parameters: DeepReadonly<GetImageStatusApiV1ImageStatusImageIdGetParameters>): ServiceOperationQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.apiService.getImageStatusApiV1ImageStatusImageIdGet.useQuery({
         *     path: {
         *         image_id: imageId
         *     },
         *     cookie: {
         *         access_token: accessToken
         *     }
         * })
         * ```
         */
        useQuery<TData = GetImageStatusApiV1ImageStatusImageIdGetData>(parameters: ServiceOperationQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters> | (DeepReadonly<GetImageStatusApiV1ImageStatusImageIdGetParameters>), options?: Omit<UndefinedInitialDataOptions<GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetError, TData, ServiceOperationQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters>>, "queryKey">): UseQueryResult<TData, OperationError<GetImageStatusApiV1ImageStatusImageIdGetError>>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.apiService.getImageStatusApiV1ImageStatusImageIdGet.useQuery({
         *     path: {
         *         image_id: imageId
         *     },
         *     cookie: {
         *         access_token: accessToken
         *     }
         * })
         * ```
         */
        useQuery<TData = GetImageStatusApiV1ImageStatusImageIdGetData>(parameters: ServiceOperationQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters> | (DeepReadonly<GetImageStatusApiV1ImageStatusImageIdGetParameters>), options: Omit<DefinedInitialDataOptions<GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetError, TData, ServiceOperationQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters>>, "queryKey">): DefinedUseQueryResult<TData, OperationError<GetImageStatusApiV1ImageStatusImageIdGetError>>;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        getInfiniteQueryKey(parameters: DeepReadonly<GetImageStatusApiV1ImageStatusImageIdGetParameters>): ServiceOperationInfiniteQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.getImageStatusApiV1ImageStatusImageIdGet.useInfiniteQuery({
         *     path: {
         *         image_id: imageId
         *     },
         *     cookie: {
         *         access_token: accessToken
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetImageStatusApiV1ImageStatusImageIdGetParameters, TQueryFnData = GetImageStatusApiV1ImageStatusImageIdGetData, TData = OperationInfiniteData<TQueryFnData, GetImageStatusApiV1ImageStatusImageIdGetParameters>>(parameters: ServiceOperationInfiniteQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters> | (DeepReadonly<GetImageStatusApiV1ImageStatusImageIdGetParameters>), options: Omit<UndefinedInitialDataInfiniteOptions<TQueryFnData, GetImageStatusApiV1ImageStatusImageIdGetError, TData, ServiceOperationInfiniteQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>): UseInfiniteQueryResult<TData, OperationError<GetImageStatusApiV1ImageStatusImageIdGetError>>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.getImageStatusApiV1ImageStatusImageIdGet.useInfiniteQuery({
         *     path: {
         *         image_id: imageId
         *     },
         *     cookie: {
         *         access_token: accessToken
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetImageStatusApiV1ImageStatusImageIdGetParameters, TQueryFnData = GetImageStatusApiV1ImageStatusImageIdGetData, TData = OperationInfiniteData<TQueryFnData, GetImageStatusApiV1ImageStatusImageIdGetParameters>>(parameters: ServiceOperationInfiniteQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters> | (DeepReadonly<GetImageStatusApiV1ImageStatusImageIdGetParameters>), options: Omit<DefinedInitialDataInfiniteOptions<TQueryFnData, GetImageStatusApiV1ImageStatusImageIdGetError, TData, ServiceOperationInfiniteQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetImageStatusApiV1ImageStatusImageIdGetData, PartialParameters<DeepReadonly<TPageParam>>>): DefinedUseInfiniteQueryResult<TData, OperationError<GetImageStatusApiV1ImageStatusImageIdGetError>>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getImageStatusApiV1ImageStatusImageIdGetTotal = qraft.apiService.getImageStatusApiV1ImageStatusImageIdGet.useIsFetching()
         * ```
         * @example Checks the number of normal queries fetching with the specified parameters.
         * ```ts
         * const getImageStatusApiV1ImageStatusImageIdGetByParametersTotal = qraft.apiService.getImageStatusApiV1ImageStatusImageIdGet.useIsFetching({
         *     infinite: false,
         *     parameters: {
         *         path: {
         *             image_id: imageId
         *         },
         *         cookie: {
         *             access_token: accessToken
         *         }
         *     }
         * })
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, TInfinite, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetError> | QueryFiltersByQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, TInfinite, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getImageStatusApiV1ImageStatusImageIdGetResults = qraft.apiService.getImageStatusApiV1ImageStatusImageIdGet.useQueries({
         *     queries: [
         *         {
         *             path: {
         *                 image_id: imageId1
         *             },
         *             cookie: {
         *                 access_token: accessToken1
         *             }
         *         },
         *         {
         *             path: {
         *                 image_id: imageId2
         *             },
         *             cookie: {
         *                 access_token: accessToken2
         *             }
         *         }
         *     ]
         * });
         * getImageStatusApiV1ImageStatusImageIdGetResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getImageStatusApiV1ImageStatusImageIdGetCombinedResults = qraft.apiService.getImageStatusApiV1ImageStatusImageIdGet.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             path: {
         *                 image_id: imageId1
         *             },
         *             cookie: {
         *                 access_token: accessToken1
         *             }
         *         },
         *         {
         *             path: {
         *                 image_id: imageId2
         *             },
         *             cookie: {
         *                 access_token: accessToken2
         *             }
         *         }
         *     ]
         * });
         * getImageStatusApiV1ImageStatusImageIdGetCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetError>>, TCombinedResult = Array<UseQueryResult<GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetError>>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * Performs asynchronous data fetching with Suspense support.
         * Similar to useQuery but integrates with React Suspense for loading states.
         *
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
         * @example Suspense Query with parameters
         * ```ts
         * const data = qraft.apiService.getImageStatusApiV1ImageStatusImageIdGet.useSuspenseQuery({
         *     path: {
         *         image_id: imageId
         *     },
         *     cookie: {
         *         access_token: accessToken
         *     }
         * })
         * ```
         */
        useSuspenseQuery<TData = GetImageStatusApiV1ImageStatusImageIdGetData>(parameters: ServiceOperationQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters> | (DeepReadonly<GetImageStatusApiV1ImageStatusImageIdGetParameters>), options?: Omit<UseSuspenseQueryOptions<GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetError, TData, ServiceOperationQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters>>, "queryKey">): UseSuspenseQueryResult<TData, OperationError<GetImageStatusApiV1ImageStatusImageIdGetError>>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.getImageStatusApiV1ImageStatusImageIdGet.useSuspenseInfiniteQuery({
         *     path: {
         *         image_id: imageId
         *     },
         *     cookie: {
         *         access_token: accessToken
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetImageStatusApiV1ImageStatusImageIdGetParameters, TData = GetImageStatusApiV1ImageStatusImageIdGetData>(parameters: ServiceOperationInfiniteQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters> | (DeepReadonly<GetImageStatusApiV1ImageStatusImageIdGetParameters>), options: Omit<UseSuspenseInfiniteQueryOptions<GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetError, OperationInfiniteData<TData, GetImageStatusApiV1ImageStatusImageIdGetParameters>, ServiceOperationInfiniteQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetImageStatusApiV1ImageStatusImageIdGetData, PartialParameters<DeepReadonly<TPageParam>>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetImageStatusApiV1ImageStatusImageIdGetParameters>, OperationError<GetImageStatusApiV1ImageStatusImageIdGetError>>;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
         * Similar to useQueries but integrates with React Suspense for loading states.
         *
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
         * @example Basic usage with Suspense
         * ```ts
         * const getImageStatusApiV1ImageStatusImageIdGetData = qraft.apiService.getImageStatusApiV1ImageStatusImageIdGet.useSuspenseQueries({
         *     queries: [
         *         {
         *             path: {
         *                 image_id: imageId1
         *             },
         *             cookie: {
         *                 access_token: accessToken1
         *             }
         *         },
         *         {
         *             path: {
         *                 image_id: imageId2
         *             },
         *             cookie: {
         *                 access_token: accessToken2
         *             }
         *         }
         *     ]
         * });
         * getImageStatusApiV1ImageStatusImageIdGetResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example With data transformation using combine
         * ```ts
         * const getImageStatusApiV1ImageStatusImageIdGetCombinedData = qraft.apiService.getImageStatusApiV1ImageStatusImageIdGet.useSuspenseQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             path: {
         *                 image_id: imageId1
         *             },
         *             cookie: {
         *                 access_token: accessToken1
         *             }
         *         },
         *         {
         *             path: {
         *                 image_id: imageId2
         *             },
         *             cookie: {
         *                 access_token: accessToken2
         *             }
         *         }
         *     ]
         * });
         * getImageStatusApiV1ImageStatusImageIdGetCombinedData.forEach(data => console.log({ data }));
         * ```
         */
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetError>): Promise<GetImageStatusApiV1ImageStatusImageIdGetData>;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetError>): Promise<void>;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetError>): Promise<GetImageStatusApiV1ImageStatusImageIdGetData>;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        fetchInfiniteQuery<TPageParam extends GetImageStatusApiV1ImageStatusImageIdGetParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetParameters, DeepReadonly<TPageParam>, GetImageStatusApiV1ImageStatusImageIdGetError>): Promise<OperationInfiniteData<GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetParameters>>;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        prefetchInfiniteQuery<TPageParam extends GetImageStatusApiV1ImageStatusImageIdGetParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetParameters, DeepReadonly<TPageParam>, GetImageStatusApiV1ImageStatusImageIdGetError>): Promise<void>;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        ensureInfiniteQueryData<TPageParam extends GetImageStatusApiV1ImageStatusImageIdGetParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetParameters, DeepReadonly<TPageParam>, GetImageStatusApiV1ImageStatusImageIdGetError>): Promise<OperationInfiniteData<GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetParameters>>;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        getQueryData(parameters: ServiceOperationQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters> | (DeepReadonly<GetImageStatusApiV1ImageStatusImageIdGetParameters>)): GetImageStatusApiV1ImageStatusImageIdGetData | undefined;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters> | (DeepReadonly<GetImageStatusApiV1ImageStatusImageIdGetParameters>)): OperationInfiniteData<GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetParameters> | undefined;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, TInfinite, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetError> | QueryFiltersByQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, TInfinite, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters>,
            data: NoInfer<OperationInfiniteData<GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters>,
            data: GetImageStatusApiV1ImageStatusImageIdGetData | undefined
        ]>;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        getQueryState(parameters: ServiceOperationQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters> | (DeepReadonly<GetImageStatusApiV1ImageStatusImageIdGetParameters>)): QueryState<GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetError> | undefined;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        getInfiniteQueryState(parameters: DeepReadonly<GetImageStatusApiV1ImageStatusImageIdGetParameters> | ServiceOperationInfiniteQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters>): QueryState<OperationInfiniteData<GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetParameters>, GetImageStatusApiV1ImageStatusImageIdGetError> | undefined;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        setQueryData(parameters: (DeepReadonly<GetImageStatusApiV1ImageStatusImageIdGetParameters>) | ServiceOperationQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters>, updater: Updater<NoInfer<GetImageStatusApiV1ImageStatusImageIdGetData> | undefined, NoInfer<DeepReadonly<GetImageStatusApiV1ImageStatusImageIdGetData>> | undefined>, options?: SetDataOptions): GetImageStatusApiV1ImageStatusImageIdGetData | undefined;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        setInfiniteQueryData(parameters: (DeepReadonly<GetImageStatusApiV1ImageStatusImageIdGetParameters>) | ServiceOperationInfiniteQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetParameters>> | undefined, NoInfer<DeepReadonly<OperationInfiniteData<GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetParameters>>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetParameters> | undefined;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, TInfinite, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetError> | QueryFiltersByQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, TInfinite, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetError>, updater: Updater<NoInfer<GetImageStatusApiV1ImageStatusImageIdGetData> | undefined, NoInfer<GetImageStatusApiV1ImageStatusImageIdGetData> | undefined>, options?: SetDataOptions): Array<GetImageStatusApiV1ImageStatusImageIdGetData | undefined>;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, TInfinite, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetError>, options?: InvalidateOptions): Promise<void>;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, TInfinite, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetError> | QueryFiltersByQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, TInfinite, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetError>, options?: RefetchOptions): Promise<void>;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, TInfinite, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetError> | QueryFiltersByQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, TInfinite, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetError>, options?: CancelOptions): Promise<void>;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, TInfinite, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetError> | QueryFiltersByQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, TInfinite, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetError>): void;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, TInfinite, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetError> | QueryFiltersByQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, TInfinite, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetError>, options?: ResetOptions): Promise<void>;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, TInfinite, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetError> | QueryFiltersByQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, TInfinite, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetError>): number;
        schema: GetImageStatusApiV1ImageStatusImageIdGetSchema;
        types: {
            parameters: GetImageStatusApiV1ImageStatusImageIdGetParameters;
            data: GetImageStatusApiV1ImageStatusImageIdGetData;
            error: GetImageStatusApiV1ImageStatusImageIdGetError;
        };
    };
    /**
     * @summary Get Image Styles
     * @description Retrieve all available hairstyles.
     *
     * Args:
     *     current_user (User): Authenticated user via dependency.
     *     db: Database session.
     *
     * Returns:
     *     List[StylesResponse]: List of available styles with metadata.
     */
    getImageStylesApiV1ImageStylesGet: {
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetImageStylesApiV1ImageStylesGetParameters, TMeta, TSignal> | void), client?: (schema: GetImageStylesApiV1ImageStylesGetSchema, options: {
            parameters: GetImageStylesApiV1ImageStylesGetParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetError>>): Promise<RequestFnResponse<GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetError>>;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        getQueryKey(parameters: DeepReadonly<GetImageStylesApiV1ImageStylesGetParameters> | void): ServiceOperationQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.apiService.getImageStylesApiV1ImageStylesGet.useQuery()
         * ```
         */
        useQuery<TData = GetImageStylesApiV1ImageStylesGetData>(parameters: ServiceOperationQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters> | (DeepReadonly<GetImageStylesApiV1ImageStylesGetParameters> | void), options?: Omit<UndefinedInitialDataOptions<GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetError, TData, ServiceOperationQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters>>, "queryKey">): UseQueryResult<TData, OperationError<GetImageStylesApiV1ImageStylesGetError>>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.apiService.getImageStylesApiV1ImageStylesGet.useQuery()
         * ```
         */
        useQuery<TData = GetImageStylesApiV1ImageStylesGetData>(parameters: ServiceOperationQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters> | (DeepReadonly<GetImageStylesApiV1ImageStylesGetParameters> | void), options: Omit<DefinedInitialDataOptions<GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetError, TData, ServiceOperationQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters>>, "queryKey">): DefinedUseQueryResult<TData, OperationError<GetImageStylesApiV1ImageStylesGetError>>;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        getInfiniteQueryKey(parameters: DeepReadonly<GetImageStylesApiV1ImageStylesGetParameters> | void): ServiceOperationInfiniteQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.getImageStylesApiV1ImageStylesGet.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetImageStylesApiV1ImageStylesGetParameters, TQueryFnData = GetImageStylesApiV1ImageStylesGetData, TData = OperationInfiniteData<TQueryFnData, GetImageStylesApiV1ImageStylesGetParameters>>(parameters: ServiceOperationInfiniteQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters> | (DeepReadonly<GetImageStylesApiV1ImageStylesGetParameters> | void), options: Omit<UndefinedInitialDataInfiniteOptions<TQueryFnData, GetImageStylesApiV1ImageStylesGetError, TData, ServiceOperationInfiniteQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>): UseInfiniteQueryResult<TData, OperationError<GetImageStylesApiV1ImageStylesGetError>>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.getImageStylesApiV1ImageStylesGet.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetImageStylesApiV1ImageStylesGetParameters, TQueryFnData = GetImageStylesApiV1ImageStylesGetData, TData = OperationInfiniteData<TQueryFnData, GetImageStylesApiV1ImageStylesGetParameters>>(parameters: ServiceOperationInfiniteQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters> | (DeepReadonly<GetImageStylesApiV1ImageStylesGetParameters> | void), options: Omit<DefinedInitialDataInfiniteOptions<TQueryFnData, GetImageStylesApiV1ImageStylesGetError, TData, ServiceOperationInfiniteQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetImageStylesApiV1ImageStylesGetData, PartialParameters<DeepReadonly<TPageParam>>>): DefinedUseInfiniteQueryResult<TData, OperationError<GetImageStylesApiV1ImageStylesGetError>>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getImageStylesApiV1ImageStylesGetTotal = qraft.apiService.getImageStylesApiV1ImageStylesGet.useIsFetching()
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, TInfinite, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetError> | QueryFiltersByQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, TInfinite, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getImageStylesApiV1ImageStylesGetResults = qraft.apiService.getImageStylesApiV1ImageStylesGet.useQueries({
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getImageStylesApiV1ImageStylesGetResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getImageStylesApiV1ImageStylesGetCombinedResults = qraft.apiService.getImageStylesApiV1ImageStylesGet.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getImageStylesApiV1ImageStylesGetCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetError>>, TCombinedResult = Array<UseQueryResult<GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetError>>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * Performs asynchronous data fetching with Suspense support.
         * Similar to useQuery but integrates with React Suspense for loading states.
         *
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
         * @example Suspense Query without parameters
         * ```ts
         * const data = qraft.apiService.getImageStylesApiV1ImageStylesGet.useSuspenseQuery()
         * ```
         */
        useSuspenseQuery<TData = GetImageStylesApiV1ImageStylesGetData>(parameters: ServiceOperationQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters> | (DeepReadonly<GetImageStylesApiV1ImageStylesGetParameters> | void), options?: Omit<UseSuspenseQueryOptions<GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetError, TData, ServiceOperationQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters>>, "queryKey">): UseSuspenseQueryResult<TData, OperationError<GetImageStylesApiV1ImageStylesGetError>>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.getImageStylesApiV1ImageStylesGet.useSuspenseInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetImageStylesApiV1ImageStylesGetParameters, TData = GetImageStylesApiV1ImageStylesGetData>(parameters: ServiceOperationInfiniteQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters> | (DeepReadonly<GetImageStylesApiV1ImageStylesGetParameters> | void), options: Omit<UseSuspenseInfiniteQueryOptions<GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetError, OperationInfiniteData<TData, GetImageStylesApiV1ImageStylesGetParameters>, ServiceOperationInfiniteQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetImageStylesApiV1ImageStylesGetData, PartialParameters<DeepReadonly<TPageParam>>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetImageStylesApiV1ImageStylesGetParameters>, OperationError<GetImageStylesApiV1ImageStylesGetError>>;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
         * Similar to useQueries but integrates with React Suspense for loading states.
         *
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
         * @example Basic usage with Suspense
         * ```ts
         * const getImageStylesApiV1ImageStylesGetData = qraft.apiService.getImageStylesApiV1ImageStylesGet.useSuspenseQueries({
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getImageStylesApiV1ImageStylesGetResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example With data transformation using combine
         * ```ts
         * const getImageStylesApiV1ImageStylesGetCombinedData = qraft.apiService.getImageStylesApiV1ImageStylesGet.useSuspenseQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getImageStylesApiV1ImageStylesGetCombinedData.forEach(data => console.log({ data }));
         * ```
         */
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetError> | void): Promise<GetImageStylesApiV1ImageStylesGetData>;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetError> | void): Promise<void>;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetError> | void): Promise<GetImageStylesApiV1ImageStylesGetData>;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        fetchInfiniteQuery<TPageParam extends GetImageStylesApiV1ImageStylesGetParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetParameters, DeepReadonly<TPageParam>, GetImageStylesApiV1ImageStylesGetError> | void): Promise<OperationInfiniteData<GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetParameters>>;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        prefetchInfiniteQuery<TPageParam extends GetImageStylesApiV1ImageStylesGetParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetParameters, DeepReadonly<TPageParam>, GetImageStylesApiV1ImageStylesGetError> | void): Promise<void>;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        ensureInfiniteQueryData<TPageParam extends GetImageStylesApiV1ImageStylesGetParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetParameters, DeepReadonly<TPageParam>, GetImageStylesApiV1ImageStylesGetError> | void): Promise<OperationInfiniteData<GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetParameters>>;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        getQueryData(parameters: ServiceOperationQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters> | (DeepReadonly<GetImageStylesApiV1ImageStylesGetParameters> | void)): GetImageStylesApiV1ImageStylesGetData | undefined;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters> | (DeepReadonly<GetImageStylesApiV1ImageStylesGetParameters> | void)): OperationInfiniteData<GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetParameters> | undefined;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, TInfinite, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetError> | QueryFiltersByQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, TInfinite, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters>,
            data: NoInfer<OperationInfiniteData<GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters>,
            data: GetImageStylesApiV1ImageStylesGetData | undefined
        ]>;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        getQueryState(parameters: ServiceOperationQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters> | (DeepReadonly<GetImageStylesApiV1ImageStylesGetParameters> | void)): QueryState<GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetError> | undefined;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        getInfiniteQueryState(parameters: DeepReadonly<GetImageStylesApiV1ImageStylesGetParameters> | ServiceOperationInfiniteQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters> | void): QueryState<OperationInfiniteData<GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetParameters>, GetImageStylesApiV1ImageStylesGetError> | undefined;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        setQueryData(parameters: (DeepReadonly<GetImageStylesApiV1ImageStylesGetParameters> | undefined) | ServiceOperationQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters>, updater: Updater<NoInfer<GetImageStylesApiV1ImageStylesGetData> | undefined, NoInfer<DeepReadonly<GetImageStylesApiV1ImageStylesGetData>> | undefined>, options?: SetDataOptions): GetImageStylesApiV1ImageStylesGetData | undefined;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        setInfiniteQueryData(parameters: (DeepReadonly<GetImageStylesApiV1ImageStylesGetParameters> | undefined) | ServiceOperationInfiniteQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetParameters>> | undefined, NoInfer<DeepReadonly<OperationInfiniteData<GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetParameters>>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetParameters> | undefined;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, TInfinite, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetError> | QueryFiltersByQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, TInfinite, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetError>, updater: Updater<NoInfer<GetImageStylesApiV1ImageStylesGetData> | undefined, NoInfer<GetImageStylesApiV1ImageStylesGetData> | undefined>, options?: SetDataOptions): Array<GetImageStylesApiV1ImageStylesGetData | undefined>;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, TInfinite, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetError>, options?: InvalidateOptions): Promise<void>;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, TInfinite, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetError> | QueryFiltersByQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, TInfinite, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetError>, options?: RefetchOptions): Promise<void>;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, TInfinite, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetError> | QueryFiltersByQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, TInfinite, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetError>, options?: CancelOptions): Promise<void>;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, TInfinite, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetError> | QueryFiltersByQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, TInfinite, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetError>): void;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, TInfinite, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetError> | QueryFiltersByQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, TInfinite, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetError>, options?: ResetOptions): Promise<void>;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, TInfinite, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetError> | QueryFiltersByQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, TInfinite, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetError>): number;
        schema: GetImageStylesApiV1ImageStylesGetSchema;
        types: {
            parameters: GetImageStylesApiV1ImageStylesGetParameters;
            data: GetImageStylesApiV1ImageStylesGetData;
            error: GetImageStylesApiV1ImageStylesGetError;
        };
    };
    /**
     * @summary Like Image
     * @description Like an image generation record.
     *
     * Args:
     *     image_id (int): ID of the image generation record.
     *     current_user (User): Authenticated user via dependency.
     *     db: Database session.
     *
     * Returns:
     *     bool: True if liked successfully, False otherwise.
     *
     * Raises:
     *     HTTPException: If image not found or doesn't belong to user.
     */
    likeImageApiV1ImageLikeImageIdPost: {
        /**
         * @summary Like Image
         * @description Like an image generation record.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     bool: True if liked successfully, False otherwise.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: ServiceOperationMutationFnOptions<LikeImageApiV1ImageLikeImageIdPostBody, LikeImageApiV1ImageLikeImageIdPostParameters, TMeta, TSignal>, client?: (schema: LikeImageApiV1ImageLikeImageIdPostSchema, options: ServiceOperationMutationFnOptions<LikeImageApiV1ImageLikeImageIdPostBody, LikeImageApiV1ImageLikeImageIdPostParameters, TMeta, TSignal>) => Promise<RequestFnResponse<LikeImageApiV1ImageLikeImageIdPostData, LikeImageApiV1ImageLikeImageIdPostError>>): Promise<RequestFnResponse<LikeImageApiV1ImageLikeImageIdPostData, LikeImageApiV1ImageLikeImageIdPostError>>;
        /**
         * @summary Like Image
         * @description Like an image generation record.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     bool: True if liked successfully, False otherwise.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        getMutationKey(parameters: DeepReadonly<LikeImageApiV1ImageLikeImageIdPostParameters> | void): ServiceOperationMutationKey<LikeImageApiV1ImageLikeImageIdPostSchema, LikeImageApiV1ImageLikeImageIdPostParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Like Image
         * @description Like an image generation record.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     bool: True if liked successfully, False otherwise.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.likeImageApiV1ImageLikeImageIdPost.useMutation({
         *     path: {
         *         image_id: imageId
         *     },
         *     cookie: {
         *         access_token: accessToken
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.likeImageApiV1ImageLikeImageIdPost.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         image_id: imageId
         *     },
         *     cookie: {
         *         access_token: accessToken
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends LikeImageApiV1ImageLikeImageIdPostBody, TContext = unknown>(parameters: DeepReadonly<LikeImageApiV1ImageLikeImageIdPostParameters>, options?: ServiceOperationUseMutationOptions<LikeImageApiV1ImageLikeImageIdPostSchema, LikeImageApiV1ImageLikeImageIdPostData, LikeImageApiV1ImageLikeImageIdPostParameters, TVariables, OperationError<LikeImageApiV1ImageLikeImageIdPostError>, TContext>): UseMutationResult<LikeImageApiV1ImageLikeImageIdPostData, OperationError<LikeImageApiV1ImageLikeImageIdPostError>, TVariables | void, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Like Image
         * @description Like an image generation record.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     bool: True if liked successfully, False otherwise.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.likeImageApiV1ImageLikeImageIdPost.useMutation({
         *     path: {
         *         image_id: imageId
         *     },
         *     cookie: {
         *         access_token: accessToken
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.likeImageApiV1ImageLikeImageIdPost.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         image_id: imageId
         *     },
         *     cookie: {
         *         access_token: accessToken
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<LikeImageApiV1ImageLikeImageIdPostBody, LikeImageApiV1ImageLikeImageIdPostParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<LikeImageApiV1ImageLikeImageIdPostSchema, LikeImageApiV1ImageLikeImageIdPostData, LikeImageApiV1ImageLikeImageIdPostParameters, TVariables, OperationError<LikeImageApiV1ImageLikeImageIdPostError>, TContext>): UseMutationResult<LikeImageApiV1ImageLikeImageIdPostData, OperationError<LikeImageApiV1ImageLikeImageIdPostError>, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @summary Like Image
         * @description Like an image generation record.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     bool: True if liked successfully, False otherwise.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const likeImageApiV1ImageLikeImageIdPostTotal = qraft.apiService.likeImageApiV1ImageLikeImageIdPost.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const likeImageApiV1ImageLikeImageIdPostTotal = qraft.apiService.likeImageApiV1ImageLikeImageIdPost.useIsMutating({
         *     parameters: {
         *         path: {
         *             image_id: imageId
         *         },
         *         cookie: {
         *             access_token: accessToken
         *         }
         *     }
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<LikeImageApiV1ImageLikeImageIdPostBody, LikeImageApiV1ImageLikeImageIdPostData, LikeImageApiV1ImageLikeImageIdPostParameters, OperationError<LikeImageApiV1ImageLikeImageIdPostError>, TContext> | MutationFiltersByMutationKey<LikeImageApiV1ImageLikeImageIdPostSchema, LikeImageApiV1ImageLikeImageIdPostBody, LikeImageApiV1ImageLikeImageIdPostData, LikeImageApiV1ImageLikeImageIdPostParameters, OperationError<LikeImageApiV1ImageLikeImageIdPostError>, TContext>): number;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @summary Like Image
         * @description Like an image generation record.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     bool: True if liked successfully, False otherwise.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const likeImageApiV1ImageLikeImageIdPostPendingMutationVariables = qraft.apiService.likeImageApiV1ImageLikeImageIdPost.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const likeImageApiV1ImageLikeImageIdPostMutationData = qraft.apiService.likeImageApiV1ImageLikeImageIdPost.useMutationState({
         *     filters: {
         *         parameters: {
         *             path: {
         *                 image_id: imageId
         *             },
         *             cookie: {
         *                 access_token: accessToken
         *             }
         *         }
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<LikeImageApiV1ImageLikeImageIdPostData, OperationError<LikeImageApiV1ImageLikeImageIdPostError>, MutationVariables<LikeImageApiV1ImageLikeImageIdPostBody, LikeImageApiV1ImageLikeImageIdPostParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<LikeImageApiV1ImageLikeImageIdPostBody, LikeImageApiV1ImageLikeImageIdPostData, LikeImageApiV1ImageLikeImageIdPostParameters, OperationError<LikeImageApiV1ImageLikeImageIdPostError>, TContext> | MutationFiltersByMutationKey<LikeImageApiV1ImageLikeImageIdPostSchema, LikeImageApiV1ImageLikeImageIdPostBody, LikeImageApiV1ImageLikeImageIdPostData, LikeImageApiV1ImageLikeImageIdPostParameters, OperationError<LikeImageApiV1ImageLikeImageIdPostError>, TContext>;
            select?: (mutation: Mutation<LikeImageApiV1ImageLikeImageIdPostData, OperationError<LikeImageApiV1ImageLikeImageIdPostError>, MutationVariables<LikeImageApiV1ImageLikeImageIdPostBody, LikeImageApiV1ImageLikeImageIdPostParameters>, TContext>) => TResult;
        }): Array<TResult>;
        /**
         * @summary Like Image
         * @description Like an image generation record.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     bool: True if liked successfully, False otherwise.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        isMutating<TContext>(filters?: MutationFiltersByParameters<LikeImageApiV1ImageLikeImageIdPostBody, LikeImageApiV1ImageLikeImageIdPostData, LikeImageApiV1ImageLikeImageIdPostParameters, OperationError<LikeImageApiV1ImageLikeImageIdPostError>, TContext> | MutationFiltersByMutationKey<LikeImageApiV1ImageLikeImageIdPostSchema, LikeImageApiV1ImageLikeImageIdPostBody, LikeImageApiV1ImageLikeImageIdPostData, LikeImageApiV1ImageLikeImageIdPostParameters, OperationError<LikeImageApiV1ImageLikeImageIdPostError>, TContext>): number;
        /**
         * Returns a `MutationCache` object that provides access to mutation cache operations
         * for the specific endpoint.
         *
         * @summary Like Image
         * @description Like an image generation record.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     bool: True if liked successfully, False otherwise.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/query-client/getMutationCache|`getMutationCache(...)` documentation}
         *
         * @example Find a mutation with specific parameters
         * ```ts
         * const mutationCache = qraft.apiService.likeImageApiV1ImageLikeImageIdPost.getMutationCache();
         * const mutation = mutationCache.find({
         *     parameters: {
         *         path: {
         *             image_id: imageId
         *         },
         *         cookie: {
         *             access_token: accessToken
         *         }
         *     }
         * });
         * ```
         *
         * @example Find all mutations for the endpoint
         * ```ts
         * const mutationCache = qraft.apiService.likeImageApiV1ImageLikeImageIdPost.getMutationCache();
         * const mutations = mutationCache.findAll();
         * ```
         */
        getMutationCache(): Omit<MutationCache, "find" | "findAll"> & {
            find<TContext = unknown>(filters: MutationFiltersByParameters<LikeImageApiV1ImageLikeImageIdPostBody, LikeImageApiV1ImageLikeImageIdPostData, LikeImageApiV1ImageLikeImageIdPostParameters, OperationError<LikeImageApiV1ImageLikeImageIdPostError>, TContext> | MutationFiltersByMutationKey<LikeImageApiV1ImageLikeImageIdPostSchema, LikeImageApiV1ImageLikeImageIdPostBody, LikeImageApiV1ImageLikeImageIdPostData, LikeImageApiV1ImageLikeImageIdPostParameters, OperationError<LikeImageApiV1ImageLikeImageIdPostError>, TContext>): Mutation<LikeImageApiV1ImageLikeImageIdPostData, LikeImageApiV1ImageLikeImageIdPostError, MutationVariables<LikeImageApiV1ImageLikeImageIdPostBody, LikeImageApiV1ImageLikeImageIdPostParameters>, TContext> | undefined;
            findAll<TContext = unknown>(filters?: MutationFiltersByParameters<LikeImageApiV1ImageLikeImageIdPostBody, LikeImageApiV1ImageLikeImageIdPostData, LikeImageApiV1ImageLikeImageIdPostParameters, OperationError<LikeImageApiV1ImageLikeImageIdPostError>, TContext> | MutationFiltersByMutationKey<LikeImageApiV1ImageLikeImageIdPostSchema, LikeImageApiV1ImageLikeImageIdPostBody, LikeImageApiV1ImageLikeImageIdPostData, LikeImageApiV1ImageLikeImageIdPostParameters, OperationError<LikeImageApiV1ImageLikeImageIdPostError>, TContext>): Array<Mutation<LikeImageApiV1ImageLikeImageIdPostData, LikeImageApiV1ImageLikeImageIdPostError, MutationVariables<LikeImageApiV1ImageLikeImageIdPostBody, LikeImageApiV1ImageLikeImageIdPostParameters>, TContext>>;
        };
        schema: LikeImageApiV1ImageLikeImageIdPostSchema;
        types: {
            parameters: LikeImageApiV1ImageLikeImageIdPostParameters;
            data: LikeImageApiV1ImageLikeImageIdPostData;
            error: LikeImageApiV1ImageLikeImageIdPostError;
            body: LikeImageApiV1ImageLikeImageIdPostBody;
        };
    };
    /**
     * @summary Dislike Image
     * @description Dislike an image generation record.
     *
     * Args:
     *     image_id (int): ID of the image generation record.
     *     current_user (User): Authenticated user via dependency.
     *     db: Database session.
     *
     * Returns:
     *     bool: True if disliked successfully, False otherwise.
     *
     * Raises:
     *     HTTPException: If image not found or doesn't belong to user.
     */
    dislikeImageApiV1ImageDislikeImageIdPost: {
        /**
         * @summary Dislike Image
         * @description Dislike an image generation record.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     bool: True if disliked successfully, False otherwise.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: ServiceOperationMutationFnOptions<DislikeImageApiV1ImageDislikeImageIdPostBody, DislikeImageApiV1ImageDislikeImageIdPostParameters, TMeta, TSignal>, client?: (schema: DislikeImageApiV1ImageDislikeImageIdPostSchema, options: ServiceOperationMutationFnOptions<DislikeImageApiV1ImageDislikeImageIdPostBody, DislikeImageApiV1ImageDislikeImageIdPostParameters, TMeta, TSignal>) => Promise<RequestFnResponse<DislikeImageApiV1ImageDislikeImageIdPostData, DislikeImageApiV1ImageDislikeImageIdPostError>>): Promise<RequestFnResponse<DislikeImageApiV1ImageDislikeImageIdPostData, DislikeImageApiV1ImageDislikeImageIdPostError>>;
        /**
         * @summary Dislike Image
         * @description Dislike an image generation record.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     bool: True if disliked successfully, False otherwise.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        getMutationKey(parameters: DeepReadonly<DislikeImageApiV1ImageDislikeImageIdPostParameters> | void): ServiceOperationMutationKey<DislikeImageApiV1ImageDislikeImageIdPostSchema, DislikeImageApiV1ImageDislikeImageIdPostParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Dislike Image
         * @description Dislike an image generation record.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     bool: True if disliked successfully, False otherwise.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.dislikeImageApiV1ImageDislikeImageIdPost.useMutation({
         *     path: {
         *         image_id: imageId
         *     },
         *     cookie: {
         *         access_token: accessToken
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.dislikeImageApiV1ImageDislikeImageIdPost.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         image_id: imageId
         *     },
         *     cookie: {
         *         access_token: accessToken
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends DislikeImageApiV1ImageDislikeImageIdPostBody, TContext = unknown>(parameters: DeepReadonly<DislikeImageApiV1ImageDislikeImageIdPostParameters>, options?: ServiceOperationUseMutationOptions<DislikeImageApiV1ImageDislikeImageIdPostSchema, DislikeImageApiV1ImageDislikeImageIdPostData, DislikeImageApiV1ImageDislikeImageIdPostParameters, TVariables, OperationError<DislikeImageApiV1ImageDislikeImageIdPostError>, TContext>): UseMutationResult<DislikeImageApiV1ImageDislikeImageIdPostData, OperationError<DislikeImageApiV1ImageDislikeImageIdPostError>, TVariables | void, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Dislike Image
         * @description Dislike an image generation record.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     bool: True if disliked successfully, False otherwise.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.dislikeImageApiV1ImageDislikeImageIdPost.useMutation({
         *     path: {
         *         image_id: imageId
         *     },
         *     cookie: {
         *         access_token: accessToken
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.dislikeImageApiV1ImageDislikeImageIdPost.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         image_id: imageId
         *     },
         *     cookie: {
         *         access_token: accessToken
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<DislikeImageApiV1ImageDislikeImageIdPostBody, DislikeImageApiV1ImageDislikeImageIdPostParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<DislikeImageApiV1ImageDislikeImageIdPostSchema, DislikeImageApiV1ImageDislikeImageIdPostData, DislikeImageApiV1ImageDislikeImageIdPostParameters, TVariables, OperationError<DislikeImageApiV1ImageDislikeImageIdPostError>, TContext>): UseMutationResult<DislikeImageApiV1ImageDislikeImageIdPostData, OperationError<DislikeImageApiV1ImageDislikeImageIdPostError>, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @summary Dislike Image
         * @description Dislike an image generation record.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     bool: True if disliked successfully, False otherwise.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const dislikeImageApiV1ImageDislikeImageIdPostTotal = qraft.apiService.dislikeImageApiV1ImageDislikeImageIdPost.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const dislikeImageApiV1ImageDislikeImageIdPostTotal = qraft.apiService.dislikeImageApiV1ImageDislikeImageIdPost.useIsMutating({
         *     parameters: {
         *         path: {
         *             image_id: imageId
         *         },
         *         cookie: {
         *             access_token: accessToken
         *         }
         *     }
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<DislikeImageApiV1ImageDislikeImageIdPostBody, DislikeImageApiV1ImageDislikeImageIdPostData, DislikeImageApiV1ImageDislikeImageIdPostParameters, OperationError<DislikeImageApiV1ImageDislikeImageIdPostError>, TContext> | MutationFiltersByMutationKey<DislikeImageApiV1ImageDislikeImageIdPostSchema, DislikeImageApiV1ImageDislikeImageIdPostBody, DislikeImageApiV1ImageDislikeImageIdPostData, DislikeImageApiV1ImageDislikeImageIdPostParameters, OperationError<DislikeImageApiV1ImageDislikeImageIdPostError>, TContext>): number;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @summary Dislike Image
         * @description Dislike an image generation record.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     bool: True if disliked successfully, False otherwise.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const dislikeImageApiV1ImageDislikeImageIdPostPendingMutationVariables = qraft.apiService.dislikeImageApiV1ImageDislikeImageIdPost.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const dislikeImageApiV1ImageDislikeImageIdPostMutationData = qraft.apiService.dislikeImageApiV1ImageDislikeImageIdPost.useMutationState({
         *     filters: {
         *         parameters: {
         *             path: {
         *                 image_id: imageId
         *             },
         *             cookie: {
         *                 access_token: accessToken
         *             }
         *         }
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<DislikeImageApiV1ImageDislikeImageIdPostData, OperationError<DislikeImageApiV1ImageDislikeImageIdPostError>, MutationVariables<DislikeImageApiV1ImageDislikeImageIdPostBody, DislikeImageApiV1ImageDislikeImageIdPostParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<DislikeImageApiV1ImageDislikeImageIdPostBody, DislikeImageApiV1ImageDislikeImageIdPostData, DislikeImageApiV1ImageDislikeImageIdPostParameters, OperationError<DislikeImageApiV1ImageDislikeImageIdPostError>, TContext> | MutationFiltersByMutationKey<DislikeImageApiV1ImageDislikeImageIdPostSchema, DislikeImageApiV1ImageDislikeImageIdPostBody, DislikeImageApiV1ImageDislikeImageIdPostData, DislikeImageApiV1ImageDislikeImageIdPostParameters, OperationError<DislikeImageApiV1ImageDislikeImageIdPostError>, TContext>;
            select?: (mutation: Mutation<DislikeImageApiV1ImageDislikeImageIdPostData, OperationError<DislikeImageApiV1ImageDislikeImageIdPostError>, MutationVariables<DislikeImageApiV1ImageDislikeImageIdPostBody, DislikeImageApiV1ImageDislikeImageIdPostParameters>, TContext>) => TResult;
        }): Array<TResult>;
        /**
         * @summary Dislike Image
         * @description Dislike an image generation record.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     bool: True if disliked successfully, False otherwise.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        isMutating<TContext>(filters?: MutationFiltersByParameters<DislikeImageApiV1ImageDislikeImageIdPostBody, DislikeImageApiV1ImageDislikeImageIdPostData, DislikeImageApiV1ImageDislikeImageIdPostParameters, OperationError<DislikeImageApiV1ImageDislikeImageIdPostError>, TContext> | MutationFiltersByMutationKey<DislikeImageApiV1ImageDislikeImageIdPostSchema, DislikeImageApiV1ImageDislikeImageIdPostBody, DislikeImageApiV1ImageDislikeImageIdPostData, DislikeImageApiV1ImageDislikeImageIdPostParameters, OperationError<DislikeImageApiV1ImageDislikeImageIdPostError>, TContext>): number;
        /**
         * Returns a `MutationCache` object that provides access to mutation cache operations
         * for the specific endpoint.
         *
         * @summary Dislike Image
         * @description Dislike an image generation record.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     bool: True if disliked successfully, False otherwise.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/query-client/getMutationCache|`getMutationCache(...)` documentation}
         *
         * @example Find a mutation with specific parameters
         * ```ts
         * const mutationCache = qraft.apiService.dislikeImageApiV1ImageDislikeImageIdPost.getMutationCache();
         * const mutation = mutationCache.find({
         *     parameters: {
         *         path: {
         *             image_id: imageId
         *         },
         *         cookie: {
         *             access_token: accessToken
         *         }
         *     }
         * });
         * ```
         *
         * @example Find all mutations for the endpoint
         * ```ts
         * const mutationCache = qraft.apiService.dislikeImageApiV1ImageDislikeImageIdPost.getMutationCache();
         * const mutations = mutationCache.findAll();
         * ```
         */
        getMutationCache(): Omit<MutationCache, "find" | "findAll"> & {
            find<TContext = unknown>(filters: MutationFiltersByParameters<DislikeImageApiV1ImageDislikeImageIdPostBody, DislikeImageApiV1ImageDislikeImageIdPostData, DislikeImageApiV1ImageDislikeImageIdPostParameters, OperationError<DislikeImageApiV1ImageDislikeImageIdPostError>, TContext> | MutationFiltersByMutationKey<DislikeImageApiV1ImageDislikeImageIdPostSchema, DislikeImageApiV1ImageDislikeImageIdPostBody, DislikeImageApiV1ImageDislikeImageIdPostData, DislikeImageApiV1ImageDislikeImageIdPostParameters, OperationError<DislikeImageApiV1ImageDislikeImageIdPostError>, TContext>): Mutation<DislikeImageApiV1ImageDislikeImageIdPostData, DislikeImageApiV1ImageDislikeImageIdPostError, MutationVariables<DislikeImageApiV1ImageDislikeImageIdPostBody, DislikeImageApiV1ImageDislikeImageIdPostParameters>, TContext> | undefined;
            findAll<TContext = unknown>(filters?: MutationFiltersByParameters<DislikeImageApiV1ImageDislikeImageIdPostBody, DislikeImageApiV1ImageDislikeImageIdPostData, DislikeImageApiV1ImageDislikeImageIdPostParameters, OperationError<DislikeImageApiV1ImageDislikeImageIdPostError>, TContext> | MutationFiltersByMutationKey<DislikeImageApiV1ImageDislikeImageIdPostSchema, DislikeImageApiV1ImageDislikeImageIdPostBody, DislikeImageApiV1ImageDislikeImageIdPostData, DislikeImageApiV1ImageDislikeImageIdPostParameters, OperationError<DislikeImageApiV1ImageDislikeImageIdPostError>, TContext>): Array<Mutation<DislikeImageApiV1ImageDislikeImageIdPostData, DislikeImageApiV1ImageDislikeImageIdPostError, MutationVariables<DislikeImageApiV1ImageDislikeImageIdPostBody, DislikeImageApiV1ImageDislikeImageIdPostParameters>, TContext>>;
        };
        schema: DislikeImageApiV1ImageDislikeImageIdPostSchema;
        types: {
            parameters: DislikeImageApiV1ImageDislikeImageIdPostParameters;
            data: DislikeImageApiV1ImageDislikeImageIdPostData;
            error: DislikeImageApiV1ImageDislikeImageIdPostError;
            body: DislikeImageApiV1ImageDislikeImageIdPostBody;
        };
    };
}
/**
 * @summary Signup
 * @description Register a new user account.
 *
 * Args:
 *     request (SignupRequest): User registration details including email, password, and name.
 *     db (Session): Database session.
 *
 * Returns:
 *     SignupUserResponse: Created user information.
 *
 * Raises:
 *     HTTPException: If email is already registered.
 */
export const signupApiV1AuthSignupPost = {
    schema: {
        method: "post",
        url: "/api/v1/auth/signup",
        mediaType: ["application/json"]
    }
} as {
    schema: SignupApiV1AuthSignupPostSchema;
    [QraftServiceOperationsToken]: ApiService["signupApiV1AuthSignupPost"];
};
/**
 * @summary Request Signup Token
 * @description Request a new signup verification token.
 *
 * Args:
 *     payload (RequestSignupTokenRequest): Request containing the user's email.
 *     db (Session): Database session.
 *
 * Returns:
 *     RequestSignupTokenResponse: New signup verification token.
 */
export const requestSignupTokenApiV1AuthRequestSignupTokenPost = {
    schema: {
        method: "post",
        url: "/api/v1/auth/request-signup-token",
        mediaType: ["application/json"]
    }
} as {
    schema: RequestSignupTokenApiV1AuthRequestSignupTokenPostSchema;
    [QraftServiceOperationsToken]: ApiService["requestSignupTokenApiV1AuthRequestSignupTokenPost"];
};
/**
 * @summary Verify Signup
 * @description Verify user's email using the signup verification code.
 *
 * Args:
 *     payload (VerifyEmailRequest): JWT token containing the verification code.
 *     auth_service (AuthService): Authentication service.
 *
 * Returns:
 *     CommentResponse: Confirmation message about successful verification.
 *
 * Raises:
 *     HTTPException: If verification code is invalid.
 */
export const verifySignupApiV1AuthVerifySignupPost = {
    schema: {
        method: "post",
        url: "/api/v1/auth/verify-signup",
        mediaType: ["application/json"]
    }
} as {
    schema: VerifySignupApiV1AuthVerifySignupPostSchema;
    [QraftServiceOperationsToken]: ApiService["verifySignupApiV1AuthVerifySignupPost"];
};
/**
 * @summary Request Login Token
 * @description Request a new login verification token.
 *
 * Args:
 *     payload (RequestLoginTokenRequest): Request containing the user's email and password.
 *     db (Session): Database session.
 *
 * Returns:
 *     RequestLoginTokenResponse: New login verification token.
 */
export const requestLoginTokenApiV1AuthRequestLoginTokenPost = {
    schema: {
        method: "post",
        url: "/api/v1/auth/request-login-token",
        mediaType: ["application/json"]
    }
} as {
    schema: RequestLoginTokenApiV1AuthRequestLoginTokenPostSchema;
    [QraftServiceOperationsToken]: ApiService["requestLoginTokenApiV1AuthRequestLoginTokenPost"];
};
/**
 * @summary Verify Login
 * @description Verify user's email using the login verification code.
 *
 * Args:
 *     payload (VerifyLoginRequest): JWT token containing the verification code.
 *     auth_service (AuthService): Authentication service.
 *
 * Returns:
 *     VerifyLoginResponse: Response containing access token and verification status.
 *
 * Raises:
 *     HTTPException: If verification code is invalid.
 */
export const verifyLoginApiV1AuthVerifyLoginPost = {
    schema: {
        method: "post",
        url: "/api/v1/auth/verify-login",
        mediaType: ["application/json"]
    }
} as {
    schema: VerifyLoginApiV1AuthVerifyLoginPostSchema;
    [QraftServiceOperationsToken]: ApiService["verifyLoginApiV1AuthVerifyLoginPost"];
};
/**
 * @summary Logout
 * @description Logout user and clear cookies.
 *
 * Args:
 *     auth_service (AuthServiceDep): Authentication service.
 *
 * Returns:
 *     JSONResponse: JSON response with cookies cleared.
 */
export const logoutApiV1AuthLogoutPost = {
    schema: {
        method: "post",
        url: "/api/v1/auth/logout"
    }
} as {
    schema: LogoutApiV1AuthLogoutPostSchema;
    [QraftServiceOperationsToken]: ApiService["logoutApiV1AuthLogoutPost"];
};
/**
 * @summary Google Login
 * @description Initiate Google OAuth authentication flow.
 *
 * Args:
 *     request (Request): FastAPI request object.
 *
 * Returns:
 *     RedirectResponse: Redirect to Google OAuth consent screen.
 */
export const googleLoginApiV1AuthGoogleGet = {
    schema: {
        method: "get",
        url: "/api/v1/auth/google"
    }
} as {
    schema: GoogleLoginApiV1AuthGoogleGetSchema;
    [QraftServiceOperationsToken]: ApiService["googleLoginApiV1AuthGoogleGet"];
};
/**
 * @summary Google Auth
 * @description Handle Google OAuth callback and create user session.
 *
 * Args:
 *     request (Request): FastAPI request object containing OAuth callback data.
 *     db (Session): Database session.
 *
 * Returns:
 *     RedirectResponse: Redirect to frontend with access token.
 *
 * Raises:
 *     HTTPException: If Google authentication fails.
 */
export const googleAuthApiV1AuthGoogleCallbackGet = {
    schema: {
        method: "get",
        url: "/api/v1/auth/google/callback"
    }
} as {
    schema: GoogleAuthApiV1AuthGoogleCallbackGetSchema;
    [QraftServiceOperationsToken]: ApiService["googleAuthApiV1AuthGoogleCallbackGet"];
};
/**
 * @summary Forgot Password
 * @description Handles password reset requests.
 *
 * args:
 *     request (ForgotPasswordRequest): Request containing the user's email.
 *
 * Returns:
 *     dict: Confirmation message about password reset email.
 */
export const forgotPasswordApiV1AuthForgotPasswordPost = {
    schema: {
        method: "post",
        url: "/api/v1/auth/forgot-password",
        mediaType: ["application/json"]
    }
} as {
    schema: ForgotPasswordApiV1AuthForgotPasswordPostSchema;
    [QraftServiceOperationsToken]: ApiService["forgotPasswordApiV1AuthForgotPasswordPost"];
};
/**
 * @summary Verify Reset Token
 * @description Verify the validity of a password reset token.
 *
 * Args:
 *     request (VerifyResetTokenRequest): Request containing the reset token.
 *     auth_service (AuthService): Authentication service.
 * Returns:
 *     VerifyResetTokenResponse: Response indicating if the token is valid.
 */
export const verifyResetTokenApiV1AuthVerifyResetTokenPost = {
    schema: {
        method: "post",
        url: "/api/v1/auth/verify-reset-token",
        mediaType: ["application/json"]
    }
} as {
    schema: VerifyResetTokenApiV1AuthVerifyResetTokenPostSchema;
    [QraftServiceOperationsToken]: ApiService["verifyResetTokenApiV1AuthVerifyResetTokenPost"];
};
/**
 * @summary Reset Password
 * @description Reset user's password using a valid reset token.
 *
 * Args:
 *     request (ResetPasswordRequest): Request containing the reset token and new password.
 *     auth_service (AuthService): Authentication service.
 * Returns:
 *     dict: Confirmation message about successful password reset.
 */
export const resetPasswordApiV1AuthResetPasswordPost = {
    schema: {
        method: "post",
        url: "/api/v1/auth/reset-password",
        mediaType: ["application/json"]
    }
} as {
    schema: ResetPasswordApiV1AuthResetPasswordPostSchema;
    [QraftServiceOperationsToken]: ApiService["resetPasswordApiV1AuthResetPasswordPost"];
};
/**
 * @summary Check Email Status
 * @description Check if the email is verified.
 *
 * Args:
 *     payload (CheckEmailStatusRequest): Request containing the user's email.
 *     auth_service (AuthService): Authentication service.
 * Returns:
 *     CheckEmailStatusResponse: Response indicating if the email is verified.
 */
export const checkEmailStatusApiV1AuthCheckEmailStatusPost = {
    schema: {
        method: "post",
        url: "/api/v1/auth/check-email-status",
        mediaType: ["application/json"]
    }
} as {
    schema: CheckEmailStatusApiV1AuthCheckEmailStatusPostSchema;
    [QraftServiceOperationsToken]: ApiService["checkEmailStatusApiV1AuthCheckEmailStatusPost"];
};
/**
 * @summary Verify Code Token
 * @description Verify the validity of a signup/login verification token.
 *
 * Args:
 *     payload (VerifyCodeTokenRequest): JWT token containing the verification code.
 *
 * Returns:
 *     dict: Response indicating if the token is valid.
 */
export const verifyCodeTokenApiV1AuthVerifyCodeTokenPost = {
    schema: {
        method: "post",
        url: "/api/v1/auth/verify-code-token",
        mediaType: ["application/json"]
    }
} as {
    schema: VerifyCodeTokenApiV1AuthVerifyCodeTokenPostSchema;
    [QraftServiceOperationsToken]: ApiService["verifyCodeTokenApiV1AuthVerifyCodeTokenPost"];
};
/**
 * @summary Read Current User
 * @description Retrieve authenticated user profile.
 *
 * Args:
 *     current_user (User): Authenticated user via dependency.
 *
 * Returns:
 *     UserBase: Current user information.
 */
export const readCurrentUserApiV1UserMeGet = {
    schema: {
        method: "get",
        url: "/api/v1/user/me"
    }
} as {
    schema: ReadCurrentUserApiV1UserMeGetSchema;
    [QraftServiceOperationsToken]: ApiService["readCurrentUserApiV1UserMeGet"];
};
/**
 * @summary Get User Images
 * @description Retrieve user's generated images.
 *
 * Args:
 *     favourites (bool): If True, fetch only favourite images. Defaults to False.
 *     page (int): Page number for pagination. Defaults to 1.
 *     limit (int): Number of images per page. Defaults to 10.
 *     current_user (User): Authenticated user via dependency.
 *     db: Database session.
 */
export const getUserImagesApiV1UserImagesGet = {
    schema: {
        method: "get",
        url: "/api/v1/user/images"
    }
} as {
    schema: GetUserImagesApiV1UserImagesGetSchema;
    [QraftServiceOperationsToken]: ApiService["getUserImagesApiV1UserImagesGet"];
};
/**
 * @summary Get User Uploads
 * @description Retrieve URLs of user's uploaded images.
 *
 * Args:
 *     current_user (User): Authenticated user via dependency.
 *     db: Database session.
 *
 * Returns:
 *     List[HttpUrl]: List of URLs of uploaded images.
 */
export const getUserUploadsApiV1UserUploadsGet = {
    schema: {
        method: "get",
        url: "/api/v1/user/uploads"
    }
} as {
    schema: GetUserUploadsApiV1UserUploadsGetSchema;
    [QraftServiceOperationsToken]: ApiService["getUserUploadsApiV1UserUploadsGet"];
};
/**
 * @summary Get Presigned Url
 * @description Generate presigned URL for direct S3 upload.
 *
 * Args:
 *     file_name (str): Name of the file to upload.
 *     file_type (str): MIME type of the file.
 *     current_user (User): Authenticated user via dependency.
 *
 * Returns:
 *     ImageUploadResponse: Presigned URL and upload details.
 */
export const getPresignedUrlApiV1FilesPresignGet = {
    schema: {
        method: "get",
        url: "/api/v1/files/presign"
    }
} as {
    schema: GetPresignedUrlApiV1FilesPresignGetSchema;
    [QraftServiceOperationsToken]: ApiService["getPresignedUrlApiV1FilesPresignGet"];
};
/**
 * @summary Generate Image
 * @description Initiate an image generation request.
 *
 * Args:
 *     data (ImageGenRequest): User input including style ID and input image URL.
 *     background_tasks (BackgroundTasks): FastAPI background task handler.
 *     current_user (User): Authenticated user via dependency.
 *     db: Database session.
 *
 * Returns:
 *     ImageGenResponse: Contains image_id and confirmation message.
 *
 * Raises:
 *     HTTPException: If database record creation fails.
 */
export const generateImageApiV1ImageGeneratePost = {
    schema: {
        method: "post",
        url: "/api/v1/image/generate",
        mediaType: ["application/json"]
    }
} as {
    schema: GenerateImageApiV1ImageGeneratePostSchema;
    [QraftServiceOperationsToken]: ApiService["generateImageApiV1ImageGeneratePost"];
};
/**
 * @summary Get Image Status
 * @description Retrieve image generation status and results.
 *
 * Args:
 *     image_id (int): ID of the image generation record.
 *     current_user (User): Authenticated user via dependency.
 *     db: Database session.
 *
 * Returns:
 *     ImageGenStatusResponse: Status and output URL if completed.
 *
 * Raises:
 *     HTTPException: If image not found or doesn't belong to user.
 */
export const getImageStatusApiV1ImageStatusImageIdGet = {
    schema: {
        method: "get",
        url: "/api/v1/image/status/{image_id}"
    }
} as {
    schema: GetImageStatusApiV1ImageStatusImageIdGetSchema;
    [QraftServiceOperationsToken]: ApiService["getImageStatusApiV1ImageStatusImageIdGet"];
};
/**
 * @summary Get Image Styles
 * @description Retrieve all available hairstyles.
 *
 * Args:
 *     current_user (User): Authenticated user via dependency.
 *     db: Database session.
 *
 * Returns:
 *     List[StylesResponse]: List of available styles with metadata.
 */
export const getImageStylesApiV1ImageStylesGet = {
    schema: {
        method: "get",
        url: "/api/v1/image/styles"
    }
} as {
    schema: GetImageStylesApiV1ImageStylesGetSchema;
    [QraftServiceOperationsToken]: ApiService["getImageStylesApiV1ImageStylesGet"];
};
/**
 * @summary Like Image
 * @description Like an image generation record.
 *
 * Args:
 *     image_id (int): ID of the image generation record.
 *     current_user (User): Authenticated user via dependency.
 *     db: Database session.
 *
 * Returns:
 *     bool: True if liked successfully, False otherwise.
 *
 * Raises:
 *     HTTPException: If image not found or doesn't belong to user.
 */
export const likeImageApiV1ImageLikeImageIdPost = {
    schema: {
        method: "post",
        url: "/api/v1/image/like/{image_id}"
    }
} as {
    schema: LikeImageApiV1ImageLikeImageIdPostSchema;
    [QraftServiceOperationsToken]: ApiService["likeImageApiV1ImageLikeImageIdPost"];
};
/**
 * @summary Dislike Image
 * @description Dislike an image generation record.
 *
 * Args:
 *     image_id (int): ID of the image generation record.
 *     current_user (User): Authenticated user via dependency.
 *     db: Database session.
 *
 * Returns:
 *     bool: True if disliked successfully, False otherwise.
 *
 * Raises:
 *     HTTPException: If image not found or doesn't belong to user.
 */
export const dislikeImageApiV1ImageDislikeImageIdPost = {
    schema: {
        method: "post",
        url: "/api/v1/image/dislike/{image_id}"
    }
} as {
    schema: DislikeImageApiV1ImageDislikeImageIdPostSchema;
    [QraftServiceOperationsToken]: ApiService["dislikeImageApiV1ImageDislikeImageIdPost"];
};
export const apiService = {
    signupApiV1AuthSignupPost,
    requestSignupTokenApiV1AuthRequestSignupTokenPost,
    verifySignupApiV1AuthVerifySignupPost,
    requestLoginTokenApiV1AuthRequestLoginTokenPost,
    verifyLoginApiV1AuthVerifyLoginPost,
    logoutApiV1AuthLogoutPost,
    googleLoginApiV1AuthGoogleGet,
    googleAuthApiV1AuthGoogleCallbackGet,
    forgotPasswordApiV1AuthForgotPasswordPost,
    verifyResetTokenApiV1AuthVerifyResetTokenPost,
    resetPasswordApiV1AuthResetPasswordPost,
    checkEmailStatusApiV1AuthCheckEmailStatusPost,
    verifyCodeTokenApiV1AuthVerifyCodeTokenPost,
    readCurrentUserApiV1UserMeGet,
    getUserImagesApiV1UserImagesGet,
    getUserUploadsApiV1UserUploadsGet,
    getPresignedUrlApiV1FilesPresignGet,
    generateImageApiV1ImageGeneratePost,
    getImageStatusApiV1ImageStatusImageIdGet,
    getImageStylesApiV1ImageStylesGet,
    likeImageApiV1ImageLikeImageIdPost,
    dislikeImageApiV1ImageDislikeImageIdPost
} as const;
type SignupApiV1AuthSignupPostSchema = {
    method: "post";
    url: "/api/v1/auth/signup";
    mediaType: [
        "application/json"
    ];
};
type SignupApiV1AuthSignupPostParameters = {
    query?: never;
    header?: never;
    path?: never;
};
type SignupApiV1AuthSignupPostData = paths["/api/v1/auth/signup"]["post"]["responses"]["200"]["content"]["application/json"];
type SignupApiV1AuthSignupPostError = null | paths["/api/v1/auth/signup"]["post"]["responses"]["422"]["content"]["application/json"];
type SignupApiV1AuthSignupPostBody = paths["/api/v1/auth/signup"]["post"]["requestBody"]["content"]["application/json"];
type RequestSignupTokenApiV1AuthRequestSignupTokenPostSchema = {
    method: "post";
    url: "/api/v1/auth/request-signup-token";
    mediaType: [
        "application/json"
    ];
};
type RequestSignupTokenApiV1AuthRequestSignupTokenPostParameters = {
    query?: never;
    header?: never;
    path?: never;
};
type RequestSignupTokenApiV1AuthRequestSignupTokenPostData = paths["/api/v1/auth/request-signup-token"]["post"]["responses"]["200"]["content"]["application/json"];
type RequestSignupTokenApiV1AuthRequestSignupTokenPostError = null | null | paths["/api/v1/auth/request-signup-token"]["post"]["responses"]["422"]["content"]["application/json"];
type RequestSignupTokenApiV1AuthRequestSignupTokenPostBody = paths["/api/v1/auth/request-signup-token"]["post"]["requestBody"]["content"]["application/json"];
type VerifySignupApiV1AuthVerifySignupPostSchema = {
    method: "post";
    url: "/api/v1/auth/verify-signup";
    mediaType: [
        "application/json"
    ];
};
type VerifySignupApiV1AuthVerifySignupPostParameters = {
    query?: never;
    header?: never;
    path?: never;
};
type VerifySignupApiV1AuthVerifySignupPostData = paths["/api/v1/auth/verify-signup"]["post"]["responses"]["200"]["content"]["application/json"];
type VerifySignupApiV1AuthVerifySignupPostError = null | paths["/api/v1/auth/verify-signup"]["post"]["responses"]["422"]["content"]["application/json"];
type VerifySignupApiV1AuthVerifySignupPostBody = paths["/api/v1/auth/verify-signup"]["post"]["requestBody"]["content"]["application/json"];
type RequestLoginTokenApiV1AuthRequestLoginTokenPostSchema = {
    method: "post";
    url: "/api/v1/auth/request-login-token";
    mediaType: [
        "application/json"
    ];
};
type RequestLoginTokenApiV1AuthRequestLoginTokenPostParameters = {
    query?: never;
    header?: never;
    path?: never;
};
type RequestLoginTokenApiV1AuthRequestLoginTokenPostData = paths["/api/v1/auth/request-login-token"]["post"]["responses"]["200"]["content"]["application/json"];
type RequestLoginTokenApiV1AuthRequestLoginTokenPostError = null | null | paths["/api/v1/auth/request-login-token"]["post"]["responses"]["422"]["content"]["application/json"];
type RequestLoginTokenApiV1AuthRequestLoginTokenPostBody = paths["/api/v1/auth/request-login-token"]["post"]["requestBody"]["content"]["application/json"];
type VerifyLoginApiV1AuthVerifyLoginPostSchema = {
    method: "post";
    url: "/api/v1/auth/verify-login";
    mediaType: [
        "application/json"
    ];
};
type VerifyLoginApiV1AuthVerifyLoginPostParameters = {
    query?: never;
    header?: never;
    path?: never;
};
type VerifyLoginApiV1AuthVerifyLoginPostData = paths["/api/v1/auth/verify-login"]["post"]["responses"]["200"]["content"]["application/json"];
type VerifyLoginApiV1AuthVerifyLoginPostError = null | paths["/api/v1/auth/verify-login"]["post"]["responses"]["422"]["content"]["application/json"];
type VerifyLoginApiV1AuthVerifyLoginPostBody = paths["/api/v1/auth/verify-login"]["post"]["requestBody"]["content"]["application/json"];
type LogoutApiV1AuthLogoutPostSchema = {
    method: "post";
    url: "/api/v1/auth/logout";
};
type LogoutApiV1AuthLogoutPostParameters = {
    query?: never;
    header?: never;
    path?: never;
};
type LogoutApiV1AuthLogoutPostData = paths["/api/v1/auth/logout"]["post"]["responses"]["200"]["content"]["application/json"];
type LogoutApiV1AuthLogoutPostError = unknown;
type LogoutApiV1AuthLogoutPostBody = undefined;
type GoogleLoginApiV1AuthGoogleGetSchema = {
    method: "get";
    url: "/api/v1/auth/google";
};
type GoogleLoginApiV1AuthGoogleGetParameters = undefined;
type GoogleLoginApiV1AuthGoogleGetData = paths["/api/v1/auth/google"]["get"]["responses"]["200"]["content"]["application/json"];
type GoogleLoginApiV1AuthGoogleGetError = unknown;
type GoogleAuthApiV1AuthGoogleCallbackGetSchema = {
    method: "get";
    url: "/api/v1/auth/google/callback";
};
type GoogleAuthApiV1AuthGoogleCallbackGetParameters = undefined;
type GoogleAuthApiV1AuthGoogleCallbackGetData = paths["/api/v1/auth/google/callback"]["get"]["responses"]["200"]["content"]["application/json"];
type GoogleAuthApiV1AuthGoogleCallbackGetError = null;
type ForgotPasswordApiV1AuthForgotPasswordPostSchema = {
    method: "post";
    url: "/api/v1/auth/forgot-password";
    mediaType: [
        "application/json"
    ];
};
type ForgotPasswordApiV1AuthForgotPasswordPostParameters = {
    query?: never;
    header?: never;
    path?: never;
};
type ForgotPasswordApiV1AuthForgotPasswordPostData = paths["/api/v1/auth/forgot-password"]["post"]["responses"]["200"]["content"]["application/json"];
type ForgotPasswordApiV1AuthForgotPasswordPostError = paths["/api/v1/auth/forgot-password"]["post"]["responses"]["422"]["content"]["application/json"];
type ForgotPasswordApiV1AuthForgotPasswordPostBody = paths["/api/v1/auth/forgot-password"]["post"]["requestBody"]["content"]["application/json"];
type VerifyResetTokenApiV1AuthVerifyResetTokenPostSchema = {
    method: "post";
    url: "/api/v1/auth/verify-reset-token";
    mediaType: [
        "application/json"
    ];
};
type VerifyResetTokenApiV1AuthVerifyResetTokenPostParameters = {
    query?: never;
    header?: never;
    path?: never;
};
type VerifyResetTokenApiV1AuthVerifyResetTokenPostData = paths["/api/v1/auth/verify-reset-token"]["post"]["responses"]["200"]["content"]["application/json"];
type VerifyResetTokenApiV1AuthVerifyResetTokenPostError = paths["/api/v1/auth/verify-reset-token"]["post"]["responses"]["422"]["content"]["application/json"];
type VerifyResetTokenApiV1AuthVerifyResetTokenPostBody = paths["/api/v1/auth/verify-reset-token"]["post"]["requestBody"]["content"]["application/json"];
type ResetPasswordApiV1AuthResetPasswordPostSchema = {
    method: "post";
    url: "/api/v1/auth/reset-password";
    mediaType: [
        "application/json"
    ];
};
type ResetPasswordApiV1AuthResetPasswordPostParameters = {
    query?: never;
    header?: never;
    path?: never;
};
type ResetPasswordApiV1AuthResetPasswordPostData = paths["/api/v1/auth/reset-password"]["post"]["responses"]["200"]["content"]["application/json"];
type ResetPasswordApiV1AuthResetPasswordPostError = null | paths["/api/v1/auth/reset-password"]["post"]["responses"]["422"]["content"]["application/json"];
type ResetPasswordApiV1AuthResetPasswordPostBody = paths["/api/v1/auth/reset-password"]["post"]["requestBody"]["content"]["application/json"];
type CheckEmailStatusApiV1AuthCheckEmailStatusPostSchema = {
    method: "post";
    url: "/api/v1/auth/check-email-status";
    mediaType: [
        "application/json"
    ];
};
type CheckEmailStatusApiV1AuthCheckEmailStatusPostParameters = {
    query?: never;
    header?: never;
    path?: never;
};
type CheckEmailStatusApiV1AuthCheckEmailStatusPostData = paths["/api/v1/auth/check-email-status"]["post"]["responses"]["200"]["content"]["application/json"];
type CheckEmailStatusApiV1AuthCheckEmailStatusPostError = paths["/api/v1/auth/check-email-status"]["post"]["responses"]["422"]["content"]["application/json"];
type CheckEmailStatusApiV1AuthCheckEmailStatusPostBody = paths["/api/v1/auth/check-email-status"]["post"]["requestBody"]["content"]["application/json"];
type VerifyCodeTokenApiV1AuthVerifyCodeTokenPostSchema = {
    method: "post";
    url: "/api/v1/auth/verify-code-token";
    mediaType: [
        "application/json"
    ];
};
type VerifyCodeTokenApiV1AuthVerifyCodeTokenPostParameters = {
    query?: never;
    header?: never;
    path?: never;
};
type VerifyCodeTokenApiV1AuthVerifyCodeTokenPostData = paths["/api/v1/auth/verify-code-token"]["post"]["responses"]["200"]["content"]["application/json"];
type VerifyCodeTokenApiV1AuthVerifyCodeTokenPostError = null | paths["/api/v1/auth/verify-code-token"]["post"]["responses"]["422"]["content"]["application/json"];
type VerifyCodeTokenApiV1AuthVerifyCodeTokenPostBody = paths["/api/v1/auth/verify-code-token"]["post"]["requestBody"]["content"]["application/json"];
type ReadCurrentUserApiV1UserMeGetSchema = {
    method: "get";
    url: "/api/v1/user/me";
};
type ReadCurrentUserApiV1UserMeGetParameters = paths["/api/v1/user/me"]["get"]["parameters"];
type ReadCurrentUserApiV1UserMeGetData = paths["/api/v1/user/me"]["get"]["responses"]["200"]["content"]["application/json"];
type ReadCurrentUserApiV1UserMeGetError = paths["/api/v1/user/me"]["get"]["responses"]["422"]["content"]["application/json"];
type GetUserImagesApiV1UserImagesGetSchema = {
    method: "get";
    url: "/api/v1/user/images";
};
type GetUserImagesApiV1UserImagesGetParameters = paths["/api/v1/user/images"]["get"]["parameters"];
type GetUserImagesApiV1UserImagesGetData = paths["/api/v1/user/images"]["get"]["responses"]["200"]["content"]["application/json"];
type GetUserImagesApiV1UserImagesGetError = paths["/api/v1/user/images"]["get"]["responses"]["422"]["content"]["application/json"];
type GetUserUploadsApiV1UserUploadsGetSchema = {
    method: "get";
    url: "/api/v1/user/uploads";
};
type GetUserUploadsApiV1UserUploadsGetParameters = paths["/api/v1/user/uploads"]["get"]["parameters"];
type GetUserUploadsApiV1UserUploadsGetData = paths["/api/v1/user/uploads"]["get"]["responses"]["200"]["content"]["application/json"];
type GetUserUploadsApiV1UserUploadsGetError = paths["/api/v1/user/uploads"]["get"]["responses"]["422"]["content"]["application/json"];
type GetPresignedUrlApiV1FilesPresignGetSchema = {
    method: "get";
    url: "/api/v1/files/presign";
};
type GetPresignedUrlApiV1FilesPresignGetParameters = paths["/api/v1/files/presign"]["get"]["parameters"];
type GetPresignedUrlApiV1FilesPresignGetData = paths["/api/v1/files/presign"]["get"]["responses"]["200"]["content"]["application/json"];
type GetPresignedUrlApiV1FilesPresignGetError = paths["/api/v1/files/presign"]["get"]["responses"]["422"]["content"]["application/json"];
type GenerateImageApiV1ImageGeneratePostSchema = {
    method: "post";
    url: "/api/v1/image/generate";
    mediaType: [
        "application/json"
    ];
};
type GenerateImageApiV1ImageGeneratePostParameters = paths["/api/v1/image/generate"]["post"]["parameters"];
type GenerateImageApiV1ImageGeneratePostData = paths["/api/v1/image/generate"]["post"]["responses"]["200"]["content"]["application/json"];
type GenerateImageApiV1ImageGeneratePostError = paths["/api/v1/image/generate"]["post"]["responses"]["422"]["content"]["application/json"];
type GenerateImageApiV1ImageGeneratePostBody = paths["/api/v1/image/generate"]["post"]["requestBody"]["content"]["application/json"];
type GetImageStatusApiV1ImageStatusImageIdGetSchema = {
    method: "get";
    url: "/api/v1/image/status/{image_id}";
};
type GetImageStatusApiV1ImageStatusImageIdGetParameters = paths["/api/v1/image/status/{image_id}"]["get"]["parameters"];
type GetImageStatusApiV1ImageStatusImageIdGetData = paths["/api/v1/image/status/{image_id}"]["get"]["responses"]["200"]["content"]["application/json"];
type GetImageStatusApiV1ImageStatusImageIdGetError = null | paths["/api/v1/image/status/{image_id}"]["get"]["responses"]["422"]["content"]["application/json"];
type GetImageStylesApiV1ImageStylesGetSchema = {
    method: "get";
    url: "/api/v1/image/styles";
};
type GetImageStylesApiV1ImageStylesGetParameters = undefined;
type GetImageStylesApiV1ImageStylesGetData = paths["/api/v1/image/styles"]["get"]["responses"]["200"]["content"]["application/json"];
type GetImageStylesApiV1ImageStylesGetError = unknown;
type LikeImageApiV1ImageLikeImageIdPostSchema = {
    method: "post";
    url: "/api/v1/image/like/{image_id}";
};
type LikeImageApiV1ImageLikeImageIdPostParameters = paths["/api/v1/image/like/{image_id}"]["post"]["parameters"];
type LikeImageApiV1ImageLikeImageIdPostData = paths["/api/v1/image/like/{image_id}"]["post"]["responses"]["200"]["content"]["application/json"];
type LikeImageApiV1ImageLikeImageIdPostError = paths["/api/v1/image/like/{image_id}"]["post"]["responses"]["422"]["content"]["application/json"];
type LikeImageApiV1ImageLikeImageIdPostBody = undefined;
type DislikeImageApiV1ImageDislikeImageIdPostSchema = {
    method: "post";
    url: "/api/v1/image/dislike/{image_id}";
};
type DislikeImageApiV1ImageDislikeImageIdPostParameters = paths["/api/v1/image/dislike/{image_id}"]["post"]["parameters"];
type DislikeImageApiV1ImageDislikeImageIdPostData = paths["/api/v1/image/dislike/{image_id}"]["post"]["responses"]["200"]["content"]["application/json"];
type DislikeImageApiV1ImageDislikeImageIdPostError = paths["/api/v1/image/dislike/{image_id}"]["post"]["responses"]["422"]["content"]["application/json"];
type DislikeImageApiV1ImageDislikeImageIdPostBody = undefined;
