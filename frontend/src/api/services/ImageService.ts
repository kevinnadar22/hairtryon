/**
 * This file was auto-generated by @openapi-qraft/cli.
 * Do not make direct changes to the file.
 */

import type { paths } from "../schema";
import type { DeepReadonly, InvalidateQueryFilters, MutationFiltersByMutationKey, MutationFiltersByParameters, MutationVariables, OperationError, OperationInfiniteData, PartialParameters, QueryFiltersByParameters, QueryFiltersByQueryKey, QueryFnOptionsByParameters, QueryFnOptionsByQueryKey, RequestFnResponse, ServiceOperationEnsureInfiniteQueryDataOptions, ServiceOperationEnsureQueryDataOptions, ServiceOperationFetchInfiniteQueryOptions, ServiceOperationFetchQueryOptions, ServiceOperationInfiniteQueryKey, ServiceOperationMutationFnOptions, ServiceOperationMutationKey, ServiceOperationQueryKey, ServiceOperationUseMutationOptions, UseQueryOptionsForUseQueries, UseQueryOptionsForUseSuspenseQuery, WithOptional, QraftServiceOperationsToken } from "@openapi-qraft/tanstack-query-react-types";
import type { CancelOptions, DefinedInitialDataInfiniteOptions, DefinedInitialDataOptions, DefinedUseInfiniteQueryResult, DefinedUseQueryResult, InfiniteQueryPageParamsOptions, InvalidateOptions, Mutation, MutationCache, MutationState, NoInfer, QueryState, RefetchOptions, ResetOptions, SetDataOptions, UndefinedInitialDataInfiniteOptions, UndefinedInitialDataOptions, Updater, UseInfiniteQueryResult, UseMutationResult, UseQueryResult, UseSuspenseInfiniteQueryOptions, UseSuspenseInfiniteQueryResult, UseSuspenseQueryOptions, UseSuspenseQueryResult } from "@tanstack/react-query";
export interface ImageService {
    /**
     * @summary Generate Image
     * @description Initiate an image generation request.
     *
     * Args:
     *     data (ImageGenRequest): User input including style ID and input image URL.
     *     background_tasks (BackgroundTasks): FastAPI background task handler.
     *     current_user (User): Authenticated user via dependency.
     *     db: Database session.
     *
     * Returns:
     *     ImageGenResponse: Contains image_id and confirmation message.
     *
     * Raises:
     *     NotEnoughCreditsException: If user has not enough credits.
     *     HTTPException: If database record creation fails.
     */
    generateImageApiV1ImageGeneratePost: {
        /**
         * @summary Generate Image
         * @description Initiate an image generation request.
         *
         * Args:
         *     data (ImageGenRequest): User input including style ID and input image URL.
         *     background_tasks (BackgroundTasks): FastAPI background task handler.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenResponse: Contains image_id and confirmation message.
         *
         * Raises:
         *     NotEnoughCreditsException: If user has not enough credits.
         *     HTTPException: If database record creation fails.
         */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: ServiceOperationMutationFnOptions<GenerateImageApiV1ImageGeneratePostBody, GenerateImageApiV1ImageGeneratePostParameters, TMeta, TSignal>, client?: (schema: GenerateImageApiV1ImageGeneratePostSchema, options: ServiceOperationMutationFnOptions<GenerateImageApiV1ImageGeneratePostBody, GenerateImageApiV1ImageGeneratePostParameters, TMeta, TSignal>) => Promise<RequestFnResponse<GenerateImageApiV1ImageGeneratePostData, GenerateImageApiV1ImageGeneratePostError>>): Promise<RequestFnResponse<GenerateImageApiV1ImageGeneratePostData, GenerateImageApiV1ImageGeneratePostError>>;
        /**
         * @summary Generate Image
         * @description Initiate an image generation request.
         *
         * Args:
         *     data (ImageGenRequest): User input including style ID and input image URL.
         *     background_tasks (BackgroundTasks): FastAPI background task handler.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenResponse: Contains image_id and confirmation message.
         *
         * Raises:
         *     NotEnoughCreditsException: If user has not enough credits.
         *     HTTPException: If database record creation fails.
         */
        getMutationKey(parameters: DeepReadonly<GenerateImageApiV1ImageGeneratePostParameters> | void): ServiceOperationMutationKey<GenerateImageApiV1ImageGeneratePostSchema, GenerateImageApiV1ImageGeneratePostParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Generate Image
         * @description Initiate an image generation request.
         *
         * Args:
         *     data (ImageGenRequest): User input including style ID and input image URL.
         *     background_tasks (BackgroundTasks): FastAPI background task handler.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenResponse: Contains image_id and confirmation message.
         *
         * Raises:
         *     NotEnoughCreditsException: If user has not enough credits.
         *     HTTPException: If database record creation fails.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.imageService.generateImageApiV1ImageGeneratePost.useMutation({
         *     cookie: {
         *         access_token: accessToken
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.imageService.generateImageApiV1ImageGeneratePost.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     cookie: {
         *         access_token: accessToken
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends GenerateImageApiV1ImageGeneratePostBody, TContext = unknown>(parameters: DeepReadonly<GenerateImageApiV1ImageGeneratePostParameters>, options?: ServiceOperationUseMutationOptions<GenerateImageApiV1ImageGeneratePostSchema, GenerateImageApiV1ImageGeneratePostData, GenerateImageApiV1ImageGeneratePostParameters, TVariables, OperationError<GenerateImageApiV1ImageGeneratePostError>, TContext>): UseMutationResult<GenerateImageApiV1ImageGeneratePostData, OperationError<GenerateImageApiV1ImageGeneratePostError>, TVariables, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Generate Image
         * @description Initiate an image generation request.
         *
         * Args:
         *     data (ImageGenRequest): User input including style ID and input image URL.
         *     background_tasks (BackgroundTasks): FastAPI background task handler.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenResponse: Contains image_id and confirmation message.
         *
         * Raises:
         *     NotEnoughCreditsException: If user has not enough credits.
         *     HTTPException: If database record creation fails.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.imageService.generateImageApiV1ImageGeneratePost.useMutation({
         *     cookie: {
         *         access_token: accessToken
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.imageService.generateImageApiV1ImageGeneratePost.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     cookie: {
         *         access_token: accessToken
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<GenerateImageApiV1ImageGeneratePostBody, GenerateImageApiV1ImageGeneratePostParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<GenerateImageApiV1ImageGeneratePostSchema, GenerateImageApiV1ImageGeneratePostData, GenerateImageApiV1ImageGeneratePostParameters, TVariables, OperationError<GenerateImageApiV1ImageGeneratePostError>, TContext>): UseMutationResult<GenerateImageApiV1ImageGeneratePostData, OperationError<GenerateImageApiV1ImageGeneratePostError>, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @summary Generate Image
         * @description Initiate an image generation request.
         *
         * Args:
         *     data (ImageGenRequest): User input including style ID and input image URL.
         *     background_tasks (BackgroundTasks): FastAPI background task handler.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenResponse: Contains image_id and confirmation message.
         *
         * Raises:
         *     NotEnoughCreditsException: If user has not enough credits.
         *     HTTPException: If database record creation fails.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const generateImageApiV1ImageGeneratePostTotal = qraft.imageService.generateImageApiV1ImageGeneratePost.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const generateImageApiV1ImageGeneratePostTotal = qraft.imageService.generateImageApiV1ImageGeneratePost.useIsMutating({
         *     parameters: {
         *         cookie: {
         *             access_token: accessToken
         *         }
         *     }
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<GenerateImageApiV1ImageGeneratePostBody, GenerateImageApiV1ImageGeneratePostData, GenerateImageApiV1ImageGeneratePostParameters, OperationError<GenerateImageApiV1ImageGeneratePostError>, TContext> | MutationFiltersByMutationKey<GenerateImageApiV1ImageGeneratePostSchema, GenerateImageApiV1ImageGeneratePostBody, GenerateImageApiV1ImageGeneratePostData, GenerateImageApiV1ImageGeneratePostParameters, OperationError<GenerateImageApiV1ImageGeneratePostError>, TContext>): number;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @summary Generate Image
         * @description Initiate an image generation request.
         *
         * Args:
         *     data (ImageGenRequest): User input including style ID and input image URL.
         *     background_tasks (BackgroundTasks): FastAPI background task handler.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenResponse: Contains image_id and confirmation message.
         *
         * Raises:
         *     NotEnoughCreditsException: If user has not enough credits.
         *     HTTPException: If database record creation fails.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const generateImageApiV1ImageGeneratePostPendingMutationVariables = qraft.imageService.generateImageApiV1ImageGeneratePost.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const generateImageApiV1ImageGeneratePostMutationData = qraft.imageService.generateImageApiV1ImageGeneratePost.useMutationState({
         *     filters: {
         *         parameters: {
         *             cookie: {
         *                 access_token: accessToken
         *             }
         *         }
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<GenerateImageApiV1ImageGeneratePostData, OperationError<GenerateImageApiV1ImageGeneratePostError>, MutationVariables<GenerateImageApiV1ImageGeneratePostBody, GenerateImageApiV1ImageGeneratePostParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<GenerateImageApiV1ImageGeneratePostBody, GenerateImageApiV1ImageGeneratePostData, GenerateImageApiV1ImageGeneratePostParameters, OperationError<GenerateImageApiV1ImageGeneratePostError>, TContext> | MutationFiltersByMutationKey<GenerateImageApiV1ImageGeneratePostSchema, GenerateImageApiV1ImageGeneratePostBody, GenerateImageApiV1ImageGeneratePostData, GenerateImageApiV1ImageGeneratePostParameters, OperationError<GenerateImageApiV1ImageGeneratePostError>, TContext>;
            select?: (mutation: Mutation<GenerateImageApiV1ImageGeneratePostData, OperationError<GenerateImageApiV1ImageGeneratePostError>, MutationVariables<GenerateImageApiV1ImageGeneratePostBody, GenerateImageApiV1ImageGeneratePostParameters>, TContext>) => TResult;
        }): Array<TResult>;
        /**
         * @summary Generate Image
         * @description Initiate an image generation request.
         *
         * Args:
         *     data (ImageGenRequest): User input including style ID and input image URL.
         *     background_tasks (BackgroundTasks): FastAPI background task handler.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenResponse: Contains image_id and confirmation message.
         *
         * Raises:
         *     NotEnoughCreditsException: If user has not enough credits.
         *     HTTPException: If database record creation fails.
         */
        isMutating<TContext>(filters?: MutationFiltersByParameters<GenerateImageApiV1ImageGeneratePostBody, GenerateImageApiV1ImageGeneratePostData, GenerateImageApiV1ImageGeneratePostParameters, OperationError<GenerateImageApiV1ImageGeneratePostError>, TContext> | MutationFiltersByMutationKey<GenerateImageApiV1ImageGeneratePostSchema, GenerateImageApiV1ImageGeneratePostBody, GenerateImageApiV1ImageGeneratePostData, GenerateImageApiV1ImageGeneratePostParameters, OperationError<GenerateImageApiV1ImageGeneratePostError>, TContext>): number;
        /**
         * Returns a `MutationCache` object that provides access to mutation cache operations
         * for the specific endpoint.
         *
         * @summary Generate Image
         * @description Initiate an image generation request.
         *
         * Args:
         *     data (ImageGenRequest): User input including style ID and input image URL.
         *     background_tasks (BackgroundTasks): FastAPI background task handler.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenResponse: Contains image_id and confirmation message.
         *
         * Raises:
         *     NotEnoughCreditsException: If user has not enough credits.
         *     HTTPException: If database record creation fails.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/query-client/getMutationCache|`getMutationCache(...)` documentation}
         *
         * @example Find a mutation with specific parameters
         * ```ts
         * const mutationCache = qraft.imageService.generateImageApiV1ImageGeneratePost.getMutationCache();
         * const mutation = mutationCache.find({
         *     parameters: {
         *         cookie: {
         *             access_token: accessToken
         *         }
         *     }
         * });
         * ```
         *
         * @example Find all mutations for the endpoint
         * ```ts
         * const mutationCache = qraft.imageService.generateImageApiV1ImageGeneratePost.getMutationCache();
         * const mutations = mutationCache.findAll();
         * ```
         */
        getMutationCache(): Omit<MutationCache, "find" | "findAll"> & {
            find<TContext = unknown>(filters: MutationFiltersByParameters<GenerateImageApiV1ImageGeneratePostBody, GenerateImageApiV1ImageGeneratePostData, GenerateImageApiV1ImageGeneratePostParameters, OperationError<GenerateImageApiV1ImageGeneratePostError>, TContext> | MutationFiltersByMutationKey<GenerateImageApiV1ImageGeneratePostSchema, GenerateImageApiV1ImageGeneratePostBody, GenerateImageApiV1ImageGeneratePostData, GenerateImageApiV1ImageGeneratePostParameters, OperationError<GenerateImageApiV1ImageGeneratePostError>, TContext>): Mutation<GenerateImageApiV1ImageGeneratePostData, GenerateImageApiV1ImageGeneratePostError, MutationVariables<GenerateImageApiV1ImageGeneratePostBody, GenerateImageApiV1ImageGeneratePostParameters>, TContext> | undefined;
            findAll<TContext = unknown>(filters?: MutationFiltersByParameters<GenerateImageApiV1ImageGeneratePostBody, GenerateImageApiV1ImageGeneratePostData, GenerateImageApiV1ImageGeneratePostParameters, OperationError<GenerateImageApiV1ImageGeneratePostError>, TContext> | MutationFiltersByMutationKey<GenerateImageApiV1ImageGeneratePostSchema, GenerateImageApiV1ImageGeneratePostBody, GenerateImageApiV1ImageGeneratePostData, GenerateImageApiV1ImageGeneratePostParameters, OperationError<GenerateImageApiV1ImageGeneratePostError>, TContext>): Array<Mutation<GenerateImageApiV1ImageGeneratePostData, GenerateImageApiV1ImageGeneratePostError, MutationVariables<GenerateImageApiV1ImageGeneratePostBody, GenerateImageApiV1ImageGeneratePostParameters>, TContext>>;
        };
        schema: GenerateImageApiV1ImageGeneratePostSchema;
        types: {
            parameters: GenerateImageApiV1ImageGeneratePostParameters;
            data: GenerateImageApiV1ImageGeneratePostData;
            error: GenerateImageApiV1ImageGeneratePostError;
            body: GenerateImageApiV1ImageGeneratePostBody;
        };
    };
    /**
     * @summary Get Image Status
     * @description Retrieve image generation status and results.
     *
     * Args:
     *     image_id (int): ID of the image generation record.
     *     current_user (User): Authenticated user via dependency.
     *     db: Database session.
     *
     * Returns:
     *     ImageGenStatusResponse: Status and output URL if completed.
     *
     * Raises:
     *     HTTPException: If image not found or doesn't belong to user.
     */
    getImageStatusApiV1ImageStatusImageIdGet: {
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetImageStatusApiV1ImageStatusImageIdGetParameters, TMeta, TSignal>), client?: (schema: GetImageStatusApiV1ImageStatusImageIdGetSchema, options: {
            parameters: GetImageStatusApiV1ImageStatusImageIdGetParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetError>>): Promise<RequestFnResponse<GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetError>>;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        getQueryKey(parameters: DeepReadonly<GetImageStatusApiV1ImageStatusImageIdGetParameters>): ServiceOperationQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.imageService.getImageStatusApiV1ImageStatusImageIdGet.useQuery({
         *     path: {
         *         image_id: imageId
         *     },
         *     cookie: {
         *         access_token: accessToken
         *     }
         * })
         * ```
         */
        useQuery<TData = GetImageStatusApiV1ImageStatusImageIdGetData>(parameters: ServiceOperationQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters> | (DeepReadonly<GetImageStatusApiV1ImageStatusImageIdGetParameters>), options?: Omit<UndefinedInitialDataOptions<GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetError, TData, ServiceOperationQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters>>, "queryKey">): UseQueryResult<TData, OperationError<GetImageStatusApiV1ImageStatusImageIdGetError>>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.imageService.getImageStatusApiV1ImageStatusImageIdGet.useQuery({
         *     path: {
         *         image_id: imageId
         *     },
         *     cookie: {
         *         access_token: accessToken
         *     }
         * })
         * ```
         */
        useQuery<TData = GetImageStatusApiV1ImageStatusImageIdGetData>(parameters: ServiceOperationQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters> | (DeepReadonly<GetImageStatusApiV1ImageStatusImageIdGetParameters>), options: Omit<DefinedInitialDataOptions<GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetError, TData, ServiceOperationQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters>>, "queryKey">): DefinedUseQueryResult<TData, OperationError<GetImageStatusApiV1ImageStatusImageIdGetError>>;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        getInfiniteQueryKey(parameters: DeepReadonly<GetImageStatusApiV1ImageStatusImageIdGetParameters>): ServiceOperationInfiniteQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.imageService.getImageStatusApiV1ImageStatusImageIdGet.useInfiniteQuery({
         *     path: {
         *         image_id: imageId
         *     },
         *     cookie: {
         *         access_token: accessToken
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetImageStatusApiV1ImageStatusImageIdGetParameters, TQueryFnData = GetImageStatusApiV1ImageStatusImageIdGetData, TData = OperationInfiniteData<TQueryFnData, GetImageStatusApiV1ImageStatusImageIdGetParameters>>(parameters: ServiceOperationInfiniteQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters> | (DeepReadonly<GetImageStatusApiV1ImageStatusImageIdGetParameters>), options: Omit<UndefinedInitialDataInfiniteOptions<TQueryFnData, GetImageStatusApiV1ImageStatusImageIdGetError, TData, ServiceOperationInfiniteQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>): UseInfiniteQueryResult<TData, OperationError<GetImageStatusApiV1ImageStatusImageIdGetError>>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.imageService.getImageStatusApiV1ImageStatusImageIdGet.useInfiniteQuery({
         *     path: {
         *         image_id: imageId
         *     },
         *     cookie: {
         *         access_token: accessToken
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetImageStatusApiV1ImageStatusImageIdGetParameters, TQueryFnData = GetImageStatusApiV1ImageStatusImageIdGetData, TData = OperationInfiniteData<TQueryFnData, GetImageStatusApiV1ImageStatusImageIdGetParameters>>(parameters: ServiceOperationInfiniteQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters> | (DeepReadonly<GetImageStatusApiV1ImageStatusImageIdGetParameters>), options: Omit<DefinedInitialDataInfiniteOptions<TQueryFnData, GetImageStatusApiV1ImageStatusImageIdGetError, TData, ServiceOperationInfiniteQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetImageStatusApiV1ImageStatusImageIdGetData, PartialParameters<DeepReadonly<TPageParam>>>): DefinedUseInfiniteQueryResult<TData, OperationError<GetImageStatusApiV1ImageStatusImageIdGetError>>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getImageStatusApiV1ImageStatusImageIdGetTotal = qraft.imageService.getImageStatusApiV1ImageStatusImageIdGet.useIsFetching()
         * ```
         * @example Checks the number of normal queries fetching with the specified parameters.
         * ```ts
         * const getImageStatusApiV1ImageStatusImageIdGetByParametersTotal = qraft.imageService.getImageStatusApiV1ImageStatusImageIdGet.useIsFetching({
         *     infinite: false,
         *     parameters: {
         *         path: {
         *             image_id: imageId
         *         },
         *         cookie: {
         *             access_token: accessToken
         *         }
         *     }
         * })
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, TInfinite, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetError> | QueryFiltersByQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, TInfinite, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getImageStatusApiV1ImageStatusImageIdGetResults = qraft.imageService.getImageStatusApiV1ImageStatusImageIdGet.useQueries({
         *     queries: [
         *         {
         *             path: {
         *                 image_id: imageId1
         *             },
         *             cookie: {
         *                 access_token: accessToken1
         *             }
         *         },
         *         {
         *             path: {
         *                 image_id: imageId2
         *             },
         *             cookie: {
         *                 access_token: accessToken2
         *             }
         *         }
         *     ]
         * });
         * getImageStatusApiV1ImageStatusImageIdGetResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getImageStatusApiV1ImageStatusImageIdGetCombinedResults = qraft.imageService.getImageStatusApiV1ImageStatusImageIdGet.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             path: {
         *                 image_id: imageId1
         *             },
         *             cookie: {
         *                 access_token: accessToken1
         *             }
         *         },
         *         {
         *             path: {
         *                 image_id: imageId2
         *             },
         *             cookie: {
         *                 access_token: accessToken2
         *             }
         *         }
         *     ]
         * });
         * getImageStatusApiV1ImageStatusImageIdGetCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetError>>, TCombinedResult = Array<UseQueryResult<GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetError>>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * Performs asynchronous data fetching with Suspense support.
         * Similar to useQuery but integrates with React Suspense for loading states.
         *
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
         * @example Suspense Query with parameters
         * ```ts
         * const data = qraft.imageService.getImageStatusApiV1ImageStatusImageIdGet.useSuspenseQuery({
         *     path: {
         *         image_id: imageId
         *     },
         *     cookie: {
         *         access_token: accessToken
         *     }
         * })
         * ```
         */
        useSuspenseQuery<TData = GetImageStatusApiV1ImageStatusImageIdGetData>(parameters: ServiceOperationQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters> | (DeepReadonly<GetImageStatusApiV1ImageStatusImageIdGetParameters>), options?: Omit<UseSuspenseQueryOptions<GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetError, TData, ServiceOperationQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters>>, "queryKey">): UseSuspenseQueryResult<TData, OperationError<GetImageStatusApiV1ImageStatusImageIdGetError>>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.imageService.getImageStatusApiV1ImageStatusImageIdGet.useSuspenseInfiniteQuery({
         *     path: {
         *         image_id: imageId
         *     },
         *     cookie: {
         *         access_token: accessToken
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetImageStatusApiV1ImageStatusImageIdGetParameters, TData = GetImageStatusApiV1ImageStatusImageIdGetData>(parameters: ServiceOperationInfiniteQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters> | (DeepReadonly<GetImageStatusApiV1ImageStatusImageIdGetParameters>), options: Omit<UseSuspenseInfiniteQueryOptions<GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetError, OperationInfiniteData<TData, GetImageStatusApiV1ImageStatusImageIdGetParameters>, ServiceOperationInfiniteQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetImageStatusApiV1ImageStatusImageIdGetData, PartialParameters<DeepReadonly<TPageParam>>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetImageStatusApiV1ImageStatusImageIdGetParameters>, OperationError<GetImageStatusApiV1ImageStatusImageIdGetError>>;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
         * Similar to useQueries but integrates with React Suspense for loading states.
         *
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
         * @example Basic usage with Suspense
         * ```ts
         * const getImageStatusApiV1ImageStatusImageIdGetData = qraft.imageService.getImageStatusApiV1ImageStatusImageIdGet.useSuspenseQueries({
         *     queries: [
         *         {
         *             path: {
         *                 image_id: imageId1
         *             },
         *             cookie: {
         *                 access_token: accessToken1
         *             }
         *         },
         *         {
         *             path: {
         *                 image_id: imageId2
         *             },
         *             cookie: {
         *                 access_token: accessToken2
         *             }
         *         }
         *     ]
         * });
         * getImageStatusApiV1ImageStatusImageIdGetResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example With data transformation using combine
         * ```ts
         * const getImageStatusApiV1ImageStatusImageIdGetCombinedData = qraft.imageService.getImageStatusApiV1ImageStatusImageIdGet.useSuspenseQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             path: {
         *                 image_id: imageId1
         *             },
         *             cookie: {
         *                 access_token: accessToken1
         *             }
         *         },
         *         {
         *             path: {
         *                 image_id: imageId2
         *             },
         *             cookie: {
         *                 access_token: accessToken2
         *             }
         *         }
         *     ]
         * });
         * getImageStatusApiV1ImageStatusImageIdGetCombinedData.forEach(data => console.log({ data }));
         * ```
         */
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetError>): Promise<GetImageStatusApiV1ImageStatusImageIdGetData>;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetError>): Promise<void>;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetError>): Promise<GetImageStatusApiV1ImageStatusImageIdGetData>;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        fetchInfiniteQuery<TPageParam extends GetImageStatusApiV1ImageStatusImageIdGetParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetParameters, DeepReadonly<TPageParam>, GetImageStatusApiV1ImageStatusImageIdGetError>): Promise<OperationInfiniteData<GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetParameters>>;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        prefetchInfiniteQuery<TPageParam extends GetImageStatusApiV1ImageStatusImageIdGetParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetParameters, DeepReadonly<TPageParam>, GetImageStatusApiV1ImageStatusImageIdGetError>): Promise<void>;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        ensureInfiniteQueryData<TPageParam extends GetImageStatusApiV1ImageStatusImageIdGetParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetParameters, DeepReadonly<TPageParam>, GetImageStatusApiV1ImageStatusImageIdGetError>): Promise<OperationInfiniteData<GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetParameters>>;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        getQueryData(parameters: ServiceOperationQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters> | (DeepReadonly<GetImageStatusApiV1ImageStatusImageIdGetParameters>)): GetImageStatusApiV1ImageStatusImageIdGetData | undefined;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters> | (DeepReadonly<GetImageStatusApiV1ImageStatusImageIdGetParameters>)): OperationInfiniteData<GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetParameters> | undefined;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, TInfinite, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetError> | QueryFiltersByQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, TInfinite, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters>,
            data: NoInfer<OperationInfiniteData<GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters>,
            data: GetImageStatusApiV1ImageStatusImageIdGetData | undefined
        ]>;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        getQueryState(parameters: ServiceOperationQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters> | (DeepReadonly<GetImageStatusApiV1ImageStatusImageIdGetParameters>)): QueryState<GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetError> | undefined;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        getInfiniteQueryState(parameters: DeepReadonly<GetImageStatusApiV1ImageStatusImageIdGetParameters> | ServiceOperationInfiniteQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters>): QueryState<OperationInfiniteData<GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetParameters>, GetImageStatusApiV1ImageStatusImageIdGetError> | undefined;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        setQueryData(parameters: (DeepReadonly<GetImageStatusApiV1ImageStatusImageIdGetParameters>) | ServiceOperationQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters>, updater: Updater<NoInfer<GetImageStatusApiV1ImageStatusImageIdGetData> | undefined, NoInfer<DeepReadonly<GetImageStatusApiV1ImageStatusImageIdGetData>> | undefined>, options?: SetDataOptions): GetImageStatusApiV1ImageStatusImageIdGetData | undefined;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        setInfiniteQueryData(parameters: (DeepReadonly<GetImageStatusApiV1ImageStatusImageIdGetParameters>) | ServiceOperationInfiniteQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetParameters>> | undefined, NoInfer<DeepReadonly<OperationInfiniteData<GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetParameters>>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetImageStatusApiV1ImageStatusImageIdGetData, GetImageStatusApiV1ImageStatusImageIdGetParameters> | undefined;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, TInfinite, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetError> | QueryFiltersByQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, TInfinite, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetError>, updater: Updater<NoInfer<GetImageStatusApiV1ImageStatusImageIdGetData> | undefined, NoInfer<GetImageStatusApiV1ImageStatusImageIdGetData> | undefined>, options?: SetDataOptions): Array<GetImageStatusApiV1ImageStatusImageIdGetData | undefined>;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, TInfinite, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetError>, options?: InvalidateOptions): Promise<void>;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, TInfinite, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetError> | QueryFiltersByQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, TInfinite, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetError>, options?: RefetchOptions): Promise<void>;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, TInfinite, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetError> | QueryFiltersByQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, TInfinite, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetError>, options?: CancelOptions): Promise<void>;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, TInfinite, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetError> | QueryFiltersByQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, TInfinite, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetError>): void;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, TInfinite, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetError> | QueryFiltersByQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, TInfinite, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetError>, options?: ResetOptions): Promise<void>;
        /**
         * @summary Get Image Status
         * @description Retrieve image generation status and results.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     ImageGenStatusResponse: Status and output URL if completed.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, TInfinite, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetError> | QueryFiltersByQueryKey<GetImageStatusApiV1ImageStatusImageIdGetSchema, GetImageStatusApiV1ImageStatusImageIdGetData, TInfinite, GetImageStatusApiV1ImageStatusImageIdGetParameters, GetImageStatusApiV1ImageStatusImageIdGetError>): number;
        schema: GetImageStatusApiV1ImageStatusImageIdGetSchema;
        types: {
            parameters: GetImageStatusApiV1ImageStatusImageIdGetParameters;
            data: GetImageStatusApiV1ImageStatusImageIdGetData;
            error: GetImageStatusApiV1ImageStatusImageIdGetError;
        };
    };
    /**
     * @summary Get Image Styles
     * @description Retrieve all available hairstyles.
     *
     * Args:
     *     current_user (User): Authenticated user via dependency.
     *     db: Database session.
     *
     * Returns:
     *     List[StylesResponse]: List of available styles with metadata.
     */
    getImageStylesApiV1ImageStylesGet: {
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<GetImageStylesApiV1ImageStylesGetParameters, TMeta, TSignal> | void), client?: (schema: GetImageStylesApiV1ImageStylesGetSchema, options: {
            parameters: GetImageStylesApiV1ImageStylesGetParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetError>>): Promise<RequestFnResponse<GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetError>>;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        getQueryKey(parameters: DeepReadonly<GetImageStylesApiV1ImageStylesGetParameters> | void): ServiceOperationQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.imageService.getImageStylesApiV1ImageStylesGet.useQuery()
         * ```
         */
        useQuery<TData = GetImageStylesApiV1ImageStylesGetData>(parameters: ServiceOperationQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters> | (DeepReadonly<GetImageStylesApiV1ImageStylesGetParameters> | void), options?: Omit<UndefinedInitialDataOptions<GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetError, TData, ServiceOperationQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters>>, "queryKey">): UseQueryResult<TData, OperationError<GetImageStylesApiV1ImageStylesGetError>>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.imageService.getImageStylesApiV1ImageStylesGet.useQuery()
         * ```
         */
        useQuery<TData = GetImageStylesApiV1ImageStylesGetData>(parameters: ServiceOperationQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters> | (DeepReadonly<GetImageStylesApiV1ImageStylesGetParameters> | void), options: Omit<DefinedInitialDataOptions<GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetError, TData, ServiceOperationQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters>>, "queryKey">): DefinedUseQueryResult<TData, OperationError<GetImageStylesApiV1ImageStylesGetError>>;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        getInfiniteQueryKey(parameters: DeepReadonly<GetImageStylesApiV1ImageStylesGetParameters> | void): ServiceOperationInfiniteQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.imageService.getImageStylesApiV1ImageStylesGet.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetImageStylesApiV1ImageStylesGetParameters, TQueryFnData = GetImageStylesApiV1ImageStylesGetData, TData = OperationInfiniteData<TQueryFnData, GetImageStylesApiV1ImageStylesGetParameters>>(parameters: ServiceOperationInfiniteQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters> | (DeepReadonly<GetImageStylesApiV1ImageStylesGetParameters> | void), options: Omit<UndefinedInitialDataInfiniteOptions<TQueryFnData, GetImageStylesApiV1ImageStylesGetError, TData, ServiceOperationInfiniteQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>): UseInfiniteQueryResult<TData, OperationError<GetImageStylesApiV1ImageStylesGetError>>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.imageService.getImageStylesApiV1ImageStylesGet.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends GetImageStylesApiV1ImageStylesGetParameters, TQueryFnData = GetImageStylesApiV1ImageStylesGetData, TData = OperationInfiniteData<TQueryFnData, GetImageStylesApiV1ImageStylesGetParameters>>(parameters: ServiceOperationInfiniteQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters> | (DeepReadonly<GetImageStylesApiV1ImageStylesGetParameters> | void), options: Omit<DefinedInitialDataInfiniteOptions<TQueryFnData, GetImageStylesApiV1ImageStylesGetError, TData, ServiceOperationInfiniteQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetImageStylesApiV1ImageStylesGetData, PartialParameters<DeepReadonly<TPageParam>>>): DefinedUseInfiniteQueryResult<TData, OperationError<GetImageStylesApiV1ImageStylesGetError>>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const getImageStylesApiV1ImageStylesGetTotal = qraft.imageService.getImageStylesApiV1ImageStylesGet.useIsFetching()
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, TInfinite, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetError> | QueryFiltersByQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, TInfinite, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const getImageStylesApiV1ImageStylesGetResults = qraft.imageService.getImageStylesApiV1ImageStylesGet.useQueries({
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getImageStylesApiV1ImageStylesGetResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const getImageStylesApiV1ImageStylesGetCombinedResults = qraft.imageService.getImageStylesApiV1ImageStylesGet.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getImageStylesApiV1ImageStylesGetCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetError>>, TCombinedResult = Array<UseQueryResult<GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetError>>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * Performs asynchronous data fetching with Suspense support.
         * Similar to useQuery but integrates with React Suspense for loading states.
         *
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
         * @example Suspense Query without parameters
         * ```ts
         * const data = qraft.imageService.getImageStylesApiV1ImageStylesGet.useSuspenseQuery()
         * ```
         */
        useSuspenseQuery<TData = GetImageStylesApiV1ImageStylesGetData>(parameters: ServiceOperationQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters> | (DeepReadonly<GetImageStylesApiV1ImageStylesGetParameters> | void), options?: Omit<UseSuspenseQueryOptions<GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetError, TData, ServiceOperationQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters>>, "queryKey">): UseSuspenseQueryResult<TData, OperationError<GetImageStylesApiV1ImageStylesGetError>>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.imageService.getImageStylesApiV1ImageStylesGet.useSuspenseInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends GetImageStylesApiV1ImageStylesGetParameters, TData = GetImageStylesApiV1ImageStylesGetData>(parameters: ServiceOperationInfiniteQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters> | (DeepReadonly<GetImageStylesApiV1ImageStylesGetParameters> | void), options: Omit<UseSuspenseInfiniteQueryOptions<GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetError, OperationInfiniteData<TData, GetImageStylesApiV1ImageStylesGetParameters>, ServiceOperationInfiniteQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<GetImageStylesApiV1ImageStylesGetData, PartialParameters<DeepReadonly<TPageParam>>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, GetImageStylesApiV1ImageStylesGetParameters>, OperationError<GetImageStylesApiV1ImageStylesGetError>>;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
         * Similar to useQueries but integrates with React Suspense for loading states.
         *
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
         * @example Basic usage with Suspense
         * ```ts
         * const getImageStylesApiV1ImageStylesGetData = qraft.imageService.getImageStylesApiV1ImageStylesGet.useSuspenseQueries({
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getImageStylesApiV1ImageStylesGetResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example With data transformation using combine
         * ```ts
         * const getImageStylesApiV1ImageStylesGetCombinedData = qraft.imageService.getImageStylesApiV1ImageStylesGet.useSuspenseQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * getImageStylesApiV1ImageStylesGetCombinedData.forEach(data => console.log({ data }));
         * ```
         */
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetError>>, TCombinedResult = Array<UseSuspenseQueryResult<GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        fetchQuery(options: ServiceOperationFetchQueryOptions<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetError> | void): Promise<GetImageStylesApiV1ImageStylesGetData>;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        prefetchQuery(options: ServiceOperationFetchQueryOptions<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetError> | void): Promise<void>;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetError> | void): Promise<GetImageStylesApiV1ImageStylesGetData>;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        fetchInfiniteQuery<TPageParam extends GetImageStylesApiV1ImageStylesGetParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetParameters, DeepReadonly<TPageParam>, GetImageStylesApiV1ImageStylesGetError> | void): Promise<OperationInfiniteData<GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetParameters>>;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        prefetchInfiniteQuery<TPageParam extends GetImageStylesApiV1ImageStylesGetParameters>(options: ServiceOperationFetchInfiniteQueryOptions<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetParameters, DeepReadonly<TPageParam>, GetImageStylesApiV1ImageStylesGetError> | void): Promise<void>;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        ensureInfiniteQueryData<TPageParam extends GetImageStylesApiV1ImageStylesGetParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetParameters, DeepReadonly<TPageParam>, GetImageStylesApiV1ImageStylesGetError> | void): Promise<OperationInfiniteData<GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetParameters>>;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        getQueryData(parameters: ServiceOperationQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters> | (DeepReadonly<GetImageStylesApiV1ImageStylesGetParameters> | void)): GetImageStylesApiV1ImageStylesGetData | undefined;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters> | (DeepReadonly<GetImageStylesApiV1ImageStylesGetParameters> | void)): OperationInfiniteData<GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetParameters> | undefined;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, TInfinite, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetError> | QueryFiltersByQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, TInfinite, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters>,
            data: NoInfer<OperationInfiniteData<GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters>,
            data: GetImageStylesApiV1ImageStylesGetData | undefined
        ]>;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        getQueryState(parameters: ServiceOperationQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters> | (DeepReadonly<GetImageStylesApiV1ImageStylesGetParameters> | void)): QueryState<GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetError> | undefined;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        getInfiniteQueryState(parameters: DeepReadonly<GetImageStylesApiV1ImageStylesGetParameters> | ServiceOperationInfiniteQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters> | void): QueryState<OperationInfiniteData<GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetParameters>, GetImageStylesApiV1ImageStylesGetError> | undefined;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        setQueryData(parameters: (DeepReadonly<GetImageStylesApiV1ImageStylesGetParameters> | undefined) | ServiceOperationQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters>, updater: Updater<NoInfer<GetImageStylesApiV1ImageStylesGetData> | undefined, NoInfer<DeepReadonly<GetImageStylesApiV1ImageStylesGetData>> | undefined>, options?: SetDataOptions): GetImageStylesApiV1ImageStylesGetData | undefined;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        setInfiniteQueryData(parameters: (DeepReadonly<GetImageStylesApiV1ImageStylesGetParameters> | undefined) | ServiceOperationInfiniteQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetParameters>, updater: Updater<NoInfer<OperationInfiniteData<GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetParameters>> | undefined, NoInfer<DeepReadonly<OperationInfiniteData<GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetParameters>>> | undefined>, options?: SetDataOptions): OperationInfiniteData<GetImageStylesApiV1ImageStylesGetData, GetImageStylesApiV1ImageStylesGetParameters> | undefined;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, TInfinite, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetError> | QueryFiltersByQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, TInfinite, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetError>, updater: Updater<NoInfer<GetImageStylesApiV1ImageStylesGetData> | undefined, NoInfer<GetImageStylesApiV1ImageStylesGetData> | undefined>, options?: SetDataOptions): Array<GetImageStylesApiV1ImageStylesGetData | undefined>;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, TInfinite, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetError>, options?: InvalidateOptions): Promise<void>;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, TInfinite, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetError> | QueryFiltersByQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, TInfinite, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetError>, options?: RefetchOptions): Promise<void>;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, TInfinite, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetError> | QueryFiltersByQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, TInfinite, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetError>, options?: CancelOptions): Promise<void>;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, TInfinite, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetError> | QueryFiltersByQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, TInfinite, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetError>): void;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, TInfinite, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetError> | QueryFiltersByQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, TInfinite, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetError>, options?: ResetOptions): Promise<void>;
        /**
         * @summary Get Image Styles
         * @description Retrieve all available hairstyles.
         *
         * Args:
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     List[StylesResponse]: List of available styles with metadata.
         */
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, TInfinite, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetError> | QueryFiltersByQueryKey<GetImageStylesApiV1ImageStylesGetSchema, GetImageStylesApiV1ImageStylesGetData, TInfinite, GetImageStylesApiV1ImageStylesGetParameters, GetImageStylesApiV1ImageStylesGetError>): number;
        schema: GetImageStylesApiV1ImageStylesGetSchema;
        types: {
            parameters: GetImageStylesApiV1ImageStylesGetParameters;
            data: GetImageStylesApiV1ImageStylesGetData;
            error: GetImageStylesApiV1ImageStylesGetError;
        };
    };
    /**
     * @summary Like Image
     * @description Like an image generation record.
     *
     * Args:
     *     image_id (int): ID of the image generation record.
     *     current_user (User): Authenticated user via dependency.
     *     db: Database session.
     *
     * Returns:
     *     bool: True if liked successfully, False otherwise.
     *
     * Raises:
     *     HTTPException: If image not found or doesn't belong to user.
     */
    likeImageApiV1ImageLikeImageIdPost: {
        /**
         * @summary Like Image
         * @description Like an image generation record.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     bool: True if liked successfully, False otherwise.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: ServiceOperationMutationFnOptions<LikeImageApiV1ImageLikeImageIdPostBody, LikeImageApiV1ImageLikeImageIdPostParameters, TMeta, TSignal>, client?: (schema: LikeImageApiV1ImageLikeImageIdPostSchema, options: ServiceOperationMutationFnOptions<LikeImageApiV1ImageLikeImageIdPostBody, LikeImageApiV1ImageLikeImageIdPostParameters, TMeta, TSignal>) => Promise<RequestFnResponse<LikeImageApiV1ImageLikeImageIdPostData, LikeImageApiV1ImageLikeImageIdPostError>>): Promise<RequestFnResponse<LikeImageApiV1ImageLikeImageIdPostData, LikeImageApiV1ImageLikeImageIdPostError>>;
        /**
         * @summary Like Image
         * @description Like an image generation record.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     bool: True if liked successfully, False otherwise.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        getMutationKey(parameters: DeepReadonly<LikeImageApiV1ImageLikeImageIdPostParameters> | void): ServiceOperationMutationKey<LikeImageApiV1ImageLikeImageIdPostSchema, LikeImageApiV1ImageLikeImageIdPostParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Like Image
         * @description Like an image generation record.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     bool: True if liked successfully, False otherwise.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.imageService.likeImageApiV1ImageLikeImageIdPost.useMutation({
         *     path: {
         *         image_id: imageId
         *     },
         *     cookie: {
         *         access_token: accessToken
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.imageService.likeImageApiV1ImageLikeImageIdPost.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         image_id: imageId
         *     },
         *     cookie: {
         *         access_token: accessToken
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends LikeImageApiV1ImageLikeImageIdPostBody, TContext = unknown>(parameters: DeepReadonly<LikeImageApiV1ImageLikeImageIdPostParameters>, options?: ServiceOperationUseMutationOptions<LikeImageApiV1ImageLikeImageIdPostSchema, LikeImageApiV1ImageLikeImageIdPostData, LikeImageApiV1ImageLikeImageIdPostParameters, TVariables, OperationError<LikeImageApiV1ImageLikeImageIdPostError>, TContext>): UseMutationResult<LikeImageApiV1ImageLikeImageIdPostData, OperationError<LikeImageApiV1ImageLikeImageIdPostError>, TVariables | void, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Like Image
         * @description Like an image generation record.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     bool: True if liked successfully, False otherwise.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.imageService.likeImageApiV1ImageLikeImageIdPost.useMutation({
         *     path: {
         *         image_id: imageId
         *     },
         *     cookie: {
         *         access_token: accessToken
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.imageService.likeImageApiV1ImageLikeImageIdPost.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         image_id: imageId
         *     },
         *     cookie: {
         *         access_token: accessToken
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<LikeImageApiV1ImageLikeImageIdPostBody, LikeImageApiV1ImageLikeImageIdPostParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<LikeImageApiV1ImageLikeImageIdPostSchema, LikeImageApiV1ImageLikeImageIdPostData, LikeImageApiV1ImageLikeImageIdPostParameters, TVariables, OperationError<LikeImageApiV1ImageLikeImageIdPostError>, TContext>): UseMutationResult<LikeImageApiV1ImageLikeImageIdPostData, OperationError<LikeImageApiV1ImageLikeImageIdPostError>, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @summary Like Image
         * @description Like an image generation record.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     bool: True if liked successfully, False otherwise.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const likeImageApiV1ImageLikeImageIdPostTotal = qraft.imageService.likeImageApiV1ImageLikeImageIdPost.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const likeImageApiV1ImageLikeImageIdPostTotal = qraft.imageService.likeImageApiV1ImageLikeImageIdPost.useIsMutating({
         *     parameters: {
         *         path: {
         *             image_id: imageId
         *         },
         *         cookie: {
         *             access_token: accessToken
         *         }
         *     }
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<LikeImageApiV1ImageLikeImageIdPostBody, LikeImageApiV1ImageLikeImageIdPostData, LikeImageApiV1ImageLikeImageIdPostParameters, OperationError<LikeImageApiV1ImageLikeImageIdPostError>, TContext> | MutationFiltersByMutationKey<LikeImageApiV1ImageLikeImageIdPostSchema, LikeImageApiV1ImageLikeImageIdPostBody, LikeImageApiV1ImageLikeImageIdPostData, LikeImageApiV1ImageLikeImageIdPostParameters, OperationError<LikeImageApiV1ImageLikeImageIdPostError>, TContext>): number;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @summary Like Image
         * @description Like an image generation record.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     bool: True if liked successfully, False otherwise.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const likeImageApiV1ImageLikeImageIdPostPendingMutationVariables = qraft.imageService.likeImageApiV1ImageLikeImageIdPost.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const likeImageApiV1ImageLikeImageIdPostMutationData = qraft.imageService.likeImageApiV1ImageLikeImageIdPost.useMutationState({
         *     filters: {
         *         parameters: {
         *             path: {
         *                 image_id: imageId
         *             },
         *             cookie: {
         *                 access_token: accessToken
         *             }
         *         }
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<LikeImageApiV1ImageLikeImageIdPostData, OperationError<LikeImageApiV1ImageLikeImageIdPostError>, MutationVariables<LikeImageApiV1ImageLikeImageIdPostBody, LikeImageApiV1ImageLikeImageIdPostParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<LikeImageApiV1ImageLikeImageIdPostBody, LikeImageApiV1ImageLikeImageIdPostData, LikeImageApiV1ImageLikeImageIdPostParameters, OperationError<LikeImageApiV1ImageLikeImageIdPostError>, TContext> | MutationFiltersByMutationKey<LikeImageApiV1ImageLikeImageIdPostSchema, LikeImageApiV1ImageLikeImageIdPostBody, LikeImageApiV1ImageLikeImageIdPostData, LikeImageApiV1ImageLikeImageIdPostParameters, OperationError<LikeImageApiV1ImageLikeImageIdPostError>, TContext>;
            select?: (mutation: Mutation<LikeImageApiV1ImageLikeImageIdPostData, OperationError<LikeImageApiV1ImageLikeImageIdPostError>, MutationVariables<LikeImageApiV1ImageLikeImageIdPostBody, LikeImageApiV1ImageLikeImageIdPostParameters>, TContext>) => TResult;
        }): Array<TResult>;
        /**
         * @summary Like Image
         * @description Like an image generation record.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     bool: True if liked successfully, False otherwise.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        isMutating<TContext>(filters?: MutationFiltersByParameters<LikeImageApiV1ImageLikeImageIdPostBody, LikeImageApiV1ImageLikeImageIdPostData, LikeImageApiV1ImageLikeImageIdPostParameters, OperationError<LikeImageApiV1ImageLikeImageIdPostError>, TContext> | MutationFiltersByMutationKey<LikeImageApiV1ImageLikeImageIdPostSchema, LikeImageApiV1ImageLikeImageIdPostBody, LikeImageApiV1ImageLikeImageIdPostData, LikeImageApiV1ImageLikeImageIdPostParameters, OperationError<LikeImageApiV1ImageLikeImageIdPostError>, TContext>): number;
        /**
         * Returns a `MutationCache` object that provides access to mutation cache operations
         * for the specific endpoint.
         *
         * @summary Like Image
         * @description Like an image generation record.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     bool: True if liked successfully, False otherwise.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/query-client/getMutationCache|`getMutationCache(...)` documentation}
         *
         * @example Find a mutation with specific parameters
         * ```ts
         * const mutationCache = qraft.imageService.likeImageApiV1ImageLikeImageIdPost.getMutationCache();
         * const mutation = mutationCache.find({
         *     parameters: {
         *         path: {
         *             image_id: imageId
         *         },
         *         cookie: {
         *             access_token: accessToken
         *         }
         *     }
         * });
         * ```
         *
         * @example Find all mutations for the endpoint
         * ```ts
         * const mutationCache = qraft.imageService.likeImageApiV1ImageLikeImageIdPost.getMutationCache();
         * const mutations = mutationCache.findAll();
         * ```
         */
        getMutationCache(): Omit<MutationCache, "find" | "findAll"> & {
            find<TContext = unknown>(filters: MutationFiltersByParameters<LikeImageApiV1ImageLikeImageIdPostBody, LikeImageApiV1ImageLikeImageIdPostData, LikeImageApiV1ImageLikeImageIdPostParameters, OperationError<LikeImageApiV1ImageLikeImageIdPostError>, TContext> | MutationFiltersByMutationKey<LikeImageApiV1ImageLikeImageIdPostSchema, LikeImageApiV1ImageLikeImageIdPostBody, LikeImageApiV1ImageLikeImageIdPostData, LikeImageApiV1ImageLikeImageIdPostParameters, OperationError<LikeImageApiV1ImageLikeImageIdPostError>, TContext>): Mutation<LikeImageApiV1ImageLikeImageIdPostData, LikeImageApiV1ImageLikeImageIdPostError, MutationVariables<LikeImageApiV1ImageLikeImageIdPostBody, LikeImageApiV1ImageLikeImageIdPostParameters>, TContext> | undefined;
            findAll<TContext = unknown>(filters?: MutationFiltersByParameters<LikeImageApiV1ImageLikeImageIdPostBody, LikeImageApiV1ImageLikeImageIdPostData, LikeImageApiV1ImageLikeImageIdPostParameters, OperationError<LikeImageApiV1ImageLikeImageIdPostError>, TContext> | MutationFiltersByMutationKey<LikeImageApiV1ImageLikeImageIdPostSchema, LikeImageApiV1ImageLikeImageIdPostBody, LikeImageApiV1ImageLikeImageIdPostData, LikeImageApiV1ImageLikeImageIdPostParameters, OperationError<LikeImageApiV1ImageLikeImageIdPostError>, TContext>): Array<Mutation<LikeImageApiV1ImageLikeImageIdPostData, LikeImageApiV1ImageLikeImageIdPostError, MutationVariables<LikeImageApiV1ImageLikeImageIdPostBody, LikeImageApiV1ImageLikeImageIdPostParameters>, TContext>>;
        };
        schema: LikeImageApiV1ImageLikeImageIdPostSchema;
        types: {
            parameters: LikeImageApiV1ImageLikeImageIdPostParameters;
            data: LikeImageApiV1ImageLikeImageIdPostData;
            error: LikeImageApiV1ImageLikeImageIdPostError;
            body: LikeImageApiV1ImageLikeImageIdPostBody;
        };
    };
    /**
     * @summary Dislike Image
     * @description Dislike an image generation record.
     *
     * Args:
     *     image_id (int): ID of the image generation record.
     *     current_user (User): Authenticated user via dependency.
     *     db: Database session.
     *
     * Returns:
     *     bool: True if disliked successfully, False otherwise.
     *
     * Raises:
     *     HTTPException: If image not found or doesn't belong to user.
     */
    dislikeImageApiV1ImageDislikeImageIdPost: {
        /**
         * @summary Dislike Image
         * @description Dislike an image generation record.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     bool: True if disliked successfully, False otherwise.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: ServiceOperationMutationFnOptions<DislikeImageApiV1ImageDislikeImageIdPostBody, DislikeImageApiV1ImageDislikeImageIdPostParameters, TMeta, TSignal>, client?: (schema: DislikeImageApiV1ImageDislikeImageIdPostSchema, options: ServiceOperationMutationFnOptions<DislikeImageApiV1ImageDislikeImageIdPostBody, DislikeImageApiV1ImageDislikeImageIdPostParameters, TMeta, TSignal>) => Promise<RequestFnResponse<DislikeImageApiV1ImageDislikeImageIdPostData, DislikeImageApiV1ImageDislikeImageIdPostError>>): Promise<RequestFnResponse<DislikeImageApiV1ImageDislikeImageIdPostData, DislikeImageApiV1ImageDislikeImageIdPostError>>;
        /**
         * @summary Dislike Image
         * @description Dislike an image generation record.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     bool: True if disliked successfully, False otherwise.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        getMutationKey(parameters: DeepReadonly<DislikeImageApiV1ImageDislikeImageIdPostParameters> | void): ServiceOperationMutationKey<DislikeImageApiV1ImageDislikeImageIdPostSchema, DislikeImageApiV1ImageDislikeImageIdPostParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Dislike Image
         * @description Dislike an image generation record.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     bool: True if disliked successfully, False otherwise.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.imageService.dislikeImageApiV1ImageDislikeImageIdPost.useMutation({
         *     path: {
         *         image_id: imageId
         *     },
         *     cookie: {
         *         access_token: accessToken
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.imageService.dislikeImageApiV1ImageDislikeImageIdPost.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         image_id: imageId
         *     },
         *     cookie: {
         *         access_token: accessToken
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends DislikeImageApiV1ImageDislikeImageIdPostBody, TContext = unknown>(parameters: DeepReadonly<DislikeImageApiV1ImageDislikeImageIdPostParameters>, options?: ServiceOperationUseMutationOptions<DislikeImageApiV1ImageDislikeImageIdPostSchema, DislikeImageApiV1ImageDislikeImageIdPostData, DislikeImageApiV1ImageDislikeImageIdPostParameters, TVariables, OperationError<DislikeImageApiV1ImageDislikeImageIdPostError>, TContext>): UseMutationResult<DislikeImageApiV1ImageDislikeImageIdPostData, OperationError<DislikeImageApiV1ImageDislikeImageIdPostError>, TVariables | void, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Dislike Image
         * @description Dislike an image generation record.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     bool: True if disliked successfully, False otherwise.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.imageService.dislikeImageApiV1ImageDislikeImageIdPost.useMutation({
         *     path: {
         *         image_id: imageId
         *     },
         *     cookie: {
         *         access_token: accessToken
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.imageService.dislikeImageApiV1ImageDislikeImageIdPost.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         image_id: imageId
         *     },
         *     cookie: {
         *         access_token: accessToken
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<DislikeImageApiV1ImageDislikeImageIdPostBody, DislikeImageApiV1ImageDislikeImageIdPostParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<DislikeImageApiV1ImageDislikeImageIdPostSchema, DislikeImageApiV1ImageDislikeImageIdPostData, DislikeImageApiV1ImageDislikeImageIdPostParameters, TVariables, OperationError<DislikeImageApiV1ImageDislikeImageIdPostError>, TContext>): UseMutationResult<DislikeImageApiV1ImageDislikeImageIdPostData, OperationError<DislikeImageApiV1ImageDislikeImageIdPostError>, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @summary Dislike Image
         * @description Dislike an image generation record.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     bool: True if disliked successfully, False otherwise.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const dislikeImageApiV1ImageDislikeImageIdPostTotal = qraft.imageService.dislikeImageApiV1ImageDislikeImageIdPost.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const dislikeImageApiV1ImageDislikeImageIdPostTotal = qraft.imageService.dislikeImageApiV1ImageDislikeImageIdPost.useIsMutating({
         *     parameters: {
         *         path: {
         *             image_id: imageId
         *         },
         *         cookie: {
         *             access_token: accessToken
         *         }
         *     }
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<DislikeImageApiV1ImageDislikeImageIdPostBody, DislikeImageApiV1ImageDislikeImageIdPostData, DislikeImageApiV1ImageDislikeImageIdPostParameters, OperationError<DislikeImageApiV1ImageDislikeImageIdPostError>, TContext> | MutationFiltersByMutationKey<DislikeImageApiV1ImageDislikeImageIdPostSchema, DislikeImageApiV1ImageDislikeImageIdPostBody, DislikeImageApiV1ImageDislikeImageIdPostData, DislikeImageApiV1ImageDislikeImageIdPostParameters, OperationError<DislikeImageApiV1ImageDislikeImageIdPostError>, TContext>): number;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @summary Dislike Image
         * @description Dislike an image generation record.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     bool: True if disliked successfully, False otherwise.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const dislikeImageApiV1ImageDislikeImageIdPostPendingMutationVariables = qraft.imageService.dislikeImageApiV1ImageDislikeImageIdPost.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const dislikeImageApiV1ImageDislikeImageIdPostMutationData = qraft.imageService.dislikeImageApiV1ImageDislikeImageIdPost.useMutationState({
         *     filters: {
         *         parameters: {
         *             path: {
         *                 image_id: imageId
         *             },
         *             cookie: {
         *                 access_token: accessToken
         *             }
         *         }
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<DislikeImageApiV1ImageDislikeImageIdPostData, OperationError<DislikeImageApiV1ImageDislikeImageIdPostError>, MutationVariables<DislikeImageApiV1ImageDislikeImageIdPostBody, DislikeImageApiV1ImageDislikeImageIdPostParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<DislikeImageApiV1ImageDislikeImageIdPostBody, DislikeImageApiV1ImageDislikeImageIdPostData, DislikeImageApiV1ImageDislikeImageIdPostParameters, OperationError<DislikeImageApiV1ImageDislikeImageIdPostError>, TContext> | MutationFiltersByMutationKey<DislikeImageApiV1ImageDislikeImageIdPostSchema, DislikeImageApiV1ImageDislikeImageIdPostBody, DislikeImageApiV1ImageDislikeImageIdPostData, DislikeImageApiV1ImageDislikeImageIdPostParameters, OperationError<DislikeImageApiV1ImageDislikeImageIdPostError>, TContext>;
            select?: (mutation: Mutation<DislikeImageApiV1ImageDislikeImageIdPostData, OperationError<DislikeImageApiV1ImageDislikeImageIdPostError>, MutationVariables<DislikeImageApiV1ImageDislikeImageIdPostBody, DislikeImageApiV1ImageDislikeImageIdPostParameters>, TContext>) => TResult;
        }): Array<TResult>;
        /**
         * @summary Dislike Image
         * @description Dislike an image generation record.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     bool: True if disliked successfully, False otherwise.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         */
        isMutating<TContext>(filters?: MutationFiltersByParameters<DislikeImageApiV1ImageDislikeImageIdPostBody, DislikeImageApiV1ImageDislikeImageIdPostData, DislikeImageApiV1ImageDislikeImageIdPostParameters, OperationError<DislikeImageApiV1ImageDislikeImageIdPostError>, TContext> | MutationFiltersByMutationKey<DislikeImageApiV1ImageDislikeImageIdPostSchema, DislikeImageApiV1ImageDislikeImageIdPostBody, DislikeImageApiV1ImageDislikeImageIdPostData, DislikeImageApiV1ImageDislikeImageIdPostParameters, OperationError<DislikeImageApiV1ImageDislikeImageIdPostError>, TContext>): number;
        /**
         * Returns a `MutationCache` object that provides access to mutation cache operations
         * for the specific endpoint.
         *
         * @summary Dislike Image
         * @description Dislike an image generation record.
         *
         * Args:
         *     image_id (int): ID of the image generation record.
         *     current_user (User): Authenticated user via dependency.
         *     db: Database session.
         *
         * Returns:
         *     bool: True if disliked successfully, False otherwise.
         *
         * Raises:
         *     HTTPException: If image not found or doesn't belong to user.
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/query-client/getMutationCache|`getMutationCache(...)` documentation}
         *
         * @example Find a mutation with specific parameters
         * ```ts
         * const mutationCache = qraft.imageService.dislikeImageApiV1ImageDislikeImageIdPost.getMutationCache();
         * const mutation = mutationCache.find({
         *     parameters: {
         *         path: {
         *             image_id: imageId
         *         },
         *         cookie: {
         *             access_token: accessToken
         *         }
         *     }
         * });
         * ```
         *
         * @example Find all mutations for the endpoint
         * ```ts
         * const mutationCache = qraft.imageService.dislikeImageApiV1ImageDislikeImageIdPost.getMutationCache();
         * const mutations = mutationCache.findAll();
         * ```
         */
        getMutationCache(): Omit<MutationCache, "find" | "findAll"> & {
            find<TContext = unknown>(filters: MutationFiltersByParameters<DislikeImageApiV1ImageDislikeImageIdPostBody, DislikeImageApiV1ImageDislikeImageIdPostData, DislikeImageApiV1ImageDislikeImageIdPostParameters, OperationError<DislikeImageApiV1ImageDislikeImageIdPostError>, TContext> | MutationFiltersByMutationKey<DislikeImageApiV1ImageDislikeImageIdPostSchema, DislikeImageApiV1ImageDislikeImageIdPostBody, DislikeImageApiV1ImageDislikeImageIdPostData, DislikeImageApiV1ImageDislikeImageIdPostParameters, OperationError<DislikeImageApiV1ImageDislikeImageIdPostError>, TContext>): Mutation<DislikeImageApiV1ImageDislikeImageIdPostData, DislikeImageApiV1ImageDislikeImageIdPostError, MutationVariables<DislikeImageApiV1ImageDislikeImageIdPostBody, DislikeImageApiV1ImageDislikeImageIdPostParameters>, TContext> | undefined;
            findAll<TContext = unknown>(filters?: MutationFiltersByParameters<DislikeImageApiV1ImageDislikeImageIdPostBody, DislikeImageApiV1ImageDislikeImageIdPostData, DislikeImageApiV1ImageDislikeImageIdPostParameters, OperationError<DislikeImageApiV1ImageDislikeImageIdPostError>, TContext> | MutationFiltersByMutationKey<DislikeImageApiV1ImageDislikeImageIdPostSchema, DislikeImageApiV1ImageDislikeImageIdPostBody, DislikeImageApiV1ImageDislikeImageIdPostData, DislikeImageApiV1ImageDislikeImageIdPostParameters, OperationError<DislikeImageApiV1ImageDislikeImageIdPostError>, TContext>): Array<Mutation<DislikeImageApiV1ImageDislikeImageIdPostData, DislikeImageApiV1ImageDislikeImageIdPostError, MutationVariables<DislikeImageApiV1ImageDislikeImageIdPostBody, DislikeImageApiV1ImageDislikeImageIdPostParameters>, TContext>>;
        };
        schema: DislikeImageApiV1ImageDislikeImageIdPostSchema;
        types: {
            parameters: DislikeImageApiV1ImageDislikeImageIdPostParameters;
            data: DislikeImageApiV1ImageDislikeImageIdPostData;
            error: DislikeImageApiV1ImageDislikeImageIdPostError;
            body: DislikeImageApiV1ImageDislikeImageIdPostBody;
        };
    };
}
/**
 * @summary Generate Image
 * @description Initiate an image generation request.
 *
 * Args:
 *     data (ImageGenRequest): User input including style ID and input image URL.
 *     background_tasks (BackgroundTasks): FastAPI background task handler.
 *     current_user (User): Authenticated user via dependency.
 *     db: Database session.
 *
 * Returns:
 *     ImageGenResponse: Contains image_id and confirmation message.
 *
 * Raises:
 *     NotEnoughCreditsException: If user has not enough credits.
 *     HTTPException: If database record creation fails.
 */
export const generateImageApiV1ImageGeneratePost = {
    schema: {
        method: "post",
        url: "/api/v1/image/generate",
        mediaType: ["application/json"]
    }
} as {
    schema: GenerateImageApiV1ImageGeneratePostSchema;
    [QraftServiceOperationsToken]: ImageService["generateImageApiV1ImageGeneratePost"];
};
/**
 * @summary Get Image Status
 * @description Retrieve image generation status and results.
 *
 * Args:
 *     image_id (int): ID of the image generation record.
 *     current_user (User): Authenticated user via dependency.
 *     db: Database session.
 *
 * Returns:
 *     ImageGenStatusResponse: Status and output URL if completed.
 *
 * Raises:
 *     HTTPException: If image not found or doesn't belong to user.
 */
export const getImageStatusApiV1ImageStatusImageIdGet = {
    schema: {
        method: "get",
        url: "/api/v1/image/status/{image_id}"
    }
} as {
    schema: GetImageStatusApiV1ImageStatusImageIdGetSchema;
    [QraftServiceOperationsToken]: ImageService["getImageStatusApiV1ImageStatusImageIdGet"];
};
/**
 * @summary Get Image Styles
 * @description Retrieve all available hairstyles.
 *
 * Args:
 *     current_user (User): Authenticated user via dependency.
 *     db: Database session.
 *
 * Returns:
 *     List[StylesResponse]: List of available styles with metadata.
 */
export const getImageStylesApiV1ImageStylesGet = {
    schema: {
        method: "get",
        url: "/api/v1/image/styles"
    }
} as {
    schema: GetImageStylesApiV1ImageStylesGetSchema;
    [QraftServiceOperationsToken]: ImageService["getImageStylesApiV1ImageStylesGet"];
};
/**
 * @summary Like Image
 * @description Like an image generation record.
 *
 * Args:
 *     image_id (int): ID of the image generation record.
 *     current_user (User): Authenticated user via dependency.
 *     db: Database session.
 *
 * Returns:
 *     bool: True if liked successfully, False otherwise.
 *
 * Raises:
 *     HTTPException: If image not found or doesn't belong to user.
 */
export const likeImageApiV1ImageLikeImageIdPost = {
    schema: {
        method: "post",
        url: "/api/v1/image/like/{image_id}"
    }
} as {
    schema: LikeImageApiV1ImageLikeImageIdPostSchema;
    [QraftServiceOperationsToken]: ImageService["likeImageApiV1ImageLikeImageIdPost"];
};
/**
 * @summary Dislike Image
 * @description Dislike an image generation record.
 *
 * Args:
 *     image_id (int): ID of the image generation record.
 *     current_user (User): Authenticated user via dependency.
 *     db: Database session.
 *
 * Returns:
 *     bool: True if disliked successfully, False otherwise.
 *
 * Raises:
 *     HTTPException: If image not found or doesn't belong to user.
 */
export const dislikeImageApiV1ImageDislikeImageIdPost = {
    schema: {
        method: "post",
        url: "/api/v1/image/dislike/{image_id}"
    }
} as {
    schema: DislikeImageApiV1ImageDislikeImageIdPostSchema;
    [QraftServiceOperationsToken]: ImageService["dislikeImageApiV1ImageDislikeImageIdPost"];
};
export const imageService = {
    generateImageApiV1ImageGeneratePost,
    getImageStatusApiV1ImageStatusImageIdGet,
    getImageStylesApiV1ImageStylesGet,
    likeImageApiV1ImageLikeImageIdPost,
    dislikeImageApiV1ImageDislikeImageIdPost
} as const;
type GenerateImageApiV1ImageGeneratePostSchema = {
    method: "post";
    url: "/api/v1/image/generate";
    mediaType: [
        "application/json"
    ];
};
type GenerateImageApiV1ImageGeneratePostParameters = paths["/api/v1/image/generate"]["post"]["parameters"];
type GenerateImageApiV1ImageGeneratePostData = paths["/api/v1/image/generate"]["post"]["responses"]["200"]["content"]["application/json"];
type GenerateImageApiV1ImageGeneratePostError = null | paths["/api/v1/image/generate"]["post"]["responses"]["422"]["content"]["application/json"] | null;
type GenerateImageApiV1ImageGeneratePostBody = paths["/api/v1/image/generate"]["post"]["requestBody"]["content"]["application/json"];
type GetImageStatusApiV1ImageStatusImageIdGetSchema = {
    method: "get";
    url: "/api/v1/image/status/{image_id}";
};
type GetImageStatusApiV1ImageStatusImageIdGetParameters = paths["/api/v1/image/status/{image_id}"]["get"]["parameters"];
type GetImageStatusApiV1ImageStatusImageIdGetData = paths["/api/v1/image/status/{image_id}"]["get"]["responses"]["200"]["content"]["application/json"];
type GetImageStatusApiV1ImageStatusImageIdGetError = null | paths["/api/v1/image/status/{image_id}"]["get"]["responses"]["422"]["content"]["application/json"] | null;
type GetImageStylesApiV1ImageStylesGetSchema = {
    method: "get";
    url: "/api/v1/image/styles";
};
type GetImageStylesApiV1ImageStylesGetParameters = undefined;
type GetImageStylesApiV1ImageStylesGetData = paths["/api/v1/image/styles"]["get"]["responses"]["200"]["content"]["application/json"];
type GetImageStylesApiV1ImageStylesGetError = null;
type LikeImageApiV1ImageLikeImageIdPostSchema = {
    method: "post";
    url: "/api/v1/image/like/{image_id}";
};
type LikeImageApiV1ImageLikeImageIdPostParameters = paths["/api/v1/image/like/{image_id}"]["post"]["parameters"];
type LikeImageApiV1ImageLikeImageIdPostData = paths["/api/v1/image/like/{image_id}"]["post"]["responses"]["200"]["content"]["application/json"];
type LikeImageApiV1ImageLikeImageIdPostError = paths["/api/v1/image/like/{image_id}"]["post"]["responses"]["422"]["content"]["application/json"] | null;
type LikeImageApiV1ImageLikeImageIdPostBody = undefined;
type DislikeImageApiV1ImageDislikeImageIdPostSchema = {
    method: "post";
    url: "/api/v1/image/dislike/{image_id}";
};
type DislikeImageApiV1ImageDislikeImageIdPostParameters = paths["/api/v1/image/dislike/{image_id}"]["post"]["parameters"];
type DislikeImageApiV1ImageDislikeImageIdPostData = paths["/api/v1/image/dislike/{image_id}"]["post"]["responses"]["200"]["content"]["application/json"];
type DislikeImageApiV1ImageDislikeImageIdPostError = paths["/api/v1/image/dislike/{image_id}"]["post"]["responses"]["422"]["content"]["application/json"] | null;
type DislikeImageApiV1ImageDislikeImageIdPostBody = undefined;
